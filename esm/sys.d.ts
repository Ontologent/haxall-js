export type JsObj = Obj | number | string | boolean | Function

/**
 * Enum is the base class for enum classes defined using the `enum`
 * keyword.  An enum models a fixed range of discrete values. 
 * Each value has an Int ordinal and a Str name.
 * 
 * Every enum class implicitly has the following slots
 * auto-generated by the compiler:
 * - a static const field for each name in the enum's range.
 * - a static field called "vals" which contains the list of
 *   discrete values indexed by ordinal.
 * - a static method called "fromStr" which maps an enum name to
 *   an enum instance
 * 
 * See [docLang::Enums](https://fantom.org/doc/docLang/Enums)
 * for details.
 */
export class Enum extends Obj {
  static type$: Type
  /**
   * Always returns name().
   */
  toStr(): string;
  /**
   * Compare based on ordinal value.
   */
  compare(obj: JsObj): number;
  /**
   * Enums are only equal if same instance using ===.
   */
  equals(obj: JsObj | null): boolean;
  /**
   * Get the programatic name for this enum.
   */
  name(): string;
  /**
   * Return ordinal value which is a zero based index into
   * values.
   */
  ordinal(): number;
}

/**
 * UnknownFacetErr indicates an attempt to access an undefined
 * facet.
 */
export class UnknownFacetErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): UnknownFacetErr;
}

/**
 * Zip is used to read/write compressed zip files and streams. 
 * Zip may be used in three modes:
 * 1. {@link open | Zip.open} is used to read a random access file
 *   and provides access to the entire contents with the ability
 *   to read select entries
 * 2. {@link read | Zip.read} is used to read a zip file from an
 *   input stream. Each entry is pulled off the stream using {@link readNext | readNext}
 * 3. {@link write | Zip.write} is used to write a zip file to an
 *   output stream. Each entry is written to the stream using {@link writeNext | writeNext}
 */
export class Zip extends Obj {
  static type$: Type
  /**
   * Construct a new GZIP output stream which wraps the given
   * output stream.
   */
  static gzipOutStream(out: OutStream): OutStream;
  /**
   * Static utility to unzip a zip file to the given directory.
   * Raise exception if there are any failures.  Return number of
   * files unzipped on success.
   */
  static unzipInto(zip: File, dir: File): number;
  /**
   * Get the underlying file or null if using streams.
   */
  file(): File | null;
  /**
   * Append a new file to the end of this zip file and return an
   * OutStream which may be used to write the file contents.  The
   * Uri must not contain a query or fragment; it may optionally
   * start with a slash.  Closing the OutStream will close only
   * this file entry - use Zip.close() when finished writing the
   * entire zip file.  Throw UnsupportedErr if zip is not writing
   * to an output stream.
   * 
   * Next entry options:
   * - comment: Str entry comment
   * - crc: Int CRC-32 of the uncompressed data
   * - extra: Buf for extra bytes data field
   * - level: Int between 9 (best compression) to 0 (no
   *   compression)
   * - compressedSize: Int for compressed size of data
   * - uncompressedSize: Int for uncompressed size of data
   * 
   * NOTE: setting level to 0 sets method to STORE, else to DEFLATED.
   * 
   * Examples:
   * ```
   * out := zip.writeNext(`/docs/test.txt`)
   * out.writeLine("test")
   * out.close
   * ```
   */
  writeNext(path: Uri, modifyTime?: DateTime, opts?: Map<string, JsObj | null> | null): OutStream;
  /**
   * Finish writing the contents of this zip file, but leave the
   * underlying OutStream open.  This method is guaranteed to
   * never throw an IOErr. Return true if the stream was finished
   * successfully or false if an error occurred.  Throw
   * UnsupportedErr if zip is not writing to an output stream.
   */
  finish(): boolean;
  /**
   * Construct a new GZIP input stream which wraps the given
   * input stream.
   */
  static gzipInStream(in$: InStream): InStream;
  /**
   * Create a Zip used to write a zip file to the specified
   * output stream.
   * 
   * Example:
   * ```
   * zip := Zip.write(File(`test.zip`).out)
   * out := zip.writeNext(`/path/hello.txt`)
   * out.writeLine("hello zip")
   * out.close
   * zip.close
   * ```
   */
  static write(out: OutStream): Zip;
  /**
   * Close this zip file for reading and writing.  If this zip
   * file is reading or writing a stream, then the underlying
   * stream is also closed.  This method is guaranteed to never
   * throw an IOErr.  Return true if the close was successful or
   * false if an error occurred.
   */
  close(): boolean;
  /**
   * If file is not null then return file.toStr, otherwise return
   * a suitable string representation.
   */
  toStr(): string;
  /**
   * Create a Zip used to read a zip file from the specified
   * input stream.
   * 
   * Example:
   * ```
   * zip := Zip.read(File(`test.zip`).in)
   * File? entry
   * while ((entry = zip.readNext()) != null)
   * {
   *   data := entry.readAllBuf
   *   echo("$entry size=$data.size")
   * }
   * zip.close
   * ```
   */
  static read(in$: InStream): Zip;
  /**
   * Construct a new deflate output stream which wraps the given
   * output stream, and compresses data using the "deflate"
   * compression format.  Options:
   * - level: Int between 9 (best compression) to 0 (no
   *   compression)
   * - nowrap: Bool false to suppress defalate header and adler
   *   checksum
   */
  static deflateOutStream(out: OutStream, opts?: Map<string, JsObj | null> | null): OutStream;
  /**
   * Read the next entry in the zip.  Use the File's input stream
   * to read the file contents.  Some file meta-data such as size
   * may not be available. Return null if at end of zip file. 
   * Throw UnsupportedErr if not reading from an input stream.
   */
  readNext(): File | null;
  /**
   * Call the specified function for every entry in the zip. Use
   * the File's input stream to read the file contents.  Some
   * file meta-data such as size may not be available. Throw
   * UnsupportedErr if not reading from an input stream.
   */
  readEach(c: ((arg0: File) => void)): void;
  /**
   * Return the contents of this zip as a map of Files.  The Uri
   * keys will start with a slash and be relative to this zip
   * file. Return null if using streams.
   */
  contents(): Map<Uri, File> | null;
  /**
   * Construct a new deflate input stream which wraps the given
   * input stream and inflates data written using the "deflate"
   * compression format.  Options:
   * - nowrap: Bool false to suppress defalate header and adler
   *   checksum
   */
  static deflateInStream(in$: InStream, opts?: Map<string, JsObj | null> | null): InStream;
  /**
   * Open the specified file as a zip file for reading.  If the
   * specified file does not exist, is not a valid file, or does
   * not support random access then throw IOErr.
   * 
   * Example:
   * ```
   * zip := Zip.open(File(`test.zip`))
   * txt := zip.contents[`/notice.txt`].readAllStr
   * zip.close
   * ```
   */
  static open(file: File): Zip;
}

/**
 * Serializable is a facet used to annotate types which can be
 * serialized. Objects are serialized via {@link OutStream.writeObj | sys::OutStream.writeObj}
 * and deserialized via {@link InStream.readObj | sys::InStream.readObj}.
 * 
 * See the [Serialization Doc](https://fantom.org/doc/docLang/Serialization)
 * for details.
 */
export class Serializable extends Obj implements Facet {
  static type$: Type
  /**
   * Simples are serialized atomically via a customized string
   * representation using the following rules:
   * - Override {@link Obj.toStr | sys::Obj.toStr} to return a
   *   suitable string representation of the object.
   * - Must declare a static method called `fromStr` which takes one `Str`
   *   parameter and returns an instance of the declaring type. 
   *   The `fromStr` method may contain additional parameters if they
   *   declare defaults.
   */
  simple(): boolean;
  __simple(it: boolean): void;
  /**
   * Collections are serialized with a collection of child
   * objects using the following  rules where `Item` is the item
   * type:
   * - Provide an `add(Item)` method to add child items during `readObj`
   * - Provide an `each(|Item| f)` method to iterate child items
   *   during `writeObj`
   */
  collection(): boolean;
  __collection(it: boolean): void;
  static make(f?: ((arg0: Serializable) => void) | null, ...args: unknown[]): Serializable;
}

/**
 * DateTime represents an absolute instance in time.  Fantom
 * time is normalized as nanosecond ticks since 1 Jan 2000 UTC
 * with a supported range of 1901 to 2099.  Fantom time does
 * not support leap seconds (same as Java and UNIX).  An
 * instance of DateTime also models the date and time of an
 * absolute instance against a specific {@link TimeZone | TimeZone}.
 * 
 * Also see [docLang](https://fantom.org/doc/docLang/DateTime).
 */
export class DateTime extends Obj {
  static type$: Type
  /**
   * Default value is "2000-01-01T00:00:00Z UTC".
   */
  static defVal(): DateTime;
  /**
   * Get the date component of this timestamp.
   */
  date(): Date;
  /**
   * Return the week number of the year as a number between 1 and
   * 53 using the given weekday as the start of the week
   * (defaults to current locale).
   */
  weekOfYear(startOfWeek?: Weekday): number;
  /**
   * Get the year as a number such as 2007.
   */
  year(): number;
  /**
   * Return the day of the year as a number between 1 and 365 (or
   * 1 to 366 if a leap year).
   */
  dayOfYear(): number;
  /**
   * Get the time zone associated with this date time.
   */
  tz(): TimeZone;
  /**
   * Get the day of the week for this time.
   */
  weekday(): Weekday;
  /**
   * Convenience for `toTimeZone(TimeZone.rel)`. See [docLang](https://fantom.org/doc/docLang/DateTime#relTimeZone).
   */
  toRel(): DateTime;
  /**
   * Get this date in Java milliseconds since the epoch of 1 Jan
   * 1970.
   */
  toJava(): number;
  /**
   * Return the number of hours for this date and this timezone.
   * Days which transition to DST will be 23 hours and days which
   * transition back to standard time will be 25 hours.  Note
   * there is one timezone "Lord_Howe" which has a 30min offset
   * which is not handled by this method (WTF).
   */
  hoursInDay(): number;
  /**
   * Return the current time as nanosecond ticks since 1 Jan 2000
   * UTC, but with the guarantee that every call returns a unique
   * value for the lifetime of this VM.  Since most platforms
   * don't actually support nanosecond resolution, the unused
   * nanoseconds are used as a counter to ensure uniqueness. 
   * However, bursts of calls may result in a drift from the
   * actual system time.  For example, if the platform's clock
   * supports millisecond resolution, then calling this method
   * more than one million times within a millisecond will
   * introduce a millisecond drift (1,000,000ns in a ms).
   */
  static nowUnique(): number;
  /**
   * Format this instance according to ISO 8601 using the
   * pattern:
   * ```
   * YYYY-MM-DD'T'hh:mm:ss.FFFz
   * ```
   * 
   * Also see {@link fromIso | fromIso}, {@link toStr | toStr}, and
   * {@link toHttpStr | toHttpStr}.
   */
  toIso(): string;
  /**
   * Get the day of the month as a number between 1 and 31.
   */
  day(): number;
  /**
   * Get the time zone's abbreviation for this time. See {@link TimeZone.stdAbbr | TimeZone.stdAbbr}
   * and {@link TimeZone.dstAbbr | TimeZone.dstAbbr}.
   */
  tzAbbr(): string;
  /**
   * Return programmatic string encoding formatted as follows:
   * ```
   * "YYYY-MM-DD'T'hh:mm:ss.FFFFFFFFFz zzzz"
   * ```
   * 
   * See {@link toLocale | toLocale} for the pattern legend.  The
   * base of the string encoding conforms to ISO 8601 and XML
   * Schema Part 2.  The Fantom format also appends the timezone
   * name to avoid the ambiguities associated with interpreting
   * the time zone offset.  Also see {@link toIso | toIso} and {@link toHttpStr | toHttpStr}.
   * 
   * Examples:
   * ```
   * "2000-04-03T00:00:00.123Z UTC"
   * "2006-10-31T01:02:03-05:00 New_York"
   * "2009-03-10T11:33:20Z London"
   * "2009-03-01T12:00:00+01:00 Amsterdam"
   * ```
   */
  toStr(): string;
  /**
   * Get this DateTime as a Fantom expression suitable for code
   * generation.
   */
  toCode(): string;
  /**
   * Create date for Java milliseconds since the epoch of 1 Jan
   * 1970 using the specified timezone (defaults to current).  If
   * millis are less than or equal to zero then return null or a
   * date before 1970 depending on the `negIsNull` flag.
   */
  static fromJava(millis: number, tz?: TimeZone, negIsNull?: boolean): DateTime | null;
  /**
   * Add a duration to compute a new time.  This method works off
   * absolute time, so adding 1days means to add 24 hours to the
   * ticks.  This might be a different time of day if on a DST
   * boundry.  Use {@link Date.plus | Date.plus} for daily
   * increments.
   * 
   * Example:
   * ```
   * nextHour := DateTime.now + 1hr
   * ```
   */
  plus(duration: Duration): DateTime;
  /**
   * Parse the string into a DateTime from the programmatic
   * encoding defined by {@link toStr | toStr}.  If the string
   * cannot be parsed into a valid DateTime and checked is false
   * then return null, otherwise throw ParseErr. Also see {@link fromIso | fromIso}
   * and {@link fromHttpStr | fromHttpStr}.
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): DateTime;
  /**
   * Get the month of this date.
   */
  month(): Month;
  /**
   * Return the current time as nanosecond ticks since 1 Jan 2000
   * UTC.
   */
  static nowTicks(): number;
  /**
   * Return nanosecond ticks for the hashcode.
   */
  hash(): number;
  /**
   * Convenience for `toTimeZone(TimeZone.utc)`.
   */
  toUtc(): DateTime;
  /**
   * Subtract a duration to compute a new time.  This method
   * works off absolute time, so subtracting 1days means to
   * subtract 24 hours from the ticks.  This might be a different
   * time of day if on a DST boundry.  Use {@link Date.minus | Date.minus}
   * for daily increments.
   * 
   * Example:
   * ```
   * prevHour := DateTime.now - 1hr
   * ```
   */
  minus(duration: Duration): DateTime;
  /**
   * Compare based on nanosecond ticks.
   */
  compare(obj: JsObj): number;
  /**
   * This method computes the day of month (1-31) for a given
   * weekday.  The pos parameter specifies the first, second,
   * third, or fourth occurence of the weekday.  A negative pos
   * is used to compute the last (or second to last, etc) weekday
   * in the month.
   * 
   * Examples:
   * ```
   * // compute the second monday in Apr 2007
   * weekdayInMonth(2007, Month.apr, Weekday.mon, 2)
   * 
   * // compute the last sunday in Oct 2007
   * weekdayInMonth(2007, Month.oct, Weekday.sun, -1)
   * ```
   */
  static weekdayInMonth(year: number, mon: Month, weekday: Weekday, pos: number): number;
  /**
   * Return if this time is within daylight savings time for its
   * associated time zone.
   */
  dst(): boolean;
  /**
   * Return the delta between this and the given time.
   * 
   * Example:
   * ```
   * elapsed := DateTime.now - startTime
   * ```
   */
  minusDateTime(time: DateTime): Duration;
  /**
   * Parse a string into a DateTime using the given pattern.  If
   * string is not a valid format then return null or raise
   * ParseErr based on checked flag.  See {@link toLocale | toLocale}
   * for pattern syntax.
   * 
   * The timezone is inferred from the zone pattern, or else the
   * given `tz` parameter is used for the timezone.  The `z` pattern
   * will match "hh:mm", "hhmm", or "hh".  If only a zone offset
   * is available and it doesn't match the expected `tz` parameter,
   * then use a "GMT+/-" timezone.  Note that if offset is a
   * fractional hour such as GMT-3:30, then result will have
   * ticks, but its tz will be floored hour based GMT timezone
   * such as GMT-3.
   */
  static fromLocale(str: string, pattern: string, tz?: TimeZone, checked?: boolean): DateTime | null;
  /**
   * Get the number of nanoseconds (the fraction of seconds) as a
   * number between 0 and 999,999,999.
   */
  nanoSec(): number;
  /**
   * Convert this DateTime to the specific timezone.  The
   * absolute point time as ticks remains the same, but the date
   * and time fields will be converted to represent the new time
   * zone.  However if converting to or from {@link TimeZone.rel | TimeZone.rel}
   * then the resulting DateTime has the same day and time.  Also
   * see {@link toUtc | toUtc} and {@link toRel | toRel}.
   * 
   * Example:
   * ```
   * dt := DateTime("2010-06-03T10:30:00-04:00 New_York")
   * dt.toUtc  =>  2010-06-03T14:30:00Z UTC
   * dt.toRel  =>  2010-06-03T10:30:00Z Rel
   * ```
   */
  toTimeZone(tz: TimeZone): DateTime;
  /**
   * Get the whole seconds of the time as a number between 0 and
   * 59.
   */
  sec(): number;
  /**
   * Get the minutes of the time as a number between 0 and 59.
   */
  min(): number;
  /**
   * Get the hour of the time as a number between 0 and 23.
   */
  hour(): number;
  /**
   * Parse an HTTP date according to the RFC 2616 section 3.3.1. 
   * If invalid format and checked is false return null,
   * otherwise throw ParseErr.  The following date formats are
   * supported:
   * ```
   * Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
   * Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
   * Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
   * ```
   */
  static fromHttpStr(s: string, checked?: boolean): DateTime | null;
  /**
   * Return the current time using {@link TimeZone.cur | TimeZone.cur}.
   * The tolerance parameter specifies that you are willing to
   * use a cached DateTime instance as long as (now - cached <=
   * tolerance).  If tolerance is null, then this method always
   * creates a new DateTime instance.  Using tolerance can
   * increase performance and save memory.  The tolerance default
   * is 250ms.
   * 
   * If you are using time to calculate relative time periods,
   * then use {@link Duration.now | Duration.now} instead. 
   * Duration is more efficient and won't cause you grief when
   * the system clock is modified.
   */
  static now(tolerance?: Duration | null): DateTime;
  /**
   * Get the boot time of the Fantom VM with {@link TimeZone.cur | TimeZone.cur}
   */
  static boot(): DateTime;
  /**
   * Return a new DateTime with this time's nanosecond ticks
   * truncated according to the specified accuracy.  For example `floor(1min)`
   * will truncate this time to the minute such that seconds are
   * 0.0.  This method is strictly based on absolute ticks, it
   * does not take into account wall-time rollovers.
   */
  floor(accuracy: Duration): DateTime;
  /**
   * Make for the specified date and time values:
   * - year:  1901-2099
   * - month: Month enumeration
   * - day:   1-31
   * - hour:  0-23
   * - min:   0-59
   * - sec:   0-59
   * - ns:    0-999_999_999
   * - tz:    time zone used to map date/time to ns ticks
   * 
   * Throw ArgErr if any of the parameters are out of range.
   */
  static make(year: number, month: Month, day: number, hour: number, min: number, sec?: number, ns?: number, tz?: TimeZone, ...args: unknown[]): DateTime;
  /**
   * Format this time for use in an MIME or HTTP message
   * according to RFC 2616 using the RFC 1123 format:
   * ```
   * Sun, 06 Nov 1994 08:49:37 GMT
   * ```
   */
  toHttpStr(): string;
  /**
   * Format this time according to the specified pattern.  If
   * pattern is null, then a localized default is used.  Any
   * ASCII letter in the pattern is interpreted as follows:
   * ```
   * YY     Two digit year             07
   * YYYY   Four digit year            2007
   * M      One/two digit month        6, 11
   * MM     Two digit month            06, 11
   * MMM    Three letter abbr month    Jun, Nov
   * MMMM   Full month                 June, November
   * D      One/two digit day          5, 28
   * DD     Two digit day              05, 28
   * DDD    Day with suffix            1st, 2nd, 3rd, 24th
   * WWW    Three letter abbr weekday  Tue
   * WWWW   Full weekday               Tuesday
   * Q      Quarter number             3
   * QQQ    Quarter with suffix        3rd
   * QQQQ   Quarter spelled out        3rd Quarter
   * V      One/two digit week of year 1,52
   * VV     Two digit week of year     01,52
   * VVV    Week of year with suffix   1st,52nd
   * h      One digit 24 hour (0-23)   3, 22
   * hh     Two digit 24 hour (0-23)   03, 22
   * k      One digit 12 hour (1-12)   3, 11
   * kk     Two digit 12 hour (1-12)   03, 11
   * m      One digit minutes (0-59)   4, 45
   * mm     Two digit minutes (0-59)   04, 45
   * s      One digit seconds (0-59)   4, 45
   * ss     Two digit seconds (0-59)   04, 45
   * SS     Optional seconds (only if non-zero)
   * f*     Fractional secs trailing zeros
   * F*     Fractional secs no trailing zeros
   * a      Lower case a/p for am/pm   a, p
   * aa     Lower case am/pm           am, pm
   * A      Upper case A/P for am/pm   A, P
   * AA     Upper case AM/PM           AM, PM
   * z      Time zone offset           Z, +03:00 (ISO 8601, XML Schema)
   * zzz    Time zone abbr             EST, EDT
   * zzzz   Time zone name             New_York
   * 'xyz'  Literal characters
   * ''     Single quote literal
   * ```
   * 
   * A symbol immediately preceding a "F" pattern with no
   * fraction to print is skipped.
   * 
   * Examples:
   * ```
   * YYYY-MM-DD'T'hh:mm:ss.FFFz  =>  2009-01-16T09:57:35.097-05:00
   * DD MMM YYYY                 =>  06 Jan 2009
   * DD/MMM/YY                   =>  06/Jan/09
   * MMMM D, YYYY                =>  January 16, 2009
   * hh:mm:ss.fff zzzz           =>  09:58:54.845 New_York
   * k:mma                       =>  9:58a
   * k:mmAA                      =>  9:58AM
   * ```
   */
  toLocale(pattern?: string | null, locale?: Locale): string;
  /**
   * Return a DateTime for the beginning of the current day at
   * midnight.
   */
  midnight(): DateTime;
  /**
   * Return number of nanosecond ticks since 1 Jan 2000 UTC.
   * Dates before this epoch will return a negative integer.
   */
  ticks(): number;
  /**
   * Return the current time using {@link TimeZone.utc | TimeZone.utc}.
   * See {@link now | now} for a description of the tolerance
   * parameter.
   */
  static nowUtc(tolerance?: Duration | null): DateTime;
  /**
   * Return if the specified year is a leap year.
   */
  static isLeapYear(year: number): boolean;
  /**
   * Parse an ISO 8601 timestamp.  If invalid format and checked
   * is false return null, otherwise throw ParseErr.  The
   * following formats are supported:
   * ```
   * YYYY-MM-DD'T'hh:mm:ss[.FFFFFFFFF]
   * YYYY-MM-DD'T'hh:mm:ss[.FFFFFFFFF]+HH:MM
   * YYYY-MM-DD'T'hh:mm:ss[.FFFFFFFFF]-HH:MM
   * ```
   * 
   * If a timezone offset is specified, then one of the
   * predefined "Etc/GMT+x" timezones are used for the result:
   * ```
   * DateTime("2009-01-15T12:00:00Z")       =>  2009-01-15T12:00:00Z UTC
   * DateTime("2009-01-15T12:00:00-05:00")  =>  2009-01-15T12:00:00-05:00 GMT+5
   * ```
   * 
   * Also see {@link toIso | toIso}, {@link fromStr | fromStr}, and
   * {@link fromHttpStr | fromHttpStr}.
   */
  static fromIso(s: string, checked?: boolean): DateTime | null;
  /**
   * Return if the time portion is "00:00:00".
   */
  isMidnight(): boolean;
  /**
   * Make for nanosecond ticks since 1 Jan 2000 UTC.  Throw
   * ArgErr if ticks represent a year out of the range 1901 to
   * 2099.
   */
  static makeTicks(ticks: number, tz?: TimeZone): DateTime;
  /**
   * Two times are equal if they have identical nanosecond ticks.
   */
  equals(that: JsObj | null): boolean;
  /**
   * Get the time component of this timestamp.
   */
  time(): Time;
}

/**
 * LogLevel provides a set of discrete levels used to customize
 * logging. See [docLang::Logging](https://fantom.org/doc/docLang/Logging)
 * for details.
 */
export class LogLevel extends Enum {
  static type$: Type
  static silent(): LogLevel;
  static debug(): LogLevel;
  static err(): LogLevel;
  /**
   * List of LogLevel values indexed by ordinal
   */
  static vals(): List<LogLevel>;
  static warn(): LogLevel;
  static info(): LogLevel;
  /**
   * Return the LogLevel instance for the specified name.  If not
   * a valid name and checked is false return null, otherwise
   * throw ParseErr.
   */
  static fromStr(name: string, checked?: boolean, ...args: unknown[]): LogLevel;
}

/**
 * Str represents a sequence of Unicode characters.
 */
export class Str extends Obj {
  static type$: Type
  /**
   * Default value is "".
   */
  static defVal(): string;
  /**
   * Duplicate this string the given number of times.  Any
   * integer less than or equal to zero returns an empty string.
   * 
   * Examples:
   * ```
   * "x" * 4  =>  "xxxx"
   * ```
   */
  static mult(self: string, times: number): string;
  /**
   * Get the character at the zero based index as a Unicode code
   * point. Negative indexes may be used to access from the end
   * of the string. Unlike {@link get | get}, this method does not
   * throw IndexErr when the index is out or range, instead it
   * returns `def`.
   */
  static getSafe(self: string, index: number, def?: number): number;
  /**
   * Return this string with all lowercase characters replaced to
   * uppercase.  The case conversion is for ASCII only. Also see {@link lower | lower},
   * {@link localeUpper | localeUpper}, {@link Int.upper | Int.upper},
   * {@link Int.localeUpper | Int.localeUpper}.
   * 
   * Example:
   * ```
   * "Foo Bar".upper => "FOO BAR"
   * ```
   */
  static upper(self: string): string;
  /**
   * Replace all occurrences of `from` with `to`.
   * 
   * Examples:
   * ```
   * "hello".replace("hell", "t")  =>  "to"
   * "aababa".replace("ab", "-")   =>  "a--a"
   * ```
   */
  static replace(self: string, from$: string, to: string): string;
  /**
   * Reverse index - return the first occurrence of the specified
   * substring searching backward, starting at the specified
   * offset index.  A negative offset may be used to access from
   * the end of string.  Return null if no occurrences are found.
   * 
   * Examples:
   * ```
   * "abcabc".indexr("b")     => 4
   * "abcabc".indexr("b", -3) => 1
   * "abcabc".indexr("b", 0)  => null
   * ```
   */
  static indexr(self: string, s: string, offset?: number): number | null;
  /**
   * Translate a programmer name like "fooBar" to "Foo Bar". This
   * method capitalizes the first letter, then walks the string
   * looking for ASCII capital letters and inserting a space. 
   * Any underbars are replaced with a space.  Also see {@link fromDisplayName | fromDisplayName}.
   * 
   * Examples:
   * ```
   * "foo".toDisplayName       ->  "Foo
   * "fooBar".toDisplayName    ->  "Foo Bar"
   * "fooBarBaz".toDisplayName ->  "Foo Bar Baz"
   * "foo33".toDisplayName     ->  "Foo 33"
   * "fooXML".toDisplayName    ->  "Foo XML"
   * "Foo".toDisplayName       ->  "Foo"
   * "foo_bar".toDisplayName   ->  "Foo Bar"
   * ```
   */
  static toDisplayName(self: string): string;
  /**
   * Return this string with the first character converted to
   * lowercase using the current locale. Also see {@link localeCapitalize | localeCapitalize}
   * and {@link decapitalize | decapitalize}.
   */
  static localeDecapitalize(self: string): string;
  /**
   * If size is less than width, then add spaces to the left to
   * create a right justified string.  Also see {@link padl | padl}.
   * 
   * Examples:
   * ```
   * "xyz".justr(2) => "xyz"
   * "xyz".justr(4) => " xyz"
   * ```
   */
  static justr(self: string, width: number): string;
  /**
   * Return this string as valid XML text.  The special control
   * characters amp, lt, apos and quot are always escaped.  The
   * gt char is escaped only if it is the first char or if
   * preceded by the `]` char.  Also see {@link OutStream.writeXml | OutStream.writeXml}
   * which is more efficient if streaming.
   */
  static toXml(self: string): string;
  /**
   * If size is less than width, then add the given char to the
   * left to achieve the specified width.  Also see {@link justl | justl}.
   * 
   * Examples:
   * ```
   * "xyz".padr(2, '.') => "xyz"
   * "xyz".padr(5, '-') => "xyz--"
   * ```
   */
  static padr(self: string, width: number, char?: number): string;
  /**
   * If size is less than width, then add spaces to the right to
   * create a left justified string.  Also see {@link padr | padr}.
   * 
   * Examples:
   * ```
   * "xyz".justl(2) => "xyz"
   * "xyz".justl(4) => "xyz "
   * ```
   */
  static justl(self: string, width: number): string;
  /**
   * Trim whitespace only from the end of the string. See {@link trim | trim}
   * for definition of whitespace.
   * 
   * Examples:
   * ```
   * "foo".trim    =>  "foo"
   * " foo ".trim  =>  " foo"
   * ```
   */
  static trimEnd(self: string): string;
  /**
   * Compare two strings without regard to case according to the
   * current locale.  Return -1, 0, or 1 if this string is less
   * than, equal to, or greater than the specified string.
   * 
   * Examples (assuming English locale):
   * ```
   * "a".localeCompare("b")   =>  -1
   * "hi".localeCompare("HI") =>  0
   * "b".localeCompare("A")   =>  1
   * ```
   */
  static localeCompare(self: string, s: string): number;
  /**
   * If size is less than width, then add the given char to the
   * left to achieve the specified width.  Also see {@link justr | justr}.
   * 
   * Examples:
   * ```
   * "3".padl(3, '0') => "003"
   * "123".padl(2, '0') => "123"
   * ```
   */
  static padl(self: string, width: number, char?: number): string;
  /**
   * Return if every character in this Str is whitespace: space
   * \t \n \r \f
   */
  static isSpace(self: string): boolean;
  /**
   * Return this string with all lowercase characters replaced to
   * uppercase using the current locale. Also see {@link localeLower | localeLower},
   * {@link upper | upper}, and {@link Int.localeUpper | Int.localeUpper}.
   */
  static localeUpper(self: string): string;
  /**
   * Split a string into a list of substrings using the given
   * separator character.  If there are contiguous separators,
   * then they are split into empty strings.  If trim is true,
   * then whitespace is trimmed from the beginning and end of the
   * results.
   * 
   * If separator is null, then the string is split according to
   * any sequence of whitespace characters (any character equal
   * to or less than the 0x20 space character including ` `, `\r`, `\n`,
   * and `\t`).
   * 
   * If this is the empty string or there are no splits return a
   * list of one item.
   * 
   * Examples:
   * ```
   * // split on whitespace
   * "".split                   =>  [""]
   * "x".split                  =>  ["x"]
   * "x y".split                =>  ["x", "y"]
   * " x y ".split              =>  ["x", "y"]
   * " x \n y \n z ".split      =>  ["x", "y", "z"]
   * 
   * // split on sep with trim
   * "".split('|')              =>  [""]
   * "22".split(';')            =>  ["22"]
   * "22;33".split(';')         =>  ["22","33"]
   * "22, 33".split(',')        =>  ["22","33"]
   * " 22 ; 33 ".split(';')     =>  ["22","33"]
   * 
   * // split on sep with no trim
   * "22#33".split('#', false)  =>  ["22","33"]
   * " x ; y".split(';', false) =>  [" x "," y"]
   * ```
   */
  static split(self: string, separator?: number | null, trim?: boolean): List<string>;
  /**
   * Trim whitespace from the beginning and end of the string. 
   * For the purposes of this method, whitespace is defined as
   * any character equal to or less than the 0x20 space character
   * (including ` `, `\r`, `\n`, and `\t`).
   * 
   * Examples:
   * ```
   * "foo".trim      =>  "foo"
   * "  foo".trim    =>  "foo"
   * " foo ".trim    =>  "foo"
   * "  foo\n".trim  =>  "foo"
   * "   ".trim      =>  ""
   * ```
   */
  static trim(self: string): string;
  /**
   * Return a substring based on the specified range.  Negative
   * indexes may be used to access from the end of the string. 
   * This method is accessed via the [] operator.  Throw IndexErr
   * if range illegal.
   * 
   * Examples:
   * ```
   * "abcd"[0..2]   => "abc"
   * "abcd"[3..3]   => "d"
   * "abcd"[-2..-1] => "cd"
   * "abcd"[0..<2]  => "ab"
   * "abcd"[1..-2]  => "bc"
   * "abcd"[4..-1]  => ""
   * ```
   */
  static getRange(self: string, range: Range): string;
  /**
   * Return if every character in this Str is ASCII uppercase: `A`-'Z'.
   */
  static isUpper(self: string): boolean;
  /**
   * Count the number of newline combinations: "\n", "\r", or
   * "\r\n".
   */
  static numNewlines(self: string): number;
  /**
   * Convenience for `compareIgnoreCase(s) == 0`. Only ASCII
   * character case is taken into account. See {@link localeCompare | localeCompare}
   * for localized case insensitive comparisions.
   */
  static equalsIgnoreCase(self: string, s: string): boolean;
  /**
   * Convenience for {@link Decimal.fromStr | Decimal.fromStr}
   * using this string.
   */
  static toDecimal(self: string, checked?: boolean): number | null;
  /**
   * Find the index just like {@link index | index}, but ignoring
   * case for ASCII chars only.
   */
  static indexIgnoreCase(self: string, s: string, offset?: number): number | null;
  /**
   * Trim whitespace only from the beginning of the string. See {@link trim | trim}
   * for definition of whitespace.
   * 
   * Examples:
   * ```
   * "foo".trim    =>  "foo"
   * " foo ".trim  =>  "foo "
   * ```
   */
  static trimStart(self: string): string;
  /**
   * Return this.
   */
  static toStr(self: string): string;
  /**
   * Return true if c returns true for all of the characters in
   * this string.  If this string is empty, return true.
   * 
   * Example:
   * ```
   * "Bar".all |c| { c.isUpper } => false
   * "BAR".all |c| { c.isUpper } => true
   * ```
   */
  static all(self: string, c: ((arg0: number, arg1: number) => boolean)): boolean;
  /**
   * Return if every char is an ASCII {@link Int.isAlphaNum | alpha-numeric}.
   */
  static isAlphaNum(self: string): boolean;
  /**
   * Create an input stream to read characters from this string.
   * The input stream is designed only to read character data. 
   * Attempts to perform binary reads will throw UnsupportedErr.
   */
  static in(self: string): InStream;
  /**
   * Return if every char is an ASCII {@link Int.isAlpha | letter}.
   */
  static isAlpha(self: string): boolean;
  /**
   * Return this string as its Fantom source code and
   * serialization representation surrounded by the specified
   * quote character (which defaults to `"`).  If quote is null
   * then the return is unquoted. This method will backslash
   * escape the following characters: `\n \r \f \t \\ $`.  If the
   * quote character is the double quote, single quote, or
   * backtick then it is escaped too.  Control chars less than
   * 0x20 are escaped as `\uXXXX`.  If `escapeUnicode` is true then
   * any char over 0x7F is escaped as `\uXXXX`.
   */
  static toCode(self: string, quote?: number | null, escapeUnicode?: boolean): string;
  /**
   * Return this string with all uppercase characters replaced to
   * lowercase.  The case conversion is for ASCII only. Also see {@link upper | upper},
   * {@link localeLower | localeLower}, {@link Int.lower | Int.lower},
   * {@link Int.localeLower | Int.localeLower}.
   * 
   * Example:
   * ```
   * "Apple".lower => "apple"
   * ```
   */
  static lower(self: string): string;
  /**
   * Return the first occurrence of the specified substring
   * searching forward, starting at the specified offset index. 
   * A negative offset may be used to access from the end of
   * string.  Return null if no occurrences are found.
   * 
   * Examples:
   * ```
   * "abcabc".index("b")     => 1
   * "abcabc".index("b", 1)  => 1
   * "abcabc".index("b", 3)  => 4
   * "abcabc".index("b", -3) => 4
   * "abcabc".index("x")     => null
   * ```
   */
  static index(self: string, s: string, offset?: number): number | null;
  /**
   * Split this string into individual lines where lines are
   * terminated by \n, \r\n, or \r.  The returned strings do not
   * contain the newline character.
   * 
   * Examples:
   * ```
   * "x\ny".splitLines  => ["x", "y"]
   * "".splitLines      => [""]
   * "x".splitLines     => ["x"]
   * "\r\n".splitLines  => ["", ""]
   * "x\n".splitLines   => ["x", ""]
   * ```
   */
  static splitLines(self: string): List<string>;
  /**
   * Convenience for {@link Bool.fromStr | Bool.fromStr} using
   * this string.
   */
  static toBool(self: string, checked?: boolean): boolean | null;
  /**
   * Reverse each - call the specified function for every char in
   * the string starting with index size-1 and decrementing down
   * to 0.
   * 
   * Example:
   * ```
   * "abc".eachr |Int c| { echo(c.toChar) }
   * ```
   */
  static eachr(self: string, c: ((arg0: number, arg1: number) => void)): void;
  /**
   * Concat the value of obj.toStr
   */
  static plus(self: string, obj: JsObj | null): string;
  /**
   * Call the specified function for every char in the string
   * with index 0 and incrementing up to size-1.
   * 
   * Example:
   * ```
   * "abc".each |Int c| { echo(c.toChar) }
   * ```
   */
  static each(self: string, c: ((arg0: number, arg1: number) => void)): void;
  /**
   * Return this string with the first character converted
   * uppercase.  The case conversion is for ASCII only. Also see {@link decapitalize | decapitalize}
   * and {@link localeCapitalize | localeCapitalize}.
   * 
   * Example:
   * ```
   * "foo".capitalize => "Foo"
   * ```
   */
  static capitalize(self: string): string;
  /**
   * Return this string with the first character converted to
   * uppercase using the current locale. Also see {@link localeDecapitalize | localeDecapitalize}
   * and {@link capitalize | capitalize}.
   */
  static localeCapitalize(self: string): string;
  /**
   * Return if this string contains the specified string.
   * Convenience for index(s) != null
   */
  static contains(self: string, s: string): boolean;
  /**
   * Return if every character in this Str is a US-ASCII
   * character less than 128.
   */
  static isAscii(self: string): boolean;
  /**
   * Return number of characters in this string.
   */
  static size(self: string): number;
  /**
   * Return if this Str ends with the specified Str.
   */
  static endsWith(self: string, s: string): boolean;
  /**
   * Get a Str containing the specified number of spaces.  Also
   * see {@link justl | justl} and {@link justr | justr} to justify
   * an existing string.
   * 
   * Examples:
   * ```
   * Str.spaces(1)  =>  " "
   * Str.spaces(2)  =>  "  "
   * ```
   */
  static spaces(n: number): string;
  /**
   * Return this string with all uppercase characters replaced to
   * lowercase using the current locale. Also see {@link localeUpper | localeUpper},
   * {@link lower | lower}, and {@link Int.localeLower | Int.localeLower}.
   */
  static localeLower(self: string): string;
  /**
   * The hash for a Str is platform dependent.
   */
  static hash(self: string): number;
  /**
   * Compare two strings without regard to case and return -1, 0,
   * or 1 if this string is less than, equal to, or greater than
   * the specified string.  Only ASCII character case is taken
   * into account. See {@link localeCompare | localeCompare} for
   * localized case insensitive comparisions.
   * 
   * Examples:
   * ```
   * "a".compareIgnoreCase("b")    =>  -1
   * "hi".compareIgnoreCase("HI")  =>  0
   * "b".compareIgnoreCase("a")    =>  1
   * ```
   */
  static compareIgnoreCase(self: string, s: string): number;
  /**
   * Compare based on Unicode character values.  Case is not
   * taken into account - also see {@link compareIgnoreCase | compareIgnoreCase}
   * and {@link localeCompare | localeCompare}.
   * 
   * Examples:
   * ```
   * "a".compare("b")    =>  -1
   * "hi".compare("hi")  =>  0
   * "hi".compare("HI")  =>  1
   * "b".compare("a")    =>  1
   * ```
   */
  static compare(self: string, obj: JsObj): number;
  /**
   * Return if this string contains the specified character.
   */
  static containsChar(self: string, ch: number): boolean;
  /**
   * Return this string with the first character converted
   * lowercase.  The case conversion is for ASCII only. Also see {@link capitalize | capitalize}
   * and {@link localeDecapitalize | localeDecapitalize}.
   * 
   * Example:
   * ```
   * "Foo".decapitalize => "foo"
   * ```
   */
  static decapitalize(self: string): string;
  /**
   * Get the character at the zero based index as a Unicode code
   * point. Negative indexes may be used to access from the end
   * of the string. This method is accessed via the [] operator. 
   * Throw IndexErr if the index is out of range.
   */
  static get(self: string, index: number): number;
  /**
   * Translate a display name like "Foo Bar" to a programmatic
   * name "fooBar".  This method decapitalizes the first letter,
   * then walks the string removing spaces.  Also see {@link toDisplayName | toDisplayName}.
   * 
   * Examples:
   * ```
   * "Foo".fromDisplayName         ->  "foo"
   * "Foo Bar".fromDisplayName     ->  "fooBar"
   * "Foo Bar Baz".fromDisplayName ->  "fooBarBaz"
   * "Foo 33 Bar".fromDisplayName  ->  "foo33Bar"
   * "Foo XML".fromDisplayName     ->  "fooXML"
   * "foo bar".fromDisplayName     ->  "fooBar"
   * ```
   */
  static fromDisplayName(self: string): string;
  /**
   * Trim whitespace from the beginning and end of the string.
   * Should the resultant string be empty, `null` is returned.
   * 
   * For the purposes of this method, whitespace is defined as
   * any character equal to or less than the 0x20 space character
   * (including ` `, `\r`, `\n`, and `\t`).
   * 
   * Examples:
   * ```
   * "foo".trimToNull      =>  "foo"
   * "  foo  ".trimToNull  =>  "foo"
   * "".trimToNull         =>  null
   * "   ".trimToNull      =>  null
   * ```
   */
  static trimToNull(self: string): string | null;
  /**
   * Return this.  This method is used to enable `toLocale` to be
   * used with duck typing across most built-in types.
   */
  static toLocale(self: string): string;
  /**
   * Convenience for {@link Int.fromStr | Int.fromStr} using this
   * string.
   */
  static toInt(self: string, radix?: number, checked?: boolean): number | null;
  /**
   * Internalize this Str such that two strings which are equal
   * via the `==` operator will have the same reference such that `===`
   * will be true.
   */
  static intern(self: string): string;
  /**
   * Convenience for {@link Regex.fromStr | Regex.fromStr} using
   * this string.
   */
  static toRegex(self: string): Regex;
  /**
   * Convenience for {@link Uri.fromStr | Uri.fromStr} using this
   * string.
   */
  static toUri(self: string): Uri;
  /**
   * Return if `size() == 0`.
   */
  static isEmpty(self: string): boolean;
  /**
   * Convenience for {@link Float.fromStr | Float.fromStr} using
   * this string.
   */
  static toFloat(self: string, checked?: boolean): number | null;
  /**
   * Construct a string from a list of unicode code points. Also
   * see {@link chars | chars}.
   */
  static fromChars(chars: List<number>): string;
  /**
   * Reverse the contents of this string.
   * 
   * Example:
   * ```
   * "stressed".reverse => "desserts"
   * ```
   */
  static reverse(self: string): string;
  /**
   * Return true if c returns true for any of the characters in
   * this string.  If this string is empty, return false.
   * 
   * Example:
   * ```
   * "Foo".any |c| { c.isUpper } => true
   * "foo".any |c| { c.isUpper } => false
   * ```
   */
  static any(self: string, c: ((arg0: number, arg1: number) => boolean)): boolean;
  /**
   * Get this string encoded into a buffer of bytes.
   */
  static toBuf(self: string, charset?: Charset): Buf;
  /**
   * Find the index just like {@link indexr | indexr}, but
   * ignoring case for ASCII chars only.
   */
  static indexrIgnoreCase(self: string, s: string, offset?: number): number | null;
  /**
   * Return true if a Str with exact same char sequence.
   */
  static equals(self: string, obj: JsObj | null): boolean;
  /**
   * Return if every character in this Str is ASCII lowercase: `a`-'z'.
   */
  static isLower(self: string): boolean;
  /**
   * Iterate each character in the string until the function
   * returns non-null.  If function returns non-null, then break
   * the iteration and return the resulting object.  Return null
   * if the function returns null for every item.
   */
  static eachWhile(self: string, c: ((arg0: number, arg1: number) => JsObj | null)): JsObj | null;
  /**
   * Get the characters in this string as a list of integer code
   * points. Also see {@link fromChars | fromChars}.
   */
  static chars(self: string): List<number>;
  /**
   * Return if this Str starts with the specified Str.
   */
  static startsWith(self: string, s: string): boolean;
}

/**
 * Enum for twelve months of the year.
 */
export class Month extends Enum {
  static type$: Type
  /**
   * July
   */
  static jul(): Month;
  /**
   * February
   */
  static feb(): Month;
  /**
   * June
   */
  static jun(): Month;
  /**
   * December
   */
  static dec(): Month;
  /**
   * List of Month values indexed by ordinal
   */
  static vals(): List<Month>;
  /**
   * November
   */
  static nov(): Month;
  /**
   * January
   */
  static jan(): Month;
  /**
   * March
   */
  static mar(): Month;
  /**
   * September
   */
  static sep(): Month;
  /**
   * October
   */
  static oct(): Month;
  /**
   * April
   */
  static apr(): Month;
  /**
   * May
   */
  static may(): Month;
  /**
   * August
   */
  static aug(): Month;
  /**
   * Return the month after this month.
   */
  increment(): Month;
  /**
   * Return the number of days in this month for the specified
   * year.
   */
  numDays(year: number): number;
  /**
   * Get the abbreviated name for the current locale. Configured
   * by the `sys::<name>Abbr` localized property.
   */
  localeAbbr(): string;
  /**
   * Return the month as a localized string according to the
   * specified pattern.  The pattern rules are a subset of the {@link DateTime.toLocale | DateTime.toLocale}:
   * ```
   * M      One/two digit month        6, 11
   * MM     Two digit month            06, 11
   * MMM    Three letter abbr month    Jun, Nov
   * MMMM   Full month name            June, November
   * ```
   * 
   * If pattern is null it defaults to "MMM".  Also see {@link localeAbbr | localeAbbr}
   * and {@link localeFull | localeFull}.
   */
  toLocale(pattern?: string | null, locale?: Locale): string;
  /**
   * Return the Month instance for the specified name.  If not a
   * valid name and checked is false return null, otherwise throw
   * ParseErr.
   */
  static fromStr(name: string, checked?: boolean, ...args: unknown[]): Month;
  /**
   * Return the month before this month.
   */
  decrement(): Month;
  /**
   * Get the full name for the current locale. Configured by the `sys::<name>Full`
   * localized property.
   */
  localeFull(): string;
}

/**
 * Decimal is used to represent a decimal floating point more
 * precisely than a Float.  Decimal is the preferred numeric
 * type for financial applications.
 */
export class Decimal extends Num {
  static type$: Type
  /**
   * Default value is 0.
   */
  static defVal(): number;
  /**
   * Subtract b from this.  Shortcut is a-b.
   */
  static minus(self: number, b: number): number;
  /**
   * Compare based on decimal value, scale is not considered for
   * equality (unlike {@link equals | equals}).
   */
  static compare(self: number, obj: JsObj): number;
  /**
   * Multiply this with b.  Shortcut is a*b.
   */
  static mult(self: number, b: number): number;
  /**
   * Return remainder of this divided by b.  Shortcut is a%b.
   */
  static mod(self: number, b: number): number;
  /**
   * Return remainder of this divided by b.  Shortcut is a%b.
   */
  static modInt(self: number, b: number): number;
  /**
   * Divide this by b.  Shortcut is a/b.
   */
  static divFloat(self: number, b: number): number;
  /**
   * Increment by one.  Shortcut is ++a or a++.
   */
  static increment(self: number): number;
  /**
   * Multiply this with b.  Shortcut is a*b.
   */
  static multInt(self: number, b: number): number;
  /**
   * Divide this by b.  Shortcut is a/b.
   */
  static div(self: number, b: number): number;
  /**
   * Add this with b.  Shortcut is a+b.
   */
  static plusFloat(self: number, b: number): number;
  /**
   * Return the smaller of this and the specified Decimal values.
   */
  static min(self: number, that: number): number;
  /**
   * Subtract b from this.  Shortcut is a-b.
   */
  static minusFloat(self: number, b: number): number;
  /**
   * Add this with b.  Shortcut is a+b.
   */
  static plusInt(self: number, b: number): number;
  /**
   * Return remainder of this divided by b.  Shortcut is a%b.
   */
  static modFloat(self: number, b: number): number;
  /**
   * Get string representation.
   */
  static toStr(self: number): string;
  /**
   * Multiply this with b.  Shortcut is a*b.
   */
  static multFloat(self: number, b: number): number;
  /**
   * Format this decimal number for the current locale. If
   * pattern is null, then the locale's default pattern is used.
   * See {@link Float.toLocale | Float.toLocale} for pattern
   * language and examples.
   */
  static toLocale(self: number, pattern?: string | null, locale?: Locale): string;
  /**
   * Return the larger of this and the specified Decimal values.
   */
  static max(self: number, that: number): number;
  /**
   * Get this Decimal as a Fantom code literal.
   */
  static toCode(self: number): string;
  /**
   * Add this with b.  Shortcut is a+b.
   */
  static plus(self: number, b: number): number;
  /**
   * Return the absolute value of this decimal.  If this value is
   * positive then return this, otherwise return the negation.
   */
  static abs(self: number): number;
  /**
   * Parse a Str into a Decimal.  If invalid format and checked
   * is false return null, otherwise throw ParseErr.
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): Decimal;
  /**
   * Negative of this.  Shortcut is -a.
   */
  static negate(self: number): number;
  /**
   * Decrement by one.  Shortcut is --a or a--.
   */
  static decrement(self: number): number;
  /**
   * Subtract b from this.  Shortcut is a-b.
   */
  static minusInt(self: number, b: number): number;
  /**
   * Return true if same decimal with same scale.
   */
  static equals(self: number, obj: JsObj | null): boolean;
  /**
   * Divide this by b.  Shortcut is a/b.
   */
  static divInt(self: number, b: number): number;
  /**
   * Return platform specific hashcode.
   */
  static hash(self: number): number;
}

/**
 * Bool represents a boolean condition of true or false.
 */
export class Bool extends Obj {
  static type$: Type
  /**
   * Default value is false.
   */
  static defVal(): boolean;
  /**
   * Return "true" or "false".
   */
  static toStr(self: boolean): string;
  /**
   * Return localized strings for "true" and "false" using
   * current locale.
   */
  static toLocale(self: boolean): string;
  /**
   * Bitwise "or" of this and b.  Note this method does not short
   * circuit like logical `||` operator.
   */
  static or(self: boolean, b: boolean): boolean;
  /**
   * Get this Bool as a Fantom code literal - returns {@link toStr | toStr}.
   */
  static toCode(self: boolean): string;
  /**
   * Return the logical not: if true return false; if false
   * return true.
   */
  static not(self: boolean): boolean;
  /**
   * Parse a Str into a Bool.  Valid formats are "true" or
   * "false". If invalid format and checked is false return null,
   * otherwise throw ParseErr.
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): Bool;
  /**
   * Bitwise "and" of this and b.  Note this method does not
   * short circuit like logical `&&` operator.
   */
  static and(self: boolean, b: boolean): boolean;
  /**
   * Return if same boolean value.
   */
  static equals(self: boolean, obj: JsObj | null): boolean;
  /**
   * Bitwise "exclusive-or" of this and b.
   */
  static xor(self: boolean, b: boolean): boolean;
  /**
   * Return 1231 for true and 1237 for false.
   */
  static hash(self: boolean): number;
}

/**
 * ConstErr indicates an attempt to set a const field after the
 * object has been constructed.
 */
export class ConstErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): ConstErr;
}

/**
 * Pod represents a module of Types.  Pods serve as a type
 * namespace as well as unit of deployment and versioning.
 */
export class Pod extends Obj {
  static type$: Type
  /**
   * Return the log for this pod's name.  This is a convenience
   * for `Log.get(name)`.
   */
  log(): Log;
  /**
   * Order a list of pods by their dependencies. This method does
   * not flatten dependencies - see {@link flattenDepends | flattenDepends}.
   */
  static orderByDepends(pods: List<Pod>): List<Pod>;
  /**
   * Find a type by name.  If the type doesn't exist and checked
   * is false then return null, otherwise throw UnknownTypeErr.
   */
  type(name: string, checked?: boolean): Type | null;
  /**
   * Convenience for {@link Env.locale | Env.locale} using {@link Locale.cur | Locale.cur}.
   */
  locale(name: string, def?: string | null): string | null;
  /**
   * Look up a resource file in this pod.  The URI must start
   * with the Pod's {@link uri | uri} or be path absolute.  If the
   * file cannot be found then return null or throw UnresolvedErr
   * based on checked flag.
   * 
   * Examples:
   * ```
   * Pod.find("icons").file(`/x16/cut.png`)
   * Pod.find("icons").file(`fan://icons/x16/cut.png`)
   * `fan://icons/x16/cut.png`.get
   * ```
   */
  file(uri: Uri, checked?: boolean): File | null;
  /**
   * Load a pod into memory from the specified input stream.  The
   * stream must contain a valid pod zip file with all the
   * definitions. The pod is completely loaded into memory and
   * the input stream is closed.  The pod cannot have resources. 
   * The pod name as defined by `/pod.def` must be uniquely named
   * or Err is thrown.
   */
  static load(in$: InStream): Pod;
  /**
   * Find a pod by name.  If the pod doesn't exist and checked is
   * false then return null, otherwise throw UnknownPodErr.
   */
  static find(name: string, checked?: boolean): Pod | null;
  /**
   * Get the pod of the given instance which is convenience for `Type.of(obj).pod`.
   * See {@link Type.pod | Type.pod}.
   */
  static of(obj: JsObj): Pod | null;
  /**
   * Expand a set of pods to include all their recursive
   * dependencies. This method does not order them; see {@link orderByDepends | orderByDepends}.
   */
  static flattenDepends(pods: List<Pod>): List<Pod>;
  /**
   * Always return name().
   */
  toStr(): string;
  /**
   * List of all the defined types.
   */
  types(): List<Type>;
  /**
   * Get the declared list of dependencies for this pod.
   */
  depends(): List<Depend>;
  /**
   * Get a list of all the pods installed.  Note that currently
   * this method will load all of the pods into memory, so it is
   * an expensive operation.
   */
  static list(): List<Pod>;
  /**
   * Version number for this pod.
   */
  version(): Version;
  /**
   * Uri for this pod which is always "fan://{name}".
   */
  uri(): Uri;
  /**
   * Convenience for {@link Env.props | Env.props}.
   */
  props(uri: Uri, maxAge: Duration): Map<string, string>;
  /**
   * Get the meta name/value pairs for this pod. See [docLang](https://fantom.org/doc/docLang/Pods#meta).
   */
  meta(): Map<string, string>;
  /**
   * Simple name of the pod such as "sys".
   */
  name(): string;
  /**
   * List all the resource files contained by this pod. 
   * Resources are any files included in the pod's zip file
   * excluding fcode files.  The URI of these files is rooted by {@link uri | uri}.
   * Use {@link file | file} or {@link Uri.get | Uri.get} to lookup
   * a resource file.
   */
  files(): List<File>;
  /**
   * Return the fandoc chapter for this pod or null if not
   * available. To get the summary string for the pod use:
   * ```
   * pod.meta["pod.summary"]
   * ```
   */
  doc(): string | null;
  /**
   * Convenience for {@link Env.config | Env.config}.
   */
  config(name: string, def?: string | null): string | null;
}

/**
 * Log provides a simple, but standardized mechanism for
 * logging.
 * 
 * See [docLang::Logging](https://fantom.org/doc/docLang/Logging)
 * for details and [examples](examples::sys-logging).
 */
export class Log extends Obj {
  static type$: Type
  /**
   * The log level field defines which log entries are reported
   * versus ignored.  Anything which equals or is more severe
   * than the log level is logged.  Anything less severe is
   * ignored. If the level is set to silent, then logging is
   * disabled.
   */
  level(): LogLevel;
  level(it: LogLevel): void;
  /**
   * Publish a log entry.  The convenience methods {@link err | err},
   * {@link warn | warn} {@link info | info}, and {@link debug | debug}
   * all route to this method for centralized handling.  The
   * standard implementation is to call each of the installed {@link handlers | handlers}
   * if the specified level is enabled.
   */
  log(rec: LogRec): void;
  /**
   * Return if debug level is enabled.
   */
  isDebug(): boolean;
  /**
   * Find a registered log by name.  If the log doesn't exist and
   * checked is false then return null, otherwise throw Err.
   */
  static find(name: string, checked?: boolean): Log | null;
  /**
   * Find an existing registered log by name or if not found then
   * create a new registered Log instance with the given name.
   * Name must be valid according to {@link Uri.isName | Uri.isName}
   * otherwise NameErr is thrown.
   */
  static get(name: string): Log;
  /**
   * Return if info level is enabled.
   */
  isInfo(): boolean;
  /**
   * Create a new log by name.  The log is added to the VM log
   * registry only if `register` is true.  If register is true and
   * a log has already been created for the specified name then
   * throw ArgErr.  Name must be valid according to {@link Uri.isName | Uri.isName}
   * otherwise NameErr is thrown.
   */
  static make(name: string, register: boolean, ...args: unknown[]): Log;
  /**
   * Generate a {@link LogLevel.info | LogLevel.info} log entry.
   */
  info(msg: string, err?: Err | null): void;
  /**
   * Return name.
   */
  toStr(): string;
  /**
   * Install a handler to receive callbacks on logging events. If
   * the handler func is not immutable, then throw
   * NotImmutableErr.
   */
  static addHandler(handler: ((arg0: LogRec) => void)): void;
  /**
   * Generate a {@link LogLevel.debug | LogLevel.debug} log entry.
   */
  debug(msg: string, err?: Err | null): void;
  /**
   * Generate a {@link LogLevel.err | LogLevel.err} log entry.
   */
  err(msg: string, err?: Err | null): void;
  /**
   * Return if error level is enabled.
   */
  isErr(): boolean;
  /**
   * Uninstall a log handler.
   */
  static removeHandler(handler: ((arg0: LogRec) => void)): void;
  /**
   * Return a list of all the active logs which have been
   * registered since system startup.
   */
  static list(): List<Log>;
  /**
   * Generate a {@link LogLevel.warn | LogLevel.warn} log entry.
   */
  warn(msg: string, err?: Err | null): void;
  /**
   * List all the handler functions installed to process log
   * events.
   */
  static handlers(): List<((arg0: LogRec) => void)>;
  /**
   * Return if this log is enabled for the specified level.
   */
  isEnabled(level: LogLevel): boolean;
  /**
   * Return name of the log.
   */
  name(): string;
  /**
   * Return if warn level is enabled.
   */
  isWarn(): boolean;
}

/**
 * InterruptedErr indicates that a thread is interrupted from
 * its normal execution.
 */
export class InterruptedErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): InterruptedErr;
}

/**
 * Method models a function with a formal parameter list and
 * return value (or Void if no return).
 */
export class Method extends Slot {
  static type$: Type
  /**
   * Convenience for `func.callOn`
   */
  callOn(target: JsObj | null, args: List<JsObj | null> | null): JsObj | null;
  /**
   * Evaluate the parameter default using reflection.  If this
   * method is static or a constructor, then instance should be
   * null.  Raise an exception if the parameter default cannot be
   * evaluated independently (such as using an expression with
   * previous parameters).
   */
  paramDef(param: Param, instance?: JsObj | null): JsObj | null;
  /**
   * Get the parameters of the method. Convenience for `func.params`.
   */
  params(): List<Param>;
  /**
   * Convenience for `func.callList`
   */
  callList(args: List<JsObj | null> | null): JsObj | null;
  /**
   * Convenience for `func.call`
   */
  call(a?: JsObj | null, b?: JsObj | null, c?: JsObj | null, d?: JsObj | null, e?: JsObj | null, f?: JsObj | null, g?: JsObj | null, h?: JsObj | null): JsObj | null;
  /**
   * Get the function body of this method.
   */
  func(): Function;
  /**
   * Type returned by the method or sys::Void if no return value.
   * Convenience for `func.returns`.
   */
  returns(): Type;
}

/**
 * ArgErr indicates an invalid argument was passed.
 */
export class ArgErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): ArgErr;
}

/**
 * LogRec all the information of a single logging event. See [docLang::Logging](https://fantom.org/doc/docLang/Logging)
 * for details.
 */
export class LogRec extends Obj {
  static type$: Type
  /**
   * Message text event
   */
  msg(): string;
  /**
   * Exception if applicable
   */
  err(): Err | null;
  /**
   * Severity level of event
   */
  level(): LogLevel;
  /**
   * Name of {@link Log | Log} which generated the event
   */
  logName(): string;
  /**
   * Timestamp of log event
   */
  time(): DateTime;
  /**
   * Return standard log format.
   */
  toStr(): string;
  /**
   * Print to the specified output stream.
   */
  print(out?: OutStream): void;
  /**
   * Constructor with all the fields
   */
  static make(time: DateTime, level: LogLevel, logName: string, message: string, err?: Err | null, ...args: unknown[]): LogRec;
}

/**
 * Float is used to represent a 64-bit floating point number.
 */
export class Float extends Num {
  static type$: Type
  /**
   * Float value for Not-A-Number.
   */
  static nan(): number;
  /**
   * Float value for positive infinity.
   */
  static posInf(): number;
  /**
   * Default value is 0f.
   */
  static defVal(): number;
  /**
   * Float value for negative infinity.
   */
  static negInf(): number;
  /**
   * Float value for e which is the base of natural logarithms.
   */
  static e(): number;
  /**
   * Float value for pi which is the ratio of the circumference
   * of a circle to its diameter.
   */
  static pi(): number;
  /**
   * Multiply this with b.  Shortcut is a*b.
   */
  static mult(self: number, b: number): number;
  /**
   * Return remainder of this divided by b.  Shortcut is a%b.
   */
  static mod(self: number, b: number): number;
  /**
   * Return the cosine of this angle in radians.
   */
  static cos(self: number): number;
  /**
   * Return if this is Float.nan.  Also see {@link compare | compare}.
   */
  static isNaN(self: number): boolean;
  /**
   * Return the arc tangent.
   */
  static atan(self: number): number;
  /**
   * Divide this by b.  Shortcut is a/b.
   */
  static div(self: number, b: number): number;
  /**
   * Return square root of this value.
   */
  static sqrt(self: number): number;
  /**
   * Return e raised to this power.
   */
  static exp(self: number): number;
  /**
   * Clamp this float between the min and max.  If its less than
   * min then return min, if its greater than max return max,
   * otherwise return this float itself.
   */
  static clamp(self: number, min: number, max: number): number;
  /**
   * Converts rectangular coordinates (x, y) to polar (r, theta).
   */
  static atan2(y: number, x: number): number;
  /**
   * Get string representation according to the lexical
   * representation defined by Section 3.2.5 of XML Schema Part
   * 2.  Representations for infinity and not-a-number are
   * "-INF", "INF", "NaN".
   */
  static toStr(self: number): string;
  /**
   * Return tangent of this angle in radians.
   */
  static tan(self: number): number;
  /**
   * Return hyperbolic sine.
   */
  static sinh(self: number): number;
  /**
   * Get this Float as a Fantom code literal.
   */
  static toCode(self: number): string;
  /**
   * Return 64-bit representation according IEEE 754
   * floating-point double format bit layout.  This method is
   * paired with {@link makeBits | Float.makeBits}.
   */
  static bits(self: number): number;
  /**
   * Convert this angle in radians to an angle in degrees.
   */
  static toDegrees(self: number): number;
  /**
   * Returns the smallest whole number greater than or equal to
   * this number.
   */
  static ceil(self: number): number;
  /**
   * Return the arc cosine.
   */
  static acos(self: number): number;
  /**
   * Add this with b.  Shortcut is a+b.
   */
  static plus(self: number, b: number): number;
  /**
   * Divide this by b.  Shortcut is a/b.
   */
  static divDecimal(self: number, b: number): number;
  /**
   * Parse a Str into a Float.  Representations for infinity and
   * not-a-number are "-INF", "INF", "NaN".  This string format
   * matches the lexical representation of Section 3.2.5 of XML
   * Schema Part 2. If invalid format and checked is false return
   * null, otherwise throw ParseErr.
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): Float;
  /**
   * Make a Float for the specified 32-bit representation
   * according IEEE 754 floating-point single format bit layout. 
   * This method is paired with {@link bits32 | Float.bits32}.
   */
  static makeBits32(bits: number): number;
  /**
   * If this value is negative zero then return normalized zero,
   * otherwise return this value.
   */
  static normNegZero(self: number): number;
  /**
   * Divide this by b.  Shortcut is a/b.
   */
  static divInt(self: number, b: number): number;
  /**
   * Return bits().
   */
  static hash(self: number): number;
  /**
   * Return if this is negative zero value.
   */
  static isNegZero(self: number): boolean;
  /**
   * Subtract b from this.  Shortcut is a-b.
   */
  static minus(self: number, b: number): number;
  /**
   * Compare based on floating point value.
   * 
   * NaN works as follows:
   * - for the `<=>` operator NaN is always less than other values
   *   and equal to itself (so sort works as expected)
   * - for all other comparison operators anything compared against
   *   NaN is false (normal Java semanatics)
   * 
   * Examples:
   * ```
   * Float.nan <=> Float.nan  =>  0
   * 2f <=> Float.nan         =>  1
   * Float.nan <=> 2f         =>  -1
   * 2f < Float.nan           =>  false
   * Float.nan < 2f           =>  false
   * Float.nan <= Float.nan   =>  false
   * ```
   */
  static compare(self: number, obj: JsObj): number;
  /**
   * Return natural logarithm of this number.
   */
  static log(self: number): number;
  /**
   * Return remainder of this divided by b.  Shortcut is a%b.
   */
  static modInt(self: number, b: number): number;
  /**
   * Return base 10 logarithm of this number.
   */
  static log10(self: number): number;
  /**
   * Increment by one.  Shortcut is ++a or a++.
   */
  static increment(self: number): number;
  /**
   * Multiply this with b.  Shortcut is a*b.
   */
  static multInt(self: number, b: number): number;
  /**
   * Add this with b.  Shortcut is a+b.
   */
  static plusDecimal(self: number, b: number): number;
  /**
   * Generate a random float between 0.0 inclusive and 1.0
   * exclusive. Also see {@link Int.random | Int.random}, {@link Range.random | Range.random},
   * {@link List.random | List.random}, and {@link util.Random | util::Random}.
   */
  static random(): number;
  /**
   * Return hyperbolic tangent.
   */
  static tanh(self: number): number;
  /**
   * Subtract b from this.  Shortcut is a-b.
   */
  static minusDecimal(self: number, b: number): number;
  /**
   * Return the smaller of this and the specified Float values.
   */
  static min(self: number, that: number): number;
  /**
   * Return this value raised to the specified power.
   */
  static pow(self: number, pow: number): number;
  /**
   * Return sine of this angle in radians.
   */
  static sin(self: number): number;
  /**
   * Returns the largest whole number less than or equal to this
   * number.
   */
  static floor(self: number): number;
  /**
   * Return 32-bit representation according IEEE 754
   * floating-point single format bit layout.  This method is
   * paired with {@link makeBits32 | Float.makeBits32}.
   */
  static bits32(self: number): number;
  /**
   * Add this with b.  Shortcut is a+b.
   */
  static plusInt(self: number, b: number): number;
  /**
   * Format this floating point number for the current locale. If
   * pattern is null, then the locale's default pattern is used.
   * Also see {@link Num.localeDecimal | Num.localeDecimal}, {@link Num.localeGrouping | Num.localeGrouping},
   * etc.
   * 
   * The pattern format:
   * ```
   * #   optional digit
   * 0   required digit
   * .   decimal point
   * ,   grouping separator (only last one before decimal matters)
   * ```
   * 
   * Examples:
   * ```
   * 12345.786f.toLocale("#,###.0")  =>  12,345.8
   * 7.1234f.toLocale("#.000")       =>  7.123
   * 0.1234f.toLocale("#.000")       =>  .123
   * 0.1234f.toLocale("0.00")        =>  0.12
   * 70.12f.toLocale("0.0000")       =>  70.1200
   * ```
   */
  static toLocale(self: number, pattern?: string | null, locale?: Locale): string;
  /**
   * Return remainder of this divided by b.  Shortcut is a%b.
   */
  static modDecimal(self: number, b: number): number;
  /**
   * Return the larger of this and the specified Float values.
   */
  static max(self: number, that: number): number;
  /**
   * Convert this angle in degrees to an angle in radians.
   */
  static toRadians(self: number): number;
  /**
   * Return the hyperbolic cosine.
   */
  static cosh(self: number): number;
  /**
   * Return the absolute value of this float.  If this value is
   * positive then return this, otherwise return the negation.
   */
  static abs(self: number): number;
  /**
   * Returns the nearest whole number to this number.
   */
  static round(self: number): number;
  /**
   * Make a Float for the specified 64-bit representation
   * according IEEE 754 floating-point double format bit layout. 
   * This method is paired with {@link bits | Float.bits}.
   */
  static makeBits(bits: number): number;
  /**
   * Negative of this.  Shortcut is -a.
   */
  static negate(self: number): number;
  /**
   * Decrement by one.  Shortcut is --a or a--.
   */
  static decrement(self: number): number;
  /**
   * Subtract b from this.  Shortcut is a-b.
   */
  static minusInt(self: number, b: number): number;
  /**
   * Return true if same float value.  Like Java, NaN != NaN.
   * Also see {@link compare | compare}.
   */
  static equals(self: number, obj: JsObj | null): boolean;
  /**
   * Return the arc sine.
   */
  static asin(self: number): number;
  /**
   * Multiply this with b.  Shortcut is a*b.
   */
  static multDecimal(self: number, b: number): number;
  /**
   * Return if this Float is approximately equal to the given
   * Float by the specified tolerance.  If tolerance is null,
   * then it is computed using the magnitude of the two Floats. 
   * It is useful for comparing Floats since often they lose a
   * bit of precision during manipulation. This method is
   * equivalent to:
   * ```
   * if (tolerance == null) tolerance = min(abs(this/1e6), abs(r/1e6))
   * (this - r).abs < tolerance
   * ```
   */
  static approx(self: number, r: number, tolerance?: number | null): boolean;
}

/**
 * TimeZone represents a region's offset from UTC and its
 * daylight savings time rules.  TimeZones are historical - UTC
 * offset and DST rules may change depending on the year.  The
 * Fantom implementation of historical time zones is optimized
 * to handle only year boundaries (so some historical changes
 * which don't occur on year boundaries may not be 100%
 * accurate).
 * 
 * The Fantom time zone database and naming model is based on
 * the [ZoneInfo database](https://www.iana.org/time-zones) used
 * by UNIX and Java.  All time zones have both a simple {@link name | name}
 * and a {@link fullName | fullName}. The `fullName` is the full
 * identifier used in the zoneinfo database such as
 * "America/New_York".  The simple name is the city name only
 * such as "New_York".
 * 
 * Use {@link cur | cur} to get current default timezone for VM.
 * 
 * Also see [docLang](https://fantom.org/doc/docLang/DateTime).
 */
export class TimeZone extends Obj {
  static type$: Type
  /**
   * Return {@link name | name}.
   */
  toStr(): string;
  /**
   * Get the current default TimeZone of the VM.  The default
   * timezone is configured by the Java or .NET runtime or it can
   * be manually configured in "etc/sys/config.props" with the
   * key "timezone" and any value accepted by {@link fromStr | fromStr}.
   * Once Fantom is booted, the default timezone cannot be
   * changed.
   */
  static cur(): TimeZone;
  /**
   * Get the duration of time added to UTC to compute standard
   * time in this time zone.  The offset is independent of
   * daylight savings time - during daylight savings the actual
   * offset is this value plus {@link dstOffset | dstOffset}.
   */
  offset(year: number): Duration;
  /**
   * UTC time zone instance is "Etc/Utc".
   */
  static utc(): TimeZone;
  /**
   * Get the full name of this time zone as defined by the
   * zoneinfo database.  These names are formatted as
   * "continent/location" where location is a major city within
   * the time zone region. Examples of full names are
   * "America/New_York" and "Europe/London".
   */
  fullName(): string;
  /**
   * Get the duration of time which will be added to local
   * standard time to get wall time during daylight savings time
   * (often 1hr). If daylight savings time is not observed then
   * return null.
   */
  dstOffset(year: number): Duration | null;
  /**
   * Get the abbreviated name during standard time.
   */
  stdAbbr(year: number): string;
  /**
   * Find a time zone by name from the built-in database:
   * 1. First check for simple name like "New_York" or the zoneinfo
   *   full name "America/New_York"
   * 2. Attempt to match against timezone aliases, if a match is
   *   found return the canonical TimeZone instance
   * 3. If no matches are found and checked is false then return
   *   null, otherwise throw ParseErr.
   * 
   * Also see:
   * - [TimeZone database](https://fantom.org/doc/docLang/DateTime#timeZone)
   * - [TimeZone aliases](https://fantom.org/doc/docLang/DateTime#timeZoneAliases)
   */
  static fromStr(name: string, checked?: boolean, ...args: unknown[]): TimeZone;
  /**
   * List all zoneinfo (Olson database) full names of the time
   * zones available in the local time zone database. This list
   * is the full names only such as "America/New_York" and
   * "Europe/London".
   */
  static listFullNames(): List<string>;
  /**
   * Relative time zone instance is "Etc/Rel".  The relative
   * timezone has a zero offset like UTC, but is used to
   * normalize by time of day versus absolute time.  See {@link DateTime.toRel | DateTime.toRel}
   * and [docLang](https://fantom.org/doc/docLang/DateTime#relTimeZone).
   */
  static rel(): TimeZone;
  /**
   * Get the identifier of this time zone in the time zone
   * database.  Name is the city name portion of the zoneinfo {@link fullName | fullName}
   * identifier such as "New_York" or "London".
   */
  name(): string;
  /**
   * Get the abbreviated name during daylight savings time or
   * null if daylight savings time not observed.
   */
  dstAbbr(year: number): string | null;
  /**
   * List the names of all the time zones available in the local
   * time zone database.  This database is stored in
   * "{home}/lib/timezone.ftz" as a binary file.  This list
   * contains only the simple names such as "New_York" and
   * "London".
   */
  static listNames(): List<string>;
  /**
   * Default value is UTC.
   */
  static defVal(): TimeZone;
}

/**
 * Slot represents a member field or method on a Type.
 */
export class Slot extends Obj {
  static type$: Type
  /**
   * Parent type which defines this slot.
   */
  parent(): Type;
  /**
   * Return if this type has the specified facet defined.
   */
  hasFacet(type: Type): boolean;
  /**
   * Return if slot is static (class based, rather than
   * instance).
   */
  isStatic(): boolean;
  /**
   * Return a string representation of the Fantom code signature.
   */
  signature(): string;
  /**
   * Return true if this is an instance of Field.
   */
  isField(): boolean;
  /**
   * Return if this slot was generated by the compiler.
   */
  isSynthetic(): boolean;
  /**
   * Return if slot has private protection scope.
   */
  isPrivate(): boolean;
  /**
   * Return if slot is native.
   */
  isNative(): boolean;
  /**
   * Get the list of facets defined on this slot or return an
   * empty list if no facets are defined. If looking up a facet
   * by type, then use the {@link facet | facet} method which will
   * provide better performance. See [Facets Doc](https://fantom.org/doc/docLang/Facets)
   * for details.
   */
  facets(): List<Facet>;
  /**
   * Return if slot has protected protection scope.
   */
  isProtected(): boolean;
  /**
   * Convenience for `(Method)find(qname, checked)`
   */
  static findMethod(qname: string, checked?: boolean): Method | null;
  /**
   * Find a Slot by its qualified name "pod::Type.slot".  If the
   * slot doesn't exist and checked is false then return null,
   * otherwise throw UnknownSlotErr.
   */
  static find(qname: string, checked?: boolean): Slot | null;
  /**
   * Return if slot is constant and thread safe.  A constant
   * field is explicitly marked with the const modifier and
   * guaranteed to always reference the same immutable object for
   * the life of the VM.  A const method is guaranteed to not
   * capture any state from its thread, and is safe to execute on
   * other threads. The compiler marks methods as const based on
   * the following analysis:
   * - static methods are always automatically const
   * - instance methods are never const
   * - closures which don't capture any variables from their scope
   *   are automatically const
   * - partial apply methods which only capture const variables
   *   from their scope are automatically const
   */
  isConst(): boolean;
  /**
   * Qualified name such as "sys:Str.size".
   */
  qname(): string;
  /**
   * Return if slot is an override (of parent's virtual method).
   */
  isOverride(): boolean;
  /**
   * Return true if this is an instance of Method.
   */
  isMethod(): boolean;
  /**
   * Return if slot has public protection scope.
   */
  isPublic(): boolean;
  /**
   * Always return qname().
   */
  toStr(): string;
  /**
   * Convenience for `findMethod(qname, checked).func`
   */
  static findFunc(qname: string, checked?: boolean): Function | null;
  /**
   * Return if slot is abstract (no implementation provided).
   */
  isAbstract(): boolean;
  /**
   * Return if slot has internal protection scope.
   */
  isInternal(): boolean;
  /**
   * Simple name of the slot such as "size".
   */
  name(): string;
  /**
   * Return the raw fandoc for this slot or null if not
   * available.
   */
  doc(): string | null;
  /**
   * Return if slot is virtual (may be overridden in subclasses).
   */
  isVirtual(): boolean;
  /**
   * Convenience for `(Field)find(qname, checked)`
   */
  static findField(qname: string, checked?: boolean): Field | null;
  /**
   * Get a facet by its type.  If not found on this slot then
   * return null or throw UnknownFacetErr based on check flag.
   * See [Facets Doc](https://fantom.org/doc/docLang/Facets) for
   * details.
   */
  facet(type: Type, checked?: boolean): Facet | null;
  /**
   * Return if slot is constructor method.
   */
  isCtor(): boolean;
}

/**
 * TestErr is thrown by {@link Test | Test} when a test method
 * fails a verify.
 */
export class TestErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string | null, cause?: Err | null, ...args: unknown[]): TestErr;
}

/**
 * Map is a hash map of key/value pairs.
 * 
 * See [examples](examples::sys-maps).
 */
export class Map<K = unknown, V = unknown> extends Obj {
  static type$: Type
  /**
   * The default value to use for {@link get | get} when a key
   * isn't mapped. This field defaults to null.  The value of `def`
   * must be immutable or NotImmutableErr is thrown.  Getting
   * this field is readonly safe. Throw ReadonlyErr if set when
   * readonly.
   */
  def(): unknown | null;
  def(it: unknown | null): void;
  /**
   * This field configures case sensitivity for maps with Str
   * keys.  When set to true, Str keys are compared without
   * regard to case for the following methods:  get, containsKey,
   * set, add, setAll, addAll, and remove methods. Only ASCII
   * character case is taken into account.  The original case is
   * preserved (keys aren't made all lower or upper case).  This
   * field defaults to false.
   * 
   * Getting this field is readonly safe.  If you attempt to set
   * this method on a map which is not empty or not typed to use
   * Str keys, then throw UnsupportedOperation.  Throw
   * ReadonlyErr if set when readonly.  This mode cannot be used
   * concurrently with {@link ordered | ordered}.
   */
  caseInsensitive(): boolean;
  caseInsensitive(it: boolean): void;
  /**
   * When set to true, the map maintains the order in which
   * key/value pairs are added to the map.  The implementation is
   * based on using a linked list in addition to the normal
   * hashmap.  This field defaults to false.
   * 
   * Getting this field is readonly safe.  If you attempt to set
   * this method on a map which is not empty, then throw
   * UnsupportedOperation.  Throw ReadonlyErr if set when
   * readonly.  This mode cannot be used concurrently with {@link caseInsensitive | caseInsensitive}.
   */
  ordered(): boolean;
  ordered(it: boolean): void;
  /**
   * Call {@link add | add} if val is non-null otherwise do
   * nothing.  Return this.
   */
  addNotNull(key: unknown, val: unknown | null): Map<K,V>;
  /**
   * Return a new map containing the key/value pairs for which c
   * returns true.  If c returns false for every item, then
   * return an empty map.  The inverse of this method is {@link exclude | exclude}.
   * If this map is {@link ordered | ordered} or {@link caseInsensitive | caseInsensitive},
   * then the resulting map is too.  This method is readonly
   * safe.
   */
  findAll(c: unknown): Map<K,V>;
  /**
   * Return the first value in the map for which c returns true.
   * If c returns false for every pair, then return null.  This
   * method is readonly safe.
   */
  find(c: unknown): unknown | null;
  /**
   * Return a new map containing the key/value pairs for which c
   * returns false.  If c returns true for every item, then
   * return an empty map.  The inverse of this method is {@link findAll | findAll}.
   * If this map is {@link ordered | ordered} or {@link caseInsensitive | caseInsensitive},
   * then the resulting map is too.  This method is readonly
   * safe.
   * 
   * Example:
   * ```
   * map := ["off":0, "slow":50, "fast":100]
   * map.exclude |Int v->Bool| { return v == 0 } => ["slow":50, "fast":100]
   * ```
   */
  exclude(c: unknown): Map<K,V>;
  /**
   * Return a string by concatenating each key/value pair using
   * the specified separator string.  If c is non-null then it is
   * used to format each pair into a string, otherwise "$k: $v"
   * is used.  This method is readonly safe.
   * 
   * Example:
   * ```
   * m := ["a" : 1, "b" : 2]
   * m.join(" and ") |Int v, Str k->Str| { return "$v from $k" }
   *   => 1 from a and 2 from b
   * ```
   */
  join(separator: string, c?: unknown | null): string;
  /**
   * Return a string representation of the Map.  This method is
   * readonly safe.
   */
  toStr(): string;
  /**
   * Add the specified key/value pair to the map.  If the key is
   * already mapped, then throw ArgErr.  Return this.  If key
   * does not return true for Obj.isImmutable, then throw
   * NotImmutableErr. If key is null throw NullErr.  Throw
   * ReadonlyErr if readonly.
   */
  add(key: unknown, val: unknown): Map<K,V>;
  /**
   * Return true if c returns true for all of the key/value pairs
   * in the map.  If the list is empty, return true.  This method
   * is readonly safe.
   */
  all(c: unknown): boolean;
  /**
   * Reduce is used to iterate through every key/value pair in
   * the map to reduce the map into a single value called the
   * reduction. The initial value of the reduction is passed in
   * as the init parameter, then passed back to the closure along
   * with each key/value pair.  This method is readonly safe.
   * 
   * Example:
   * ```
   * m := ["2":2, "3":3, "4":4]
   * m.reduce(100) |Obj r, Int v->Obj| { return (Int)r + v } => 109
   * ```
   */
  reduce(init: JsObj | null, c: unknown): JsObj | null;
  /**
   * Call {@link set | set} if val is non-null otherwise do
   * nothing.  Return this.
   */
  setNotNull(key: unknown, val: unknown | null): Map<K,V>;
  /**
   * Return if the specified key is mapped. This method is
   * readonly safe.
   */
  containsKey(key: unknown): boolean;
  /**
   * Get this map as a Fantom expression suitable for code
   * generation. The individual keys and values must all respond
   * to the `toCode` method.
   */
  toCode(): string;
  /**
   * Call the specified function for every key/value pair in the
   * map. This method is readonly safe.
   */
  each(c: unknown): void;
  /**
   * Convenience for {@link map | map} and {@link findNotNull | findNotNull}.
   * Each key/value pair is mapped by the given function and if
   * null is returned it is excluded from the result.  The
   * resulting type is based on the return type of c but
   * non-nullable.  This method is readonly safe.
   */
  mapNotNull(c: unknown): Map<JsObj, JsObj | null>;
  /**
   * Return a new map containing all the key/value pairs where
   * value is not null.  If this map is {@link ordered | ordered}
   * or {@link caseInsensitive | caseInsensitive}, then the
   * resulting map is too.  This method is readonly safe.
   */
  findNotNull(): Map<K,V>;
  /**
   * Get the number of key/value pairs in the list.  This method
   * is readonly safe.
   */
  size(): number;
  /**
   * Get a readonly Map instance with the same contents as this
   * Map (although its values may be mutable themselves).  If
   * this Map is already readonly, then return this.  Only
   * methods documented as "readonly safe" may be used safely
   * with a readonly Map, all others will throw ReadonlyErr. 
   * This method is readonly safe.
   */
  ro(): Readonly<Map<K,V>>;
  /**
   * Return platform dependent hashcode based on hash of the keys
   * and values.
   */
  hash(): number;
  /**
   * Get a list of all the mapped values.  This method is
   * readonly safe.
   */
  vals(): unknown;
  /**
   * Get a read-write, mutable Map instance with the same
   * contents as this Map.  If this Map is already read-write,
   * then return this. This method is readonly safe.
   */
  rw(): Map<K,V>;
  /**
   * Get a list of all the mapped keys.  This method is readonly
   * safe.
   */
  keys(): unknown;
  /**
   * Remove the key/value pair identified by the specified key
   * from the map and return the value.   If the key was not
   * mapped then return null.  Throw ReadonlyErr if readonly.
   */
  remove(key: unknown): unknown | null;
  /**
   * Deprecated - use addNotNull
   */
  addIfNotNull(key: unknown, val: unknown | null): Map<K,V>;
  /**
   * Return if this Map is readonly.  A readonly Map is
   * guaranteed to be immutable (although its values may be
   * mutable themselves). Any attempt to modify a readonly Map
   * will result in ReadonlyErr. Use {@link rw | rw} to get a
   * read-write Map from a readonly Map.  Methods documented as
   * "readonly safe" may be used safely with a readonly Map. This
   * method is readonly safe.
   */
  isRO(): boolean;
  /**
   * Get the value for the specified key.  If key is not mapped,
   * then return the value of the def parameter.  If def is
   * omitted it defaults to the {@link def | def} field.  This
   * method is readonly safe. Shortcut is `a[key]`.
   */
  get(key: unknown, def?: unknown | null): unknown | null;
  /**
   * Add the specified list to this map where the values are the
   * list items and the keys are derived by calling the specified
   * function on each item. If the function is null, then the
   * items themselves are used as the keys. If any key is already
   * mapped then this method will fail (any previous keys will
   * remain mapped, potentially leaving this map in an
   * inconsistent state). Return this.  Throw ReadonlyErr if
   * readonly.  Also see {@link setList | setList}.
   * 
   * Examples:
   * ```
   * m := [0:"0"]
   * m.addList(["1","2"]) |Str s->Int| { return s.toInt }
   * m  =>  [0:"0", 1:"1", 2:"2"]
   * ```
   */
  addList(list: unknown, c?: unknown | null): Map<K,V>;
  /**
   * Constructor for type (must be Map type).
   */
  static make(type: Type, ...args: unknown[]): Map;
  /**
   * Append the specified map to this map by setting every
   * key/value in m in this map.  Keys in m not yet mapped are
   * added and keys already mapped are overwritten.  Return this.
   * Throw ReadonlyErr if readonly. Also see {@link addAll | addAll}.
   * This method is semanatically equivalent to:
   * ```
   * m.each |v, k| { this.set(k, v) }
   * ```
   */
  setAll(m: Map<K,V>): Map<K,V>;
  /**
   * Create a new map with the same keys, but apply the specified
   * closure to generate new values.  The new map is typed based
   * on the return type of c.  If this map is {@link ordered | ordered}
   * or {@link caseInsensitive | caseInsensitive}, then the
   * resulting map is too.  This method is readonly safe.
   * 
   * Example:
   * ```
   * m := [2:2, 3:3, 4:4]
   * x := m.map |Int v->Int| { return v*2 }
   * x => [2:4, 3:6, 4:8]
   * ```
   */
  map(c: unknown): Map<JsObj, JsObj | null>;
  /**
   * Return if this Map is read-write.  A read-write Map is
   * mutable and may be modified.  Use {@link ro | ro} to get a
   * readonly Map from a read-write Map.  This method is readonly
   * safe.
   */
  isRW(): boolean;
  /**
   * Set the value for the specified key.  If the key is already
   * mapped, this overwrites the old value.  If key is not yet
   * mapped this adds the key/value pair to the map.  Return
   * this.  If key does not return true for Obj.isImmutable, then
   * throw NotImmutableErr. If key is null throw NullErr.  Throw
   * ReadonlyErr if readonly.
   */
  set(key: unknown, val: unknown): Map<K,V>;
  /**
   * Get the value for the specified key, or if it doesn't exist
   * then automatically add it.  The value function is called to
   * get the value to add, it is only called if the key is not
   * mapped. Throw ReadonlyErr if readonly only if add is
   * required.
   */
  getOrAdd(key: unknown, valFunc: unknown): unknown;
  /**
   * Return if size() == 0.  This method is readonly safe.
   */
  isEmpty(): boolean;
  /**
   * Remove all key/value pairs from the map.  Return this. Throw
   * ReadonlyErr if readonly.
   */
  clear(): Map<K,V>;
  /**
   * Add the specified list to this map where the values are the
   * list items and the keys are derived by calling the specified
   * function on each item. If the function is null, then the
   * items themselves are used as the keys. If any key is already
   * mapped then it is overwritten.  Return this.  Throw
   * ReadonlyErr if readonly.  Also see {@link addList | addList}.
   * 
   * Examples:
   * ```
   * m := [0:"0", 2:"old"]
   * m.setList(["1","2"]) |Str s->Int| { return s.toInt }
   * m  =>  [0:"0", 1:"1", 2:"2"]
   * ```
   */
  setList(list: unknown, c?: unknown | null): Map<K,V>;
  /**
   * Return true if c returns true for any of the key/value pairs
   * in the map.  If the map is empty, return false.  This method
   * is readonly safe.
   */
  any(c: unknown): boolean;
  /**
   * Append the specified map to this map by adding every
   * key/value in m in this map.  If any key in m is already
   * mapped then this method will fail (any previous keys will
   * remain mapped potentially leaving this map in an
   * inconsistent state).  Return this.  Throw ReadonlyErr if
   * readonly.  Also see {@link setAll | setAll}. This method is
   * semanatically equivalent to:
   * ```
   * m.each |v, k| { this.add(k, v) }
   * ```
   */
  addAll(m: Map<K,V>): Map<K,V>;
  /**
   * Two Maps are equal if they have the same type and same
   * number of equal key/value pairs.
   * 
   * Examples:
   * ```
   * a := Int:Str[1:"one", 2:"two"]
   * b := Int:Str[2:"two", 1:"one"]
   * c := Int:Str?[2:"two", 1:"one"]
   * a == b  =>  true
   * a == c  =>  false
   * ```
   */
  equals(that: JsObj | null): boolean;
  /**
   * Get the value for the specified key or if key is not mapped
   * then raise UnknownKeyErr.  This method is readonly safe.
   */
  getOrThrow(key: unknown): unknown;
  /**
   * Get the value for the specified key.  If the key is not
   * mapped then return null or raise UnknownKeyErr based on
   * checked flag.  This method is readonly safe.
   */
  getChecked(key: unknown, checked?: boolean): unknown | null;
  /**
   * Iterate every key/value pair in the map until the function
   * returns non-null.  If function returns non-null, then break
   * the iteration and return the resulting object.  Return null
   * if the function returns null for every key/value pair. This
   * method is readonly safe.
   */
  eachWhile(c: unknown): JsObj | null;
  /**
   * Create a shallow duplicate copy of this map.  The keys and
   * values themselves are not duplicated.  The resulting map is
   * always read/write.  This method is readonly safe.
   */
  dup(): Map<K,V>;
}

/**
 * UnsupportedErr indicates a feature which isn't supported.
 */
export class UnsupportedErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): UnsupportedErr;
}

/**
 * Byte ordering.
 */
export class Endian extends Enum {
  static type$: Type
  /**
   * Most significant byte first (network byte order)
   */
  static big(): Endian;
  /**
   * List of Endian values indexed by ordinal
   */
  static vals(): List<Endian>;
  /**
   * Least significant byte first
   */
  static little(): Endian;
  /**
   * Return the Endian instance for the specified name.  If not a
   * valid name and checked is false return null, otherwise throw
   * ParseErr.
   */
  static fromStr(name: string, checked?: boolean, ...args: unknown[]): Endian;
}

/**
 * Depend models a dependency as a pod name and a version
 * constraint.  Convention for Fantom pods is a four part
 * version format of `major.minor.build.patch`.
 * 
 * The string format for Depend:
 * ```
 * <depend>        := <name> space* <constraints>
 * <constraints>   := <constraint> [space* "," space* <constraint>]*
 * <constraint>    := <versionSimple> | <versionPlus> | <versionRange>
 * <versionSimple> := <version>
 * <versionPlus>   := <version> space* "+"
 * <versionRange>  := <version> space* "-" space* <version>
 * <version>       := <digits> ["." <digits>]*
 * <digits>        := <digit> [<digits>]*
 * <digit>         := "0" - "9"
 * ```
 * 
 * Note a simple version constraint such as "foo 1.2" really
 * means "1.2.*" - it  will match all build numbers and patch
 * numbers within "1.2".  Likewise "foo 1.2.64" will match all
 * patch numbers within the "1.2.64" build.  The "+" plus sign
 * is used to specify a given version and anything greater. 
 * The "-" dash is used to specify an inclusive range.  When
 * using a range, the end version is matched using the same
 * rules as a simple version - for example "4", "4.2", and
 * "4.0.99" are all matches for "foo 1.2-4".  You may specify a
 * list of potential constraints separated by commas - a match
 * for the entire dependency is made if any one constraint is
 * matched.
 * 
 * Examples:
 * ```
 * "foo 1.2"      Any version of foo 1.2 with any build or patch number
 * "foo 1.2.64"   Any version of foo 1.2.64 with any patch number
 * "foo 0+"       Any version of foo - version wildcard
 * "foo 1.2+"     Any version of foo 1.2 or greater
 * "foo 1.2-1.4"  Any version between 1.2 and 1.4 inclusive
 * "foo 1.2,1.4"  Any version of 1.2 or 1.4
 * ```
 */
export class Depend extends Obj {
  static type$: Type
  /**
   * Get the normalized string format of this dependency. 
   * Normalized dependency strings do not contain any optional
   * spaces.  See class header for specification of the format.
   */
  toStr(): string;
  /**
   * Return if the constraint at the specified index is a
   * versionPlus:
   * - versionSimple: returns false
   * - versionPlus:   returns true
   * - versionRange:  returns false
   */
  isPlus(index?: number): boolean;
  /**
   * Return if the specified version is a match against this
   * dependency's constraints.  See class header for matching
   * rules.
   */
  match(version: Version): boolean;
  /**
   * Get the version constraint at specified index:
   * - versionSimple: returns the version
   * - versionPlus:   returns the version
   * - versionRange:  returns the start version
   */
  version(index?: number): Version;
  /**
   * Return if the constraint at the specified index is a
   * versionRange:
   * - versionSimple: returns false
   * - versionPlus:   returns false
   * - versionRange:  returns true
   */
  isRange(index?: number): boolean;
  /**
   * Parse the string accordingly into a dependency.  See class
   * header for specification of the format.  If invalid format
   * and checked is false return null, otherwise throw ParseErr.
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): Depend;
  /**
   * Get the number of version constraints.  There is always at
   * least one constraint.
   */
  size(): number;
  /**
   * Two Depends are equal if they have same normalized string
   * representation.
   */
  equals(that: JsObj | null): boolean;
  /**
   * Get the pod name of the dependency.
   */
  name(): string;
  /**
   * Return if the constraint at the specified index is neither a
   * plus nor a range:
   * - versionSimple: returns true
   * - versionPlus:   returns false
   * - versionRange:  returns false
   */
  isSimple(index?: number): boolean;
  /**
   * Return the ending version if versionRange:
   * - versionSimple: returns null
   * - versionPlus:   returns null
   * - versionRange:  returns end version
   */
  endVersion(index?: number): Version;
  /**
   * Return a hash code based on the normalized string
   * representation.
   */
  hash(): number;
}

/**
 * Err is the base class of all exceptions.
 */
export class Err extends Obj {
  static type$: Type
  /**
   * Return the qualified type name and optional message.
   */
  toStr(): string;
  /**
   * Get the string message passed to the contructor or empty
   * string if a message is not available.
   */
  msg(): string;
  /**
   * Get the underyling cause exception or null.
   */
  cause(): Err | null;
  /**
   * Dump the stack trace of this exception to the specified
   * output stream (or `Env.cur.err` by default).  Return this.
   * 
   * The options may be used to specify the format of the output:
   * - "indent": Int for initial number of indentation spaces
   * - "maxDepth": Int specifies how many methods in each
   * ```
   * exception of chain to include.  If unspecified the
   * default is configured from the "errTraceMaxDepth" prop
   * in etc/sys/config.props.
   * ```
   */
  trace(out?: OutStream, options?: Map<string, JsObj> | null): this;
  /**
   * Dump the stack trace of this exception to a Str.
   */
  traceToStr(): string;
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): Err;
}

/**
 * FieldNotSetErr indicates a non-nullable field was not set by
 * the constructor it-block.
 */
export class FieldNotSetErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): FieldNotSetErr;
}

/**
 * Uri is used to immutably represent a Universal Resource
 * Identifier according to [RFC 3986](http://tools.ietf.org/html/rfc3986).
 * The generic format for a URI is:
 * ```
 * <uri>        := [<scheme> ":"] <body>
 * <body>       := ["//" <auth>] ["/" <path>] ["?" <query>] ["#" <frag>]
 * <auth>       := [<userInfo> "@"] <host> [":" <port>]
 * <path>       := <name> ("/" <name>)*
 * <name>       := <basename> ["." <ext>]
 * <query>      := <queryPair> (<querySep> <queryPair>)*
 * <querySep>   := "&" | ";"
 * <queryPair>  := <queryKey> ["=" <queryVal>]
 * <gen-delims> := ":" / "/" / "?" / "#" / "[" / "]" / "@"
 * ```
 * 
 * Uris are expressed in the following forms:
 * - Standard Form: any char allowed, general delimiters are "\"
 *   escaped
 * - Encoded Form: `%HH` percent encoded
 * 
 * In standard form the full range of Unicode characters is
 * allowed in all sections except the general delimiters which
 * separate sections.  For example `?` is barred in any section
 * before the query, but is permissible in the query string
 * itself or the fragment identifier.  The scheme must be
 * strictly defined in terms of ASCII alphanumeric, ".", "+",
 * or "-". Any general delimiter used outside of its normal
 * role, must be escaped using the "\" backslash character. 
 * The backslash itself is escaped as "\\".  For example a
 * filename with the "#" character is represented as "file
 * \#2".  Only the path, query, and fragment sections can use
 * escaped general delimiters; the scheme and authority
 * sections cannot use escaped general delimiters.
 * 
 * Encoded form as defined by RFC 3986 uses a stricter set of
 * rules for the characters allowed in each section of the URI
 * (scheme, userInfo, host, path, query, and fragment).  Any
 * character outside of the allowed set is UTF-8 encoded into
 * octets and `%HH` percent encoded. The encoded form should be
 * used when working with external applications such as HTTP,
 * HTML, or XML.
 * 
 * The Uri API is designed to work with the standard form of
 * the Uri. Access methods like {@link host | host}, {@link pathStr | pathStr},
 * or {@link queryStr | queryStr} all use standard form.  To
 * summarize different ways of working with Uri:
 * - {@link fromStr | Uri.fromStr}:  parses a string from its
 *   standard form
 * - {@link toStr | Uri.toStr}:    returns the standard form
 * - {@link decode | Uri.decode}:   parses a string from percent
 *   encoded form
 * - {@link encode | Uri.encode}:   translate into percent encoded
 *   form
 * 
 * Uri can be used to model either absolute URIs or relative
 * references. The {@link plus | plus} and {@link relTo | relTo}
 * methods can be used to resolve and relativize relative
 * references against a base URI.
 */
export class Uri extends Obj {
  static type$: Type
  /**
   * Default value is ````.
   */
  static defVal(): Uri;
  /**
   * Fragment token section flag
   */
  static sectionFrag(): number;
  /**
   * Query token section flag
   */
  static sectionQuery(): number;
  /**
   * Path token section flag
   */
  static sectionPath(): number;
  /**
   * Return the percent encoded string for this Uri according to
   * RFC 3986.  Each section of the Uri is UTF-8 encoded into
   * octets and then percent encoded according to its valid
   * character set. Spaces in the query section are encoded as `+`.
   */
  encode(): string;
  /**
   * Return a new Uri with a single path name appended to this
   * Uri.  If asDir is true, then add a trailing slash to the Uri
   * to make it a directory Uri.  This method is potentially much
   * more efficient than using {@link plus | plus} when appending
   * a single name.
   * 
   * Examples:
   * ```
   * `dir/`.plusName("foo")        =>  `dir/foo`
   * `dir/`.plusName("foo", true)  =>  `dir/foo/`
   * `/dir/file`.plusName("foo")   =>  `/dir/foo`
   * `/dir/#frag`.plusName("foo")  =>  `/dir/foo`
   * ```
   */
  plusName(name: string, asDir?: boolean): Uri;
  /**
   * User info is string information embedded in the authority
   * using the "@" character.  Its use is discouraged for
   * security reasons.
   * 
   * Examples:
   * ```
   * `http://brian:pass@host/`.userInfo  =>  "brian:pass"
   * `http://www.cool.com/`.userInfo     =>  null
   * ```
   */
  userInfo(): string | null;
  /**
   * Return the parent directory of this Uri or null if a parent
   * path cannot be computed from this Uri.  If the path is not
   * empty, then this method is equivalent to `getRange(0..-2)`.
   * 
   * Examples:
   * ```
   * `http://foo/a/b/c?q#f`.parent  =>  `http://foo/a/b/`
   * `/a/b/c/`.parent  =>  `/a/b/`)
   * `a/b/c`.parent    =>  `a/b/`
   * `/a`.parent       =>   `/`
   * `/`.parent        =>   null
   * `a.txt`.parent    =>   null
   * ```
   */
  parent(): Uri | null;
  /**
   * Relativize this uri against the specified base.
   * 
   * Examples:
   * ```
   * `http://foo/a/b/c`.relTo(`http://foo/a/b/c`) => ``
   * `http://foo/a/b/c`.relTo(`http://foo/a/b`)   => `c`
   * `/a/b/c`.relTo(`/a`)                         => `b/c`
   * `a/b/c`.relTo(`/a`)                          => `b/c`
   * `/a/b/c?q`.relTo(`/`)                        => `a/b/c?q`
   * `/a/x`.relTo(`/a/b/c`)                       => `../x`
   * ```
   */
  relTo(base: Uri): Uri;
  /**
   * Encode a map of query parameters into URL percent encoding
   * according to the "application/x-www-form-urlencoded" MIME
   * type. See {@link decodeQuery | decodeQuery}.
   */
  static encodeQuery(q: Map<string, string>): string;
  /**
   * The authority represents a network endpoint in the format:
   * ```
   * [<userInfo> "@"] host [":" <port>]
   * ```
   * 
   * Examples:
   * ```
   * `http://user@host:99/`.auth  =>  "user@host:99"
   * `http://host/`.auth          =>  "host"
   * `/dir/file.txt`.auth         =>  null
   * ```
   */
  auth(): string | null;
  /**
   * Return the MimeType mapped by the {@link ext | ext} or null
   * if no mapping.  If this uri is to a directory, then
   * "x-directory/normal" is returned.
   * 
   * Examples:
   * ```
   * `file.txt`  =>  text/plain
   * `somefile`  =>  null
   * ```
   */
  mimeType(): MimeType | null;
  /**
   * Parse an ASCII percent encoded string into a Uri according
   * to RFC 3986.  All `%HH` escape sequences are translated into
   * octets, and then the octet sequence is UTF-8 decoded into a
   * Str.  The `+` character in the query section is unescaped into
   * a space.  If checked is true then throw ParseErr if the
   * string is a malformed URI or if not encoded correctly,
   * otherwise return null. Refer to {@link fromStr | fromStr} for
   * normalization rules.
   */
  static decode(s: string, checked?: boolean): Uri | null;
  /**
   * If the specified string is not a valid name according to the
   * {@link isName | isName} method, then throw {@link NameErr | NameErr}.
   */
  static checkName(name: string): void;
  /**
   * Escape a token so that any delimiter for the given section
   * is backslash escaped for use in normalized URI form. Section
   * must be {@link sectionPath | sectionPath}, {@link sectionQuery | sectionQuery},
   * or {@link sectionFrag | sectionFrag}.
   * 
   * Examples:
   * ```
   * Uri.escapeToken("a/b#c", Uri.sectionPath)   =>  "a\/b\#c"
   * Uri.escapeToken("a=b/c", Uri.sectionQuery)  =>  "a\=b/c"
   * ```
   */
  static escapeToken(s: string, section: number): string;
  /**
   * Return the path parsed into a list of simple names or an
   * empty list if the pathStr is "" or "/".  Any general
   * delimiters in the path such "?" or "#" are backslash
   * escaped.
   * 
   * Examples:
   * ```
   * `mailto:me@there.com`  =>  ["me@there.com"]
   * `http://host`.path     =>  Str[,]
   * `http://foo/`.path     =>  Str[,]
   * `/`.path               =>  Str[,]
   * `/a`.path              =>  ["a"]
   * `/a/b`.path            =>  ["a", "b"]
   * `../a/b`.path          =>  ["..", "a", "b"]
   * ```
   */
  path(): List<string>;
  /**
   * Return if an absolute Uri which means it has a non-null
   * scheme.
   */
  isAbs(): boolean;
  /**
   * Return a new Uri based on a slice of this Uri's path.  If
   * the range starts at zero, then the authority is included
   * otherwise it is stripped and the result is not path
   * absolute.  If the range includes the last name in the path,
   * then the query and fragment are included otherwise they are
   * stripped and the result includes a trailing slash.  The
   * range can include negative indices to access from the end of
   * the path.  Also see {@link pathOnly | pathOnly} to create a
   * slice without the authority, query, or fragment.
   * 
   * Examples:
   * ```
   * `http://host/a/b/c?q`[0..-1]  =>  `http://host/a/b/c?q`
   * `http://host/a/b/c?q`[0..-2]  =>  `http://host/a/b/`
   * `http://host/a/b/c?q`[0..-3]  =>  `http://host/a/`
   * `http://host/a/b/c?q`[0..-4]  =>  `http://host/`
   * `http://host/a/b/c?q`[1..-1]  =>  `b/c?q`
   * `http://host/a/b/c?q`[2..-1]  =>  `c?q`
   * `http://host/a/b/c?q`[3..-1]  =>  `?q`
   * `/a/b/c/`[0..1]               =>  `/a/b/`
   * `/a/b/c/`[0..0]               =>  `/a/`
   * `/a/b/c/`[1..2]               =>  `b/c/`
   * `/a/b/c/`[1..<2]              =>  `b/`
   * `/a`[0..-2]                   =>  `/`
   * ```
   */
  getRange(r: Range): Uri;
  /**
   * Return the host address of the URI or null if not available.
   * The host is in the format of a DNS name, IPv4 address, or
   * IPv6 address surrounded by square brackets.  Return null if
   * the uri is not absolute.
   * 
   * Examples:
   * ```
   * `ftp://there:78/file`.host            =>  "there"
   * `http://www.cool.com/`.host           =>  "www.cool.com"
   * `http://user@10.162.255.4/index`.host =>  "10.162.255.4"
   * `http://[::192.9.5.5]/`.host          =>  "[::192.9.5.5]"
   * `//foo/bar`.host                      =>  "foo"
   * `/bar`.host                           =>  null
   * ```
   */
  host(): string | null;
  /**
   * Return the path component of the Uri.  Any general
   * delimiters in the path such "?" or "#" are backslash
   * escaped.
   * 
   * Examples:
   * ```
   * `mailto:me@there.com`  =>  "me@there.com"
   * `http://host`          =>  ""
   * `http://foo/`.pathStr  =>  "/"
   * `/a`.pathStr           =>  "/a"
   * `/a/b`.pathStr         =>  "/a/b"
   * `../a/b`.pathStr       =>  "../a/b"
   * ```
   */
  pathStr(): string;
  /**
   * Return normalized string representation.
   */
  toStr(): string;
  /**
   * Unescape all backslash escape sequences.
   * 
   * Examples:
   * ```
   * Uri.unescapeToken(Str<|a\#b|>)  =>  "a#b"
   * ```
   */
  static unescapeToken(s: string): string;
  /**
   * Return file name extension (everything after the last dot)
   * or null if name is null or name has no dot.
   * 
   * Examples:
   * ```
   * `/`.ext            =>  null
   * `/a/file.txt`.ext  =>  "txt"
   * `/Foo.Bar`.ext     =>  "Bar"
   * `/a/file`.ext      =>  null
   * `/a/file.`.ext     =>  ""
   * `..`.ext           =>  null
   * ```
   */
  ext(): string | null;
  /**
   * Get this Uri as a Fantom code literal.  This method will
   * escape the "$" interpolation character.
   */
  toCode(): string;
  /**
   * Decode a map of query parameters which are URL encoded
   * according to the "application/x-www-form-urlencoded" MIME
   * type.  This method will unescape `%` percent encoding and `+`
   * into space.  The parameters are parsed into map using the
   * same semantics as {@link query | Uri.query}.  Throw ArgErr if
   * the string is malformed.  See {@link encodeQuery | encodeQuery}.
   */
  static decodeQuery(s: string): Map<string, string>;
  /**
   * Return the query parsed as a map of key/value pairs.  If no
   * query string was specified return an empty map (this method
   * will never return null).  The query is parsed such that
   * pairs are separated by the "&" or ";" characters.  If a pair
   * contains the "=", then it is split into a key and value,
   * otherwise the value defaults to "true".  If delimiters such
   * as "&", "=", or ";" are in the keys or values, then they are
   * *not* escaped.  If duplicate keys are detected, then the
   * values are concatenated together with a comma.
   * 
   * Examples:
   * ```
   * `http://host/path?query`.query  =>  ["query":"true"]
   * `http://host/path`.query        =>  [:]
   * `?a=b;c=d`.query                =>  ["a":"b", "c":"d"]
   * `?a=b&c=d`.query                =>  ["a":"b", "c":"d"]
   * `?a=b;;c=d;`.query              =>  ["a":"b", "c":"d"]
   * `?a=b;;c`.query                 =>  ["a":"b", "c":"true"]
   * `?x=1&x=2&x=3`.query            =>  ["x":"1,2,3"]
   * ```
   */
  query(): Map<string, string>;
  /**
   * Add a trailing slash to the path string of this Uri to make
   * it a directory Uri.
   * 
   * Examples
   * ```
   * `http://h/dir`.plusSlash  => `http://h/dir/`
   * `/a`.plusSlash            =>  `/a/`
   * `/a/`.plusSlash           =>  `/a/`
   * `/a/b`.plusSlash          =>  `/a/b/`
   * `/a?q`.plusSlash          =>  `/a/?q`
   * ```
   */
  plusSlash(): Uri;
  /**
   * Unescape "%xx" percent encoded string to its normalized form
   * for the given section.  Any delimiters for the section are
   * backslash escaped.  Section must be {@link sectionPath | sectionPath},
   * {@link sectionQuery | sectionQuery}, or {@link sectionFrag | sectionFrag}.
   * Also see {@link encodeToken | encodeToken}.
   * 
   * Examples:
   * ```
   * Uri.decodeToken("a%2Fb%23c", Uri.sectionPath)  =>  "a\/b\#c"
   * Uri.decodeToken("a%3Db/c", Uri.sectionQuery)   =>  "a\=b/c"
   * ```
   */
  static decodeToken(s: string, section: number): string;
  /**
   * Return a new Uri with the specified Uri appended to this
   * Uri.
   * 
   * Examples:
   * ```
   * `http://foo/path` + `http://bar/`  =>  `http://bar/`
   * `http://foo/path?q#f` + `newpath`  =>  `http://foo/newpath`
   * `http://foo/path/?q#f` + `newpath` =>  `http://foo/path/newpath`
   * `a/b/c`  + `d`                     =>  `a/b/d`
   * `a/b/c/` + `d`                     =>  `a/b/c/d`
   * `a/b/c`  + `../../d`               =>  `d`
   * `a/b/c/` + `../../d`               =>  `a/d`
   * `a/b/c`  + `../../../d`            =>  `../d`
   * `a/b/c/` + `../../../d`            =>  `d`
   * ```
   */
  plus(toAppend: Uri): Uri;
  /**
   * Return file name without the extension (everything up to the
   * last dot) or "" if name is "".
   * 
   * Examples:
   * ```
   * `/`.basename            =>  ""
   * `/a/file.txt`.basename  =>  "file"
   * `/a/file`.basename      =>  "file"
   * `/a/file.`.basename     =>  "file"
   * `..`.basename           =>  ".."
   * ```
   */
  basename(): string;
  /**
   * Parse the specified string into a Uri.  If invalid format
   * and checked is false return null,  otherwise throw ParseErr.
   * Parses a standard form Unicode string into its generic
   * parts. It does not unescape `%` or `+` and handles normal
   * Unicode characters in the string.  If general delimiters
   * such as the "?" or "#" characters are used outside their
   * normal role, then they must be backslash escaped.
   * 
   * All Uris are automatically normalized as follows:
   * - Replacing "." and ".." segments in the middle of a path
   * - Scheme always normalizes to lowercase
   * - If http then port 80 normalizes to null
   * - If http then a null path normalizes to /
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): Uri;
  /**
   * Return the IP port of the host for the network end point. 
   * It is optionally embedded in the authority using the ":"
   * character.  If unspecified then return null.
   * 
   * Examples:
   * ```
   * `http://foo:81/`.port        =>  81
   * `http://www.cool.com/`.port  =>  null
   * ```
   */
  port(): number | null;
  /**
   * Return simple file name which is path.last or "" if the path
   * is empty.
   * 
   * Examples:
   * ```
   * `/`.name            =>  ""
   * `/a/file.txt`.name  =>  "file.txt"
   * `/a/file`.name      =>  "file"
   * `somedir/`.name     =>  "somedir"
   * ```
   */
  name(): string;
  /**
   * If scheme is non-null, then this is convenience for {@link get | get}
   * cast to a File.  If scheme is null then is a convenience for
   * File.make(this) which maps to a file on the local file
   * system.
   */
  toFile(): File;
  /**
   * Return a slice of this Uri's path using the same semantics
   * as {@link getRange | getRange}.  However this method ensures
   * that the result has a leading slash in the path such that {@link isPathAbs | isPathAbs}
   * returns true.
   * 
   * Examples:
   * ```
   * `/a/b/c/`.getRangeToPathAbs(0..1)  =>  `/a/b/`
   * `/a/b/c/`.getRangeToPathAbs(1..2)  =>  `/b/c/`
   * `/a/b/c/`.getRangeToPathAbs(1..<2) =>  `/b/`
   * ```
   */
  getRangeToPathAbs(r: Range): Uri;
  /**
   * Return a hash code based on the normalized string
   * representation.
   */
  hash(): number;
  /**
   * Return the query component of the Uri which is everything
   * after the "?" but before the "#" fragment.  Return null if
   * no query string specified.  Any delimiters used in keys or
   * values such as "&", "=", or ";" are backslash escaped.
   * 
   * Examples:
   * ```
   * `http://host/path?query#frag`.queryStr =>  "query"
   * `http://host/path?query`.queryStr      =>  "query"
   * `http://host/path`.queryStr            =>  null
   * `../foo?a=b&c=d`.queryStr              =>  "a=b&c=d"
   * `?a=b;c;`.queryStr                     =>  "a=b;c;"
   * ```
   */
  queryStr(): string | null;
  /**
   * Relativize this uri against its authority.  This method
   * strips the authority if present and keeps the path, query,
   * and fragment segments.
   * 
   * Examples:
   * ```
   * `http://host/a/b/c?q#frag`.relToAuth  => `/a/b/c?q#frag`
   * `http://host/a/b/c`.relToAuth         => `/a/b/c`
   * `http://user@host/index`.relToAuth    => `/index`
   * `mailto:bob@bob.net`.relToAuth        => `bob@bob.net`
   * `/a/b/c/`.relToAuth                   => `/a/b/c/`
   * `logo.png`.relToAuth                  => `logo.png`
   * ```
   */
  relToAuth(): Uri;
  /**
   * Return the fragment component of the Uri which is everything
   * after the "#".  Return null if no fragment specified.
   * 
   * Examples:
   * ```
   * `http://host/path?query#frag`.frag  =>  "frag"
   * `http://host/path`                  =>  null
   * `#h1`                               =>  "h1"
   * ```
   */
  frag(): string | null;
  /**
   * Return the scheme component or null if not absolute.  The
   * scheme is always normalized into lowercase.
   * 
   * Examples:
   * ```
   * `http://foo/a/b/c`.scheme      =>  "http"
   * `HTTP://foo/a/b/c`.scheme      =>  "http"
   * `mailto:who@there.com`.scheme  =>  "mailto"
   * ```
   */
  scheme(): string | null;
  /**
   * Return if the path starts with a leading slash.  If pathStr
   * is empty, then return false.
   * 
   * Examples:
   * ```
   * `http://foo/`.isPathAbs    =>  true
   * `/dir/f.txt`.isPathAbs     =>  true
   * `dir/f.txt`.isPathAbs      =>  false
   * `../index.html`.isPathAbs  =>  false
   * ```
   */
  isPathAbs(): boolean;
  /**
   * Resolve this Uri into a Fantom object. See [docLang](https://fantom.org/doc/docLang/Naming#resolving)
   * for the resolve process.
   */
  get(base?: JsObj | null, checked?: boolean): JsObj | null;
  /**
   * Add the specified query key/value pairs to this Uri. If this
   * uri has an existing query, then it is merged with the given
   * query.  The key/value pairs should not be backslash escaped
   * or percent encoded.  If the query param is null or empty,
   * return this instance.
   * 
   * Examples:
   * ```
   * `http://h/`.plusQuery(["k":"v"])         =>  `http://h/?k=v`
   * `http://h/?k=old`.plusQuery(["k":"v"])   =>  `http://h/?k=v`
   * `/foo?a=b`.plusQuery(["k":"v"])          =>  `/foo?a=b&k=v`
   * `?a=b`.plusQuery(["k1":"v1", "k2":"v2"]) =>  `?a=b&k1=v1&k2=v2`
   * ```
   */
  plusQuery(query: Map<string, string> | null): Uri;
  /**
   * Return a new Uri with only a path part.  If this Uri has an
   * authority, fragment, or query they are stripped off.
   * 
   * Examples:
   * ```
   * `http://host/a/b/c?query`.pathOnly =>  `/a/b/c`
   * `http://host/a/b/c/`.pathOnly      =>  `/a/b/c/`
   * `/a/b/c`.pathOnly                  =>  `/a/b/c`
   * `file.txt`.pathOnly                =>  `file.txt`
   * ```
   */
  pathOnly(): Uri;
  /**
   * Return {@link toStr | toStr}.  This method is used to enable `toLocale`
   * to be used with duck typing across most built-in types.
   */
  toLocale(): string;
  /**
   * Return logical-not of {@link isPathAbs | isPathAbs} when path
   * is empty or does not start with a leading slash.
   */
  isPathRel(): boolean;
  /**
   * Return if a relative Uri which means it has a null scheme.
   */
  isRel(): boolean;
  /**
   * Return if this Uri contains only a path component.  The
   * authority (scheme, host, port), query, and fragment must be
   * null.
   */
  isPathOnly(): boolean;
  /**
   * Return if the specified string is a valid name segment to
   * use in an unencoded URI.  The name must be at least one char
   * long and can never be "." or "..".  The legal characters are
   * defined as follows from RFC 3986:
   * ```
   * unreserved  =  ALPHA / DIGIT / "-" / "." / "_" / "~"
   * ALPHA       =  %x41-5A / %x61-7A   ; A-Z / a-z
   * DIGIT       =  %x30-39 ; 0-9
   * ```
   * 
   * Although RFC 3986 does allow path segments to contain other
   * special characters such as `sub-delims`, Fantom takes a strict
   * approach to names to be used in URIs.
   */
  static isName(name: string): boolean;
  /**
   * Two Uris are equal if they have same string normalized
   * representation.
   */
  equals(that: JsObj | null): boolean;
  /**
   * Encode a token so that any invalid character or delimiter
   * for the given section is "%xx" percent encoding.  Section
   * must be {@link sectionPath | sectionPath}, {@link sectionQuery | sectionQuery},
   * or {@link sectionFrag | sectionFrag}.  Also see {@link decodeToken | decodeToken}.
   * 
   * Examples:
   * ```
   * Uri.encodeToken("a/b#c", Uri.sectionPath)   =>  "a%2Fb%23c"
   * Uri.encodeToken("a=b/c", Uri.sectionQuery)  =>  "a%3Db/c"
   * ```
   */
  static encodeToken(s: string, section: number): string;
  /**
   * A Uri represents a directory if it has a non-null path which
   * ends with a "/" slash.  Directories are joined with other
   * Uris relative to themselves versus non-directories which are
   * joined relative to their parent.
   * 
   * Examples:
   * ```
   * `/a/b`.isDir   =>  false
   * `/a/b/`.isDir  =>  true
   * `/a/?q`.isDir  =>  true
   * ```
   */
  isDir(): boolean;
}

/**
 * MimeType represents the parsed value of a Content-Type
 * header per RFC 2045 section 5.1.
 */
export class MimeType extends Obj {
  static type$: Type
  /**
   * Encode as a MIME message according to RFC 822.  This is
   * always the exact same string passed to {@link fromStr | fromStr}.
   */
  toStr(): string;
  /**
   * If a charset parameter is specified, then map it to the `Charset`
   * instance, otherwise return `Charset.utf8`.
   */
  charset(): Charset;
  /**
   * Return an instance with this mediaType and subType, but
   * strip any parameters.
   */
  noParams(): MimeType;
  /**
   * Map a case insensitive file extension to a MimeType. This
   * mapping is configured via "etc/sys/ext2mime.props".  If no
   * mapping is available return null.
   */
  static forExt(ext: string): MimeType | null;
  /**
   * The primary media type always in lowercase:
   * ```
   * text/html  =>  text
   * ```
   */
  mediaType(): string;
  /**
   * Additional parameters stored in case-insensitive map. If no
   * parameters, then this is an empty map.
   * ```
   * text/html; charset=utf-8    =>  [charset:utf-8]
   * text/html; charset="utf-8"  =>  [charset:utf-8]
   * ```
   */
  params(): Map<string, string>;
  /**
   * Parse from string format.  If invalid format and checked is
   * false return null, otherwise throw ParseErr. Parenthesis
   * comments are treated as part of the value.
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): MimeType;
  /**
   * Equality is based on the case insensitive mediaType and
   * subType, and params (keys are case insensitive and values
   * are case sensitive).
   */
  equals(that: JsObj | null): boolean;
  /**
   * The subtype always in lowercase:
   * ```
   * text/html  =>  html
   * ```
   */
  subType(): string;
  /**
   * Hash code is derived from the mediaType, subType, and params
   * hashes.
   */
  hash(): number;
  /**
   * Parse a set of attribute-value parameters where the values
   * may be tokens or quoted-strings.  The resulting map is case
   * insensitive. If invalid format return null or raise ParseErr
   * based on checked flag. Parenthesis comments are not
   * supported.  If a value pair is missing "= value", then the
   * value is defaulted to "".
   * 
   * Examples:
   * ```
   * a=b; c="d"       =>  ["a":"b", "c"="d"]
   * foo=bar; secure  =>  ["foo":"bar", "secure":""]
   * ```
   */
  static parseParams(s: string, checked?: boolean): Map<string, string> | null;
  /**
   * Return if this mime type is known to be text.  This includes
   * all "text/*" mime types along with special cases like
   * "application/json".
   */
  isText(): boolean;
}

/**
 * NotImmutableErr indicates using a mutable Obj where an
 * immutable Obj is required.  See Obj.isImmutable for the
 * definition of immutability.
 */
export class NotImmutableErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): NotImmutableErr;
}

/**
 * Enum for seven days of the week.
 */
export class Weekday extends Enum {
  static type$: Type
  /**
   * Thursday
   */
  static thu(): Weekday;
  /**
   * Tuesday
   */
  static tue(): Weekday;
  /**
   * List of Weekday values indexed by ordinal
   */
  static vals(): List<Weekday>;
  /**
   * Sunday
   */
  static sun(): Weekday;
  /**
   * Monday
   */
  static mon(): Weekday;
  /**
   * Wednesday
   */
  static wed(): Weekday;
  /**
   * Friday
   */
  static fri(): Weekday;
  /**
   * Saturday
   */
  static sat(): Weekday;
  /**
   * Get the first day of the week for the current locale. For
   * example in the United States, `sun` is considered the start of
   * the week.  Configured by `sys::weekdayStart` localized
   * property.  Also see {@link localeVals | localeVals}.
   */
  static localeStartOfWeek(): Weekday;
  /**
   * Return the day after this weekday.
   */
  increment(): Weekday;
  /**
   * Get the days of the week ordered according to the locale's
   * start of the week.  Also see {@link localeStartOfWeek | localeStartOfWeek}.
   */
  static localeVals(): List<Weekday>;
  /**
   * Get the abbreviated name for the current locale. Configured
   * by the `sys::<name>Abbr` localized property.
   */
  localeAbbr(): string;
  /**
   * Return the weekday as a localized string according to the
   * specified pattern.  The pattern rules are a subset of the {@link DateTime.toLocale | DateTime.toLocale}:
   * ```
   * WWW    Three letter abbr weekday  Tue
   * WWWW   Full weekday name          Tuesday
   * ```
   * 
   * If pattern is null it defaults to "WWW".  Also see {@link localeAbbr | localeAbbr}
   * and {@link localeFull | localeFull}.
   */
  toLocale(pattern?: string | null, locale?: Locale): string;
  /**
   * Return the Weekday instance for the specified name.  If not
   * a valid name and checked is false return null, otherwise
   * throw ParseErr.
   */
  static fromStr(name: string, checked?: boolean, ...args: unknown[]): Weekday;
  /**
   * Return the day before this weekday.
   */
  decrement(): Weekday;
  /**
   * Get the full name for the current locale. Configured by the `sys::<name>Full`
   * localized property.
   */
  localeFull(): string;
}

/**
 * Buf is used to model a block of bytes with random access. 
 * Buf is typically backed by a block of memory, but can also
 * be backed by a file:
 * - {@link make | Buf.make}: backed by RAM
 * - {@link File.open | File.open}: backed by random access file
 * - {@link File.mmap | File.mmap}: backed by memory mapped file
 * 
 * Buf provides an {@link InStream | InStream} and {@link OutStream | OutStream}
 * to read and write into the buffer using a configurable
 * position accessed via {@link pos | Buf.pos} and {@link seek | Buf.seek}.
 * 
 * When using an InStream, bytes are read starting at pos where
 * pos is advanced after each read.  The end of stream is
 * reached when pos reaches size.  When using the OutStream,
 * bytes are written starting at pos with pos advanced after
 * each write.  If pos is less then size then the existing
 * bytes are rewritten and size is not advanced, otherwise the
 * buffer is automatically grown and size is advanced as bytes
 * are appended.  It is common to write bytes into the buffer
 * using the OutStream, then call {@link flip | Buf.flip} to
 * prepare the buffer to be used for reading.
 * 
 * Memory bufs may be made immutable by calling {@link Obj.toImmutable | Obj.toImmutable}.
 * When a buf is made immutable, the original buffer's data is
 * cleared (to avoid copying the backing array).  All write
 * operations on an immutable buf will raise a `ReadonlyErr`. 
 * Reads may be performed by acquiring an InStream via the {@link in | in}
 * method.  However, read operations which require a mutable
 * Buf pos will raise ReadonlyErr too, including methods such
 * as {@link seek | seek} or {@link read | read}. Use {@link dup | dup}
 * to copy an immutable buf back into a mutable buf.
 */
export class Buf extends Obj {
  static type$: Type
  /**
   * Byte order mode for both OutStream and InStream. Default is {@link Endian.big | Endian.big}
   * (network byte order).
   */
  endian(): Endian;
  endian(it: Endian): void;
  /**
   * Return the total number of bytes in the buffer.  If the size
   * is set greater than capacity then the buffer's capacity is
   * automatically grown, otherwise capacity remains the same. 
   * Setting size does not actually change any bytes in the
   * buffer.  A mmap buffer can never be increased from its
   * initial size.
   */
  size(): number;
  size(it: number): void;
  /**
   * Character set for both the OutStream and InStream.
   */
  charset(): Charset;
  charset(it: Charset): void;
  /**
   * The number of bytes this buffer can hold without allocating
   * more memory.  Capacity is always greater or equal to size. 
   * If adding a large number of bytes, it may be more efficient
   * to manually set capacity.  See the {@link trim | trim} method
   * to automatically set capacity to size.  Throw ArgErr if
   * attempting to set capacity less than size. This method is
   * ignored on a file buffer, and unsupported on mmap.
   */
  capacity(): number;
  capacity(it: number): void;
  /**
   * Convenience for {@link InStream.readF4 | in.readF4}
   */
  readF4(): number;
  /**
   * Convenience for {@link InStream.readDecimal | in.readDecimal}
   */
  readDecimal(): number;
  /**
   * Convenience for {@link InStream.readAllStr | in.readAllStr}
   */
  readAllStr(normalizeNewlines?: boolean): string;
  /**
   * Decode the specified hexadecimal string into its binary
   * contents.  Any characters which are not included in the set
   * "0-9, a-f, A-F" are ignored as long as they appear between
   * bytes (hi and lo nibbles must be contiguous).
   * 
   * Example:
   * ```
   * Buf.make.print("\r\n").toHex   => "0d0a"
   * Buf.fromHex("0d0a").readAllStr => "\r\n"
   * ```
   */
  static fromHex(s: string): Buf;
  /**
   * Convenience for {@link InStream.readBufFully | in.readBufFully}
   */
  readBufFully(buf: Buf | null, n: number): Buf;
  /**
   * Decode the specified Base64 string into its binary contents.
   * Both MIME RFC 2045 and URI-safe RFC 4648 encodings are
   * supported. Any characters which are not included in the
   * Base64 character set are safely ignored.
   * 
   * Example:
   * ```
   * Buf.make.print("Fan").toBase64    => "RmFu"
   * Buf.fromBase64("RmFu").readAllStr => "Fan"
   * ```
   */
  static fromBase64(s: string): Buf;
  /**
   * Convenience for {@link InStream.readF8 | in.readF8}
   */
  readF8(): number;
  /**
   * Convenience for {@link OutStream.writeProps | out.writeProps}
   * Return this.
   */
  writeProps(props: Map<string, string>): this;
  /**
   * Convenience for {@link InStream.readS2 | in.readS2}
   */
  readS2(): number;
  /**
   * Convenience for {@link InStream.readS1 | in.readS1}
   */
  readS1(): number;
  /**
   * Convenience for {@link InStream.readS4 | in.readS4}
   */
  readS4(): number;
  /**
   * Trim the capacity such that the underlying storage is
   * optimized for the current size.  Return this.
   */
  trim(): this;
  /**
   * Return a new buffer containing the bytes in the specified
   * absolute range.  Negative indexes may be used to access from
   * the end of the buf.  This method accesses the buffer
   * absolutely independent of current position.  This method is
   * accessed via the [] operator. Throw IndexErr if range
   * illegal.
   * 
   * Examples:
   * ```
   * buf := Buf.make
   * buf.write(0xaa).write(0xbb).write(0xcc).write(0xdd)
   * buf[0..2]   => 0x[aabbcc]
   * buf[3..3]   => 0x[dd]
   * buf[-2..-1] => 0x[ccdd]
   * buf[0..<2]  => 0x[aabb]
   * buf[1..-2]  => 0x[bbcc]
   * ```
   */
  getRange(range: Range): Buf;
  /**
   * Convenience for {@link InStream.readBuf | in.readBuf}
   */
  readBuf(buf: Buf, n: number): number | null;
  /**
   * Return if the buffer contents are the same size and same
   * bytes. Note this could be an extremely expensive call for
   * non-memory buffers.
   */
  bytesEqual(that: Buf): boolean;
  /**
   * Convenience for {@link OutStream.write | out.write} Return
   * this.
   */
  write(byte: number): this;
  /**
   * Convenience for {@link InStream.readS8 | in.readS8}
   */
  readS8(): number;
  /**
   * Convenience for {@link InStream.unreadChar | in.unreadChar}
   * Memory backed buffers support a stack based pushback model
   * like IO streams.  File backed buffers will simply rewrite
   * the last position in the file.  Return this.
   */
  unreadChar(b: number): this;
  /**
   * Return string summary of the buffer.
   */
  toStr(): string;
  /**
   * Convenience for {@link OutStream.writeI4 | out.writeI4}
   * Return this.
   */
  writeI4(n: number): this;
  /**
   * Convenience for {@link OutStream.printLine | out.printLine}
   * Return this.
   */
  printLine(obj?: JsObj | null): this;
  /**
   * Encode the buffer contents from 0 to size to a Base64 string
   * as defined by MIME RFC 2045.  No line breaks are added. 
   * This method is only supported by memory-backed buffers;
   * file-backed buffers will throw UnsupportedErr.
   * 
   * Example:
   * ```
   * Buf.make.print("Fan").toBase64    => "RmFu"
   * Buf.fromBase64("RmFu").readAllStr => "Fan"
   * ```
   */
  toBase64(): string;
  /**
   * Convenience for {@link OutStream.writeI2 | out.writeI2}
   * Return this.
   */
  writeI2(n: number): this;
  /**
   * Convenience for {@link InStream.read | in.read}
   */
  read(): number | null;
  /**
   * Convenience for {@link OutStream.writeI8 | out.writeI8}
   * Return this.
   */
  writeI8(n: number): this;
  /**
   * Get the InStream which reads from this buffer. This method
   * always returns the same instance. If this buffer is backed
   * by a file, then `in.close` will not close the file - you must
   * use {@link close | Buf.close}.
   */
  in(): InStream;
  /**
   * Encode the buffer contents from 0 to size to a Uri-safe
   * Base64 string as defined by RFC 4648. This means `+` is
   * encoded as `-`, and `/` is encoded as `_`. Additionally, no
   * padding is applied. This method is only supported by
   * memory-backed buffers; file-backed buffers will throw
   * UnsupportedErr.
   * 
   * Example:
   * ```
   * Buf.make.print("safe base64~~").toBase64    => "c2FmZSBiYXNlNjR+fg=="
   * Buf.make.print("safe base64~~").toBase64Uri => "c2FmZSBiYXNlNjR-fg"
   * ```
   */
  toBase64Uri(): string;
  /**
   * Write the specified byte to the end of the buffer using
   * given count.
   * 
   * Examples:
   * ```
   * Buf().fill(0xff, 4)  =>  0xffffffff
   * ```
   */
  fill(byte: number, times: number): this;
  /**
   * If this Buf is backed by a file, then fsync all changes to
   * the storage device.  Throw IOErr on error.  Return this.
   */
  sync(): this;
  /**
   * Return the remaining number of bytes to read: size-pos.
   */
  remaining(): number;
  /**
   * Convenience for {@link InStream.readProps | in.readProps}
   */
  readProps(): Map<string, string>;
  /**
   * Encode the buffer contents from 0 to size into a hexadecimal
   * string.  This method is unsupported for mmap buffers.
   * 
   * Example:
   * ```
   * Buf.make.print("\r\n").toHex   => "0d0a"
   * Buf.fromHex("0d0a").readAllStr => "\r\n"
   * ```
   */
  toHex(): string;
  /**
   * Convenience for {@link OutStream.writeUtf | out.writeUtf}
   * Return this.
   */
  writeUtf(s: string): this;
  /**
   * Create an in-memory File instance for this buffer with the
   * given file URI.  The buffer must be a RAM based buffer which
   * is converted to an immutable buffer via `Obj.toImmutable`
   * semantics.  The current time is used for the file's modified
   * time.
   */
  toFile(uri: Uri): File;
  /**
   * Generate a password based cryptographic key.  Supported
   * algorithms:
   * - "PBKDF2WithHmacSHA1"
   * - "PBKDF2WithHmacSHA256"
   * 
   * Parameters:
   * - password: secret used to generate resulting cryptographic
   *   key
   * - salt: cryptographic salt
   * - iterations: number of iterations (the `c` term)
   * - keyLen: desired length of key in bytes (not bits!)
   * 
   * Throw ArgErr if the algorithm is not available.  This method
   * is only supported for memory buffers.
   */
  static pbk(algorithm: string, password: string, salt: Buf, iterations: number, keyLen: number): Buf;
  /**
   * Convenience for {@link OutStream.writeChars | out.writeChars}
   * Return this.
   */
  writeChars(str: string, off?: number, len?: number): this;
  /**
   * Apply the specified message digest algorithm to this
   * buffer's contents from 0 to size and return the resulting
   * hash.  Digests are secure one-way hash functions which input
   * an arbitrary sized buffer and return a fixed sized buffer. 
   * Common algorithms include: "MD5", "SHA-1", and "SHA-256";
   * the full list supported is platform dependent.  On the Java
   * VM, the algorithm maps to those available via the `java.security.MessageDigest`
   * API.  Throw ArgErr if the algorithm is not available.  This
   * method is unsupported for mmap buffers.
   * 
   * Example:
   * ```
   * Buf.make.print("password").print("salt").toDigest("MD5").toHex
   *  =>  "b305cadbb3bce54f3aa59c64fec00dea"
   * ```
   */
  toDigest(algorithm: string): Buf;
  /**
   * Convenience for {@link InStream.unread | in.unread} Memory
   * backed buffers support a stack based pushback model like IO
   * streams.  File backed buffers will simply rewrite the last
   * position in the file.  Return this.
   */
  unread(b: number): this;
  /**
   * Convenience for {@link OutStream.writeF4 | out.writeF4}
   * Return this.
   */
  writeF4(r: number): this;
  /**
   * Convenience for {@link OutStream.writeXml | out.writeXml}
   * Return this.
   */
  writeXml(s: string, flags?: number): this;
  /**
   * Convenience for {@link InStream.readAllLines | in.readAllLines}
   */
  readAllLines(): List<string>;
  /**
   * Convenience for {@link InStream.readAllBuf | in.readAllBuf}
   */
  readAllBuf(): Buf;
  /**
   * Set the current position to the specified byte offset.  A
   * negative index may be used to access from the end of the
   * buffer. For example seek(-1) is translated into
   * seek(size-1). Return this.
   */
  seek(pos: number): this;
  /**
   * Convenience for {@link OutStream.writeBool | out.writeBool}
   * Return this.
   */
  writeBool(b: boolean): this;
  /**
   * Convenience for {@link InStream.readChar | in.readChar}
   */
  readChar(): number | null;
  /**
   * Get the OutStream which writes to this buffer. This method
   * always returns the same instance. If this buffer is backed
   * by a file, then `out.close` will not close the file - you must
   * use {@link close | Buf.close}.
   */
  out(): OutStream;
  /**
   * Convenience for {@link InStream.readU4 | in.readU4}
   */
  readU4(): number;
  /**
   * Generate a random series of bytes.
   * 
   * Example:
   * ```
   * Buf.random(8).toHex  => "d548b54989028b90"
   * ```
   */
  static random(size: number): Buf;
  /**
   * Obsolete call to {@link sync | sync}.  In the future this
   * method may be relaxed to flush only memory buffers, but not
   * force an fsync.
   */
  flush(): this;
  /**
   * Convenience for {@link InStream.readUtf | in.readUtf}
   */
  readUtf(): string;
  /**
   * Return the current position for the next read or write.  The
   * position is always between 0 and {@link size | size}.  If pos
   * is less than size then future writes will rewrite the
   * existing bytes without growing size.  Change the position
   * with {@link seek | seek}.
   */
  pos(): number;
  /**
   * Compute a cycle redundancy check code using this buffer's
   * contents from 0 to size.  The supported algorithm names:
   * - "CRC-16": also known as CRC-16-ANSI, CRC-16-IBM; used by
   *   USB, ANSI X3.28, and Modbus
   * - "CRC-32": used by Ethernet, MPEG-2, PKZIP, Gzip, PNG
   * - "CRC-32-Adler": used by Zlib
   * 
   * Raise ArgErr if algorithm is not available.  This method is
   * only supported for memory based buffers.
   */
  crc(algorithm: string): number;
  /**
   * Convenience for {@link InStream.readU2 | in.readU2}
   */
  readU2(): number;
  /**
   * Get the byte at the specified absolute index.  A negative
   * index may be used to access from the end of the buffer.  For
   * example get(-1) is translated into get(size-1).  This method
   * accesses the buffer absolutely independent of current
   * position.  The get method is accessed via the [] shortcut
   * operator.  Throw IndexErr if index out of range.
   */
  get(index: number): number;
  /**
   * Convenience for {@link InStream.readU1 | in.readU1}
   */
  readU1(): number;
  /**
   * Generate an HMAC message authentication as specified by RFC
   * 2104. This buffer is the data input, `algorithm` specifies the
   * hash digest, and `key` represents the secret key:
   * - `H`: specified by algorthim parameter - "MD5" or "SHA1"
   * - `K`: secret key specified by key parameter
   * - `B`: fixed at 64
   * - `text`: this instance
   * 
   * The HMAC is computed using:
   * ```
   * ipad = the byte 0x36 repeated B times
   * opad = the byte 0x5C repeated B times
   * H(K XOR opad, H(K XOR ipad, text))
   * ```
   * 
   * Throw ArgErr if the algorithm is not available.  This method
   * is only supported for memory buffers.
   * 
   * Examples:
   * ```
   * "hi there".toBuf.hmac("MD5", "secret".toBuf)
   * ```
   */
  hmac(algorithm: string, key: Buf): Buf;
  /**
   * Convenience for {@link OutStream.writeF8 | out.writeF8}
   * Return this.
   */
  writeF8(r: number): this;
  /**
   * Allocate a byte buffer in RAM with the initial given
   * capacity.
   */
  static make(capacity?: number, ...args: unknown[]): Buf;
  /**
   * Flip a buffer from write-mode to read-mode.  This method
   * sets total size to current position, and position to 0. 
   * Return this.
   */
  flip(): this;
  /**
   * If this buffer is backed by a file, then close it.  If a
   * memory buffer then do nothing.  This method is guaranteed to
   * never throw an IOErr.  Return true if the buffer was closed
   * successfully or false if closed abnormally.
   */
  close(): boolean;
  /**
   * Convenience for {@link InStream.readBool | in.readBool}
   */
  readBool(): boolean;
  /**
   * Set is used to overwrite the byte at the specified index.  A
   * negative index may be used to access an index from the end
   * of the buffer.  The set method is accessed via the []=
   * shortcut operator. Return this.  Throw IndexErr if index is
   * out of range.
   */
  set(index: number, byte: number): this;
  /**
   * Convenience for {@link OutStream.writeBuf | out.writeBuf}
   * Return this.
   */
  writeBuf(buf: Buf, n?: number): this;
  /**
   * Convenience for {@link InStream.readObj | in.readObj}
   */
  readObj(options?: Map<string, JsObj> | null): JsObj | null;
  /**
   * Return if more bytes are available to read: remaining() > 0.
   */
  more(): boolean;
  /**
   * Convenience for {@link InStream.peekChar | in.peekChar}
   */
  peekChar(): number | null;
  /**
   * Return if size() == 0.
   */
  isEmpty(): boolean;
  /**
   * Read the buffer for a fresh read by reseting the buffer's
   * pos and size to zero.  The buffer's capacity remains the
   * same. Return this.
   */
  clear(): this;
  /**
   * Convenience for {@link OutStream.writeObj | out.writeObj}
   * Return this.
   */
  writeObj(obj: JsObj | null, options?: Map<string, JsObj> | null): this;
  /**
   * Convenience for {@link InStream.readStrToken | in.readStrToken}
   */
  readStrToken(max?: number | null, c?: ((arg0: number) => boolean) | null): string | null;
  /**
   * Convenience for {@link InStream.readLine | in.readLine}
   */
  readLine(max?: number | null): string | null;
  /**
   * Convenience for {@link InStream.peek | in.peek}
   */
  peek(): number | null;
  /**
   * Convenience for {@link OutStream.writeChar | out.writeChar}
   * Return this.
   */
  writeChar(char: number): this;
  /**
   * Convenience for {@link OutStream.print | out.print} Return
   * this.
   */
  print(s: JsObj | null): this;
  /**
   * Convenience for {@link InStream.readChars | in.readChars}
   */
  readChars(n: number): string;
  /**
   * Convenience for {@link InStream.eachLine | in.eachLine}
   */
  eachLine(f: ((arg0: string) => void)): void;
  /**
   * Buf equality is based on reference equality using the ===
   * operator.
   */
  equals(that: JsObj | null): boolean;
  /**
   * Convenience for {@link OutStream.writeDecimal | out.writeDecimal}
   * Return this.
   */
  writeDecimal(d: number): this;
  /**
   * Create a new buffer in memory which deeply clones this
   * buffer. The resulting buf is read/write.
   */
  dup(): Buf;
}

/**
 * UnknownKeyErr indicates an attempt to lookup a non-existent
 * key.
 */
export class UnknownKeyErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): UnknownKeyErr;
}

/**
 * Indicates that a type or slot is obsolete
 */
export class Deprecated extends Obj implements Facet {
  static type$: Type
  /**
   * Message for compiler output when deprecated type or slot is
   * used.
   */
  msg(): string;
  __msg(it: string): void;
  static make(f?: ((arg0: Deprecated) => void) | null, ...args: unknown[]): Deprecated;
}

/**
 * CancelledErr indicates that an operation was cancelled
 * before it completed normally.
 */
export class CancelledErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): CancelledErr;
}

/**
 * Transient annotates fields which should not be serialized. 
 * It is used inside a {@link Serializable | Serializable} type.
 * See the [Serialization Doc](https://fantom.org/doc/docLang/Serialization)
 * for details.
 */
export class Transient extends Obj implements Facet {
  static type$: Type
  /**
   * Singleton for Transient facet.
   */
  static defVal(): Transient;
}

/**
 * NameErr indicates an attempt to use an invalid name. See {@link Uri.isName | Uri.isName}
 * and {@link Uri.checkName | Uri.checkName}.
 */
export class NameErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): NameErr;
}

/**
 * Num is the base class for number classes: {@link Int | Int}, {@link Float | Float},
 * and {@link Decimal | Decimal}.
 */
export class Num extends Obj {
  static type$: Type
  /**
   * Convert this number to an Int.
   */
  static toInt(self: number): number;
  /**
   * Get the current locale's symbol for the percent sign.
   */
  static localePercent(): string;
  /**
   * Convert this number to a Float.
   */
  static toFloat(self: number): number;
  /**
   * Get the current locale's string representation for
   * not-a-number.
   */
  static localeNaN(): string;
  /**
   * Get the current locale's minus sign used to represent a
   * negative number.
   */
  static localeMinus(): string;
  /**
   * Get the current locale's string representation for negative
   * infinity.
   */
  static localeNegInf(): string;
  /**
   * Get the current locale's decimal separator. For example in
   * the the US this is a dot.
   */
  static localeDecimal(): string;
  /**
   * Convert this number to a Decimal.
   */
  static toDecimal(self: number): number;
  /**
   * Get the current locale's separator for grouping thousands
   * together.  For example in the US this is a comma.
   */
  static localeGrouping(): string;
  /**
   * Get the current locale's string representation for positive
   * infinity.
   */
  static localePosInf(): string;
}

/**
 * Charset represents a specific character encoding.  It is
 * used to decode bytes to Unicode characters, and encode
 * Unicode characters to bytes.
 */
export class Charset extends Obj {
  static type$: Type
  /**
   * Return name().
   */
  toStr(): string;
  /**
   * A charset for "UTF-8" format (Eight-bit UCS Transformation
   * Format).
   */
  static utf8(): Charset;
  /**
   * A charset for "UTF-16BE" format (Sixteen-bit UCS
   * Transformation Format, big-endian byte order).
   */
  static utf16BE(): Charset;
  /**
   * Attempt to lookup a Charset by name.  Use one of the
   * predefined methods such as {@link utf8 | utf8} to get a
   * standard encoding.  If charset not found and checked is
   * false return null, otherwise throw ParseErr.
   */
  static fromStr(name: string, checked?: boolean, ...args: unknown[]): Charset;
  /**
   * Charset equality is based on the character set name ignoring
   * case (names are not case-sensitive).
   */
  equals(obj: JsObj | null): boolean;
  /**
   * Get the name of this character encoding.
   */
  name(): string;
  /**
   * A charset for "UTF-16LE" format (Sixteen-bit UCS
   * Transformation Format, little-endian byte order).
   */
  static utf16LE(): Charset;
  /**
   * Compute hash code based on case-insensitive name.
   */
  hash(): number;
  /**
   * Default value is {@link utf8 | utf8}.
   */
  static defVal(): Charset;
}

/**
 * Used to annoate types which should be compiled into
 * JavaScript.
 */
export class Js extends Obj implements Facet {
  static type$: Type
  /**
   * Singleton for Js facet.
   */
  static defVal(): Js;
}

/**
 * ReadonlyErr indicates an attempt to modify a readonly
 * instance. It is commonly used with List and Map.
 */
export class ReadonlyErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): ReadonlyErr;
}

/**
 * Type defines the contract of an Obj by the slots it
 * supports. Types model the inheritance relationships and
 * provide a mapping for all the slots both inherited and
 * declared.
 */
export class Type extends Obj {
  static type$: Type
  /**
   * Return a recursive flattened list of all the types this type
   * inherits from.  The result list always includes this type
   * itself. The result of this method represents the complete
   * list of types implemented by this type - instances of this
   * type are assignable to any type in this list.  All types
   * (including mixins) will include sys::Obj in this list.
   * 
   * Examples:
   * ```
   * Obj#.inheritance  =>  [sys::Obj]
   * Int#.inheritance  =>  [sys::Int, sys::Num, sys::Obj]
   * ```
   */
  inheritance(): List<Type>;
  /**
   * Return if this Type was generated by the compiler.
   */
  isSynthetic(): boolean;
  /**
   * Get the list of facets defined on this type or return an
   * empty list if no facets are defined. If looking up a facet
   * by type, then use the {@link facet | facet} method which will
   * provide better performance. See [Facets Doc](https://fantom.org/doc/docLang/Facets)
   * for details.
   */
  facets(): List<Facet>;
  /**
   * Return the mixins directly implemented by this type.
   * 
   * Examples:
   * ```
   * Obj#.mixins        =>  [,]
   * Buf#.mixins        =>  [sys::InStream, sys::OutStream]
   * OutStream#.mixins  =>  [,]
   * ```
   */
  mixins(): List<Type>;
  /**
   * Find a Type by its qualified name "pod::Type".  If the type
   * doesn't exist and checked is false then return null,
   * otherwise throw UnknownTypeErr.
   */
  static find(qname: string, checked?: boolean): Type | null;
  /**
   * Qualified name formatted as "pod::name".  For parameterized
   * types derived from List, Map, or Func, this method always
   * returns "sys::List", "sys::Map", or "sys::Func"
   * respectively.  If this is a nullable type, the qname does *not*
   * include the "?".
   * 
   * Examples:
   * ```
   * Str#.qname         => "sys::Str"
   * Str?#.qname        => "sys::Str"
   * acme::Foo#.qname   => "acme::Foo"
   * acme::Foo[]#.qname => "sys::List"
   * ```
   */
  qname(): string;
  /**
   * Return if this Type is a Facet type.
   */
  isFacet(): boolean;
  /**
   * Always return signature().
   */
  toStr(): string;
  /**
   * Convenience for (Method)slot(name, checked)
   */
  method(name: string, checked?: boolean): Method | null;
  /**
   * If this is a parameterized type, then return the map of
   * names to types.  If this is not a parameterized type return
   * an empty map.
   * 
   * Examples:
   * ```
   * Str#.params => [:]
   * Str[]#.params => ["V":Str, "L":Str[]]
   * Int:Slot#.params => ["K":Int, "V":Slot, "M":Int:Slot]
   * |Int x, Float y->Bool|#.params => ["A":Int, "B":Float, "R":Bool]
   * ```
   */
  params(): Map<string, Type>;
  /**
   * Does this type implement the specified type.  If true, then
   * this type is assignable to the specified type (although the
   * converse is not necessarily true).  This method provides the
   * same semantics as the `is` operator, but between two types
   * rather than an instance and a type.  All types (including
   * mixin types) fit `sys::Obj`.
   * 
   * This method implicitly ignores the nullability of both `this`
   * and `t` such that this method is always equivalent to:
   * ```
   * this.toNonNullable.fits(t.toNonNullable)
   * ```
   * 
   * Example:
   * ```
   * Float#.fits(Float#) =>  true
   * Float#.fits(Num#)   =>  true
   * Float#.fits(Obj#)   =>  true
   * Float#.fits(Str#)   =>  false
   * Obj#.fits(Float#)   =>  false
   * ```
   */
  fits(t: Type): boolean;
  /**
   * Return if this Type has internal protection scope.
   */
  isInternal(): boolean;
  /**
   * List of all the defined slots, both fields and methods
   * (including inherited slots).
   */
  slots(): List<Slot>;
  /**
   * Convenience for (Field)slot(name, checked)
   */
  field(name: string, checked?: boolean): Field | null;
  /**
   * Is this a nullable type.  Nullable types can store the `null`
   * value, but non-nullables are never null.  Null types are
   * indicated with a trailing "?".
   */
  isNullable(): boolean;
  /**
   * Simple name of the type such as "Str".  For parameterized
   * types derived from List, Map, or Func, this method always
   * returns "List", "Map", or "Func" respectively.
   * 
   * Examples:
   * ```
   * Str#.name         => "Str"
   * acme::Foo#.name   => "Foo"
   * acme::Foo[]#.name => "List"
   * ```
   */
  name(): string;
  /**
   * Return the raw fandoc for this type or null if not
   * available.
   */
  doc(): string | null;
  /**
   * List of all the defined fields (including inherited fields).
   */
  fields(): List<Field>;
  /**
   * Return this type as a non-nullable type.  If this type is
   * already non-nullable then return this.
   */
  toNonNullable(): Type;
  /**
   * Return if this type has the specified facet defined.
   */
  hasFacet(type: Type): boolean;
  /**
   * Parent pod which defines this type.  For parameterized types
   * derived from List, Map, or Func, this method always returns
   * the sys pod.
   * 
   * Examples:
   * ```
   * Str#.pod         => sys
   * acme::Foo#.pod   => acme
   * acme::Foo[]#.pod => sys
   * ```
   */
  pod(): Pod | null;
  /**
   * Return the formal signature of this type.  In the case of
   * non-parameterized types the signature is the same as qname.
   * For parameterized types derived from List, Map, or Func the
   * signature uses the following special syntax:
   * ```
   * List => V[]
   * Map  => [K:V]
   * Func => |A,B...->R|
   * ```
   * 
   * If this is a nullable type, the signature ends with "?" such
   * as "sys::Int?".
   * 
   * Examples:
   * ```
   * Str#.signature => "sys::Str"
   * Str?#.signature => "sys::Str?"
   * Int[]#.signature => "sys::Int[]"
   * Int:Str#.signature => "[sys::Int:sys::Str]"
   * Str:Buf[]#.signature => [sys::Str:sys::Buf[]]
   * |Float x->Bool|#.signature => "|sys::Float->sys::Bool|"
   * |Float x, Int y|#.signature => |sys::Float,sys::Int->sys::Void|
   * ```
   */
  signature(): string;
  /**
   * List of all the defined methods (including inherited
   * methods).
   */
  methods(): List<Method>;
  /**
   * Lookup a slot by name.  If the slot doesn't exist and
   * checked is false then return null, otherwise throw
   * UnknownSlotErr. Slots are any field or method in this type's
   * scope including those defined directly by this type and
   * those inherited from super class or mixins.
   */
  slot(name: string, checked?: boolean): Slot | null;
  /**
   * Return this type as a nullable type.  If this type is
   * already nullable then return this.
   */
  toNullable(): Type;
  /**
   * Return an immutable empty list of this type.  Since
   * immutable lists can be used safely everywhere, this allows
   * signficant memory savings instead of allocating new empty
   * lists.
   * 
   * Examples:
   * ```
   * Str#.emptyList  =>  Str[,]
   * ```
   */
  emptyList(): List<JsObj>;
  /**
   * Return if this is a const class which means instances of
   * this class are immutable.
   */
  isConst(): boolean;
  /**
   * Get the class Type of the given instance.  Also see {@link Obj.typeof | Obj.typeof}
   * which provides the same functionality.
   */
  static of(obj: JsObj): Type;
  /**
   * Return if this Type has public protection scope.
   */
  isPublic(): boolean;
  /**
   * Return if this Type is marked final which means it may not
   * be subclassed.
   */
  isFinal(): boolean;
  /**
   * Create a new instance of this Type using the following
   * rules:
   * 1. Call public constructor `make` with specified arguments
   * 2. If no public constructor called `make` or invalid number of of
   *   required arguments, then return value of `defVal` slot (must
   *   be static field or static method with zero params)
   * 3. If no public `defVal` field, then throw Err
   */
  make(args?: List<JsObj> | null): JsObj;
  /**
   * Return if this Type is a class (as opposed to enum or mixin)
   */
  isClass(): boolean;
  /**
   * Return {@link signature | signature}.  This method is used to
   * enable `toLocale` to be used with duck typing across most
   * built-in types.  Note: we may change the specification of
   * this method in the future to allow localized type names.
   */
  toLocale(): string;
  /**
   * If this is a generic type, then dynamically create a new
   * parameterized type with the specified name to type map.  If
   * this type is not generic then throw UnsupportedErr.  Throw
   * ArgErr if params fails to specify the required parameters:
   * ```
   * List => V required
   * Map  => K, V required
   * Func => R required, A-H optional
   * ```
   * 
   * Examples:
   * ```
   * List#.parameterize(["V":Bool#]) => Bool[]
   * Map#.parameterize(["K":Str#, "V":Obj#]) => Str:Obj
   * ```
   */
  parameterize(params: Map<string, Type>): Type;
  /**
   * A generic type contains slot signatures which may be
   * parameterized - for example Map's key and value types are
   * generic as K and V.  Fantom supports three built-in generic
   * types: List, Map, and Func.   A parameterized type such as
   * Str[] is not a generic type (all of its generic parameters
   * have been filled in).  User defined generic types are not
   * supported in Fantom.
   * 
   * Examples:
   * ```
   * Str#.isGeneric   => false
   * List#.isGeneric  => true
   * Str[]#.isGeneric => false
   * ```
   */
  isGeneric(): boolean;
  /**
   * Return if this Type is an Enum type.
   */
  isEnum(): boolean;
  /**
   * Is this a value type.  Fantom supports three implicit value
   * types: {@link Bool | Bool}, {@link Int | Int}, and {@link Float | Float}.
   */
  isVal(): boolean;
  /**
   * Return if this Type is abstract and cannot be instantiated. 
   * This method will always return true if the type is a mixin.
   */
  isAbstract(): boolean;
  /**
   * Return if this Type is a mixin type and cannot be
   * instantiated.
   */
  isMixin(): boolean;
  /**
   * Convenience for `List#.parameterize(["V":this])`
   * 
   * Examples:
   * ```
   * Int#.toListOf => Int[]
   * Str[]#.toListOf => Str[][]
   * ```
   */
  toListOf(): Type;
  /**
   * Get a facet by its type.  If not found on this type then
   * return null or throw UnknownFacetErr based on check flag.
   * See [Facets Doc](https://fantom.org/doc/docLang/Facets) for
   * details.
   */
  facet(type: Type, checked?: boolean): Facet | null;
  /**
   * The direct super class of this type (null for Obj). Return
   * sys::Obj for all mixin types.
   * 
   * Examples:
   * ```
   * Obj#.base        =>  null
   * Int#.base        =>  sys::Num
   * OutStream#.base  =>  sys::Obj
   * ```
   */
  base(): Type | null;
}

/**
 * ParseErr indicates an invalid string format which cannot be
 * parsed. It is often used with `fromStr` and `fromLocale`
 * methods.
 */
export class ParseErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): ParseErr;
}

/**
 * IOErr indicates an input/output error typically associated
 * with a file system or socket.
 */
export class IOErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): IOErr;
}

/**
 * InStream is used to read binary and text stream based input.
 */
export class InStream extends Obj {
  static type$: Type
  /**
   * Byte order mode for binary reads. Default is {@link Endian.big | Endian.big}
   * (network byte order).
   */
  endian(): Endian;
  endian(it: Endian): void;
  /**
   * The current charset used to decode bytes into Unicode
   * characters.  The default charset should always be UTF-8.
   */
  charset(): Charset;
  charset(it: Charset): void;
  /**
   * Read the next four bytes as a 32-bit floating point number
   * using configured {@link endian | endian} according to {@link Float.bits32 | Float.bits32}.
   * This method may be paired with {@link OutStream.writeF4 | OutStream.writeF4}.
   * Throw IOErr on error or if the end of stream is reached
   * before four bytes can be read.
   */
  readF4(): number;
  /**
   * Read a decimal string according to {@link readUtf | readUtf}.
   */
  readDecimal(): number;
  /**
   * Read the entire stream into a Str based on the configured
   * charset encoding.  If the normalizeNewlines flag is true,
   * then all occurances of \r\n or \r newlines are normalized
   * into \n.  Return "" if the stream is empty.  Throw IOErr if
   * there is a problem reading the stream or an invalid
   * character encoding is encountered.  This InStream is
   * guaranteed to be closed.
   */
  readAllStr(normalizeNewlines?: boolean): string;
  /**
   * Read the next n bytes from the stream into the Buf at its
   * current position.  The buffer will be grown as needed.  If
   * the buf parameter is null, then a memory buffer is
   * automatically created with a capacity of n.  Block until
   * exactly n bytes have been read or throw IOErr if end of
   * stream is reached first.  Return the Buf passed in or the
   * one created automatically if buf is null. The buffer is
   * automatically positioned at zero.
   */
  readBufFully(buf: Buf | null, n: number): Buf;
  /**
   * Read the next eight bytes as a 64-bit floating point number
   * using configured {@link endian | endian} according to {@link Float.bits | Float.bits}.
   * This method may be paired with {@link OutStream.writeF8 | OutStream.writeF8}.
   * Throw IOErr on error or if the end of stream is reached
   * before four bytes can be read.
   */
  readF8(): number;
  /**
   * Read the next two bytes as a signed 16-bit number using
   * configured {@link endian | endian}.  This method may be
   * paired with {@link OutStream.writeI2 | OutStream.writeI2}.
   * Throw IOErr on error or if the end of stream is reached
   * before two bytes can be read.
   */
  readS2(): number;
  /**
   * Read the next byte as a signed 8-bit number.  This method
   * may be paired with {@link OutStream.write | OutStream.write}.
   * Throw IOErr on error or if the end of stream is reached
   * before one byte can be read.
   */
  readS1(): number;
  /**
   * Read the next four bytes as a signed 32-bit number using
   * configured {@link endian | endian}.  This method may be
   * paired with {@link OutStream.writeI4 | OutStream.writeI4}.
   * Throw IOErr on error or if the end of stream is reached
   * before four bytes can be read.
   */
  readS4(): number;
  /**
   * Attempt to read the next n bytes into the Buf at its current
   * position.  The buffer will be grown as needed.  Return the
   * number of bytes read and increment buf's size and position
   * accordingly. Return null and leave buf's state untouched if
   * end of stream. Note this method may not read the full number
   * of n bytes, use {@link readBufFully | readBufFully} if you
   * must block until all n bytes read. Throw IOErr on error.
   */
  readBuf(buf: Buf, n: number): number | null;
  /**
   * Pipe bytes from this input stream to the specified output
   * stream. If n is specified, then block until exactly n bytes
   * have been read or throw IOErr if end of stream is reached
   * first.  If n is null then the entire contents of this input
   * stream are piped.  If close is true, then this input stream
   * is guaranteed to be closed upon return (the OutStream is
   * never closed).  Return the number of bytes piped to the
   * output stream.
   */
  pipe(out: OutStream, n?: number | null, close?: boolean): number;
  /**
   * Read the next eight bytes as a signed 64-bit number using
   * configured {@link endian | endian}.  This method may be
   * paired with {@link OutStream.writeI8 | OutStream.writeI8}.
   * Throw IOErr on error or if the end of stream is reached
   * before eight bytes can be read.  Note there is no readU8
   * (because Java doesn't support unsigned longs).
   */
  readS8(): number;
  /**
   * Pushback a char so that it is the next char to be read. 
   * This method pushes back one or more bytes depending on the
   * current character encoding.  Return this.
   */
  unreadChar(b: number): this;
  /**
   * Read the next unsigned byte from the input stream. Return
   * null if at end of stream.  Throw IOErr on error.
   */
  read(): number | null;
  /**
   * Read the entire stream into a `Str:Str` of name/value pairs
   * using the Fantom props file format.  This format is similar
   * to but different than the Java properties file format:
   * - Input must be UTF-8 encoded (current charset is ignored)
   * - Name/value pairs formatted as logical line: `<name>=<value>`
   * - Any Unicode character allowed in name or value
   * - Leading and trailing whitespace trimmed from both name and
   *   value
   * - Duplicate name keys within one file is an error condition
   * - Lines starting with `#` are comments
   * - Comment to end of line is `//` if start of line or preceeded
   *   by whitespace
   * - Block comment is `/* *\/` (may be nested)
   * - Use trailing `\` to continue logical line to another actual
   *   line, any leading whitespace (space or tab char) is trimmed
   *   from beginning of continued line
   * - Fantom Str literal escape sequences supported: `\n \r \t or
   *   \uxxxx`
   * - The `$` character is treated as a normal character and should
   *   not be escaped, but convention is to indicate a variable in
   *   a format string
   * - Convention is that name is lower camel case with dot
   *   separators
   * 
   * Throw IOErr if there is a problem reading the stream or an
   * invalid props format is encountered.  This InStream is
   * guaranteed to be closed.
   * 
   * Also see {@link Env.props | Env.props}.
   */
  readProps(): Map<string, string>;
  /**
   * Pushback a byte so that it is the next byte to be read. 
   * There is a finite limit to the number of bytes which may be
   * pushed back.  Return this.
   */
  unread(b: number): this;
  /**
   * Attempt to skip `n` number of bytes.  Return the number of
   * bytes actually skipped which may be equal to or less than n.
   */
  skip(n: number): number;
  /**
   * Read the entire stream into a list of Str lines based on the
   * configured charset encoding.  Each Str in the list maps to a
   * line terminated by \n, \r\n, \r, or EOF using the same
   * semantics as {@link readLine | readLine} with default max
   * line length of null.  The Str lines themselves do not
   * contain a trailing newline.  Empty lines are returned as the
   * empty Str "".  Return an empty list if currently at end of
   * stream (not null).  Throw IOErr if there is a problem
   * reading the stream or an invalid character encoding is
   * encountered.  This InStream is guaranteed to be closed upon
   * return.
   */
  readAllLines(): List<string>;
  /**
   * Read the entire contents of the stream into a memory Buf.
   * The resulting buffer is automatically positioned at the
   * beginning. This InStream is guaranteed to be closed.
   */
  readAllBuf(): Buf;
  /**
   * Read a single Unicode character from the stream using the
   * current charset encoding.  Return null if at end of stream.
   * Throw IOErr if there is a problem reading the stream, or an
   * invalid character encoding is encountered.
   */
  readChar(): number | null;
  /**
   * Read the next four bytes as an unsigned 32-bit number using
   * configured {@link endian | endian}.  This method may be
   * paired with {@link OutStream.writeI4 | OutStream.writeI4}.
   * Throw IOErr on error or if the end of stream is reached
   * before four bytes can be read.
   */
  readU4(): number;
  /**
   * Read a string terminated by the "\0" character.  The "\0"
   * character is read from the stream, but not included in the
   * string result.
   * 
   * The max parameter specifies the maximum number of Unicode
   * characters (not bytes) to read before truncating the string
   * and returning.  If max is null, then no boundary is enforced
   * except of course the end of the stream.
   */
  readNullTerminatedStr(max?: number | null): string;
  /**
   * Read a Str in modified UTF-8 format according to the
   * java.io.DataInput specification. This method may be paired
   * with {@link OutStream.writeUtf | OutStream.writeUtf}. Throw
   * IOErr on error, invalid UTF encoding, or if the end of
   * stream is reached before the string is fully read.
   */
  readUtf(): string;
  /**
   * Read the next two bytes as an unsigned 16-bit number using
   * configured {@link endian | endian}.  This method may be
   * paired with {@link OutStream.writeI2 | OutStream.writeI2}.
   * Throw IOErr on error or if the end of stream is reached
   * before two bytes can be read.
   */
  readU2(): number;
  /**
   * Read the next byte as an unsigned 8-bit number.  This method
   * may be paired with {@link OutStream.write | OutStream.write}.
   * Throw IOErr on error or if the end of stream is reached
   * before one byte can be read.  This method differs from {@link read | read}
   * in that it will throw IOErr on end of stream rather than
   * return null.
   */
  readU1(): number;
  /**
   * Close the input stream.  This method is guaranteed to never
   * throw an IOErr.  Return true if the stream was closed
   * successfully or false if the stream was closed abnormally. 
   * Default implementation does nothing and returns true.
   */
  close(): boolean;
  /**
   * Return the number of bytes available on input stream without
   * blocking.  Return zero if no bytes available or it is
   * unknown. Throw IOErr on error.
   */
  avail(): number;
  /**
   * Read the next byte and return true if nonzero.  This method
   * may be paired with {@link OutStream.writeBool | OutStream.writeBool}.
   * Throw IOErr on error or if the end of stream is reached
   * before one byte can be read.
   */
  readBool(): boolean;
  /**
   * Read a serialized object from the stream according to the
   * Fantom [serialization format](https://fantom.org/doc/docLang/Serialization).
   * Throw IOErr or ParseErr on error.  This method may consume
   * bytes/chars past the end of the serialized object (we may
   * want to add a "full stop" token at some point to support
   * compound object streams).
   * 
   * The options may be used to specify additional decoding
   * logic:
   * - "makeArgs": Obj[] arguments to pass to the root object's
   *   make constructor via `Type.make`
   */
  readObj(options?: Map<string, JsObj> | null): JsObj | null;
  /**
   * Peek at the next char to be read without actually consuming
   * it.  Peek has the same semantics as a readChar/unreadChar.
   * Return null if at end of stream.
   */
  peekChar(): number | null;
  /**
   * Read a Str token from the input stream which is terminated
   * when the specified function `c` returns true.  The terminating
   * char is unread and will be the next char read once this
   * method returns.  Characters are read based on the currently
   * configured charset.
   * 
   * If `c` is null then the default implementation tokenizes up
   * until the next character which returns true for {@link Int.isSpace | Int.isSpace}.
   * 
   * The max parameter specifies the maximum number of Unicode
   * characters (not bytes) to read before truncating the line
   * and returning.  If max is null, then no boundary is enforced
   * except of course the end of the stream.
   * 
   * Return null if the end of stream has been reached.  Throw
   * IOErr if there is a problem reading the stream or an invalid
   * character encoding is encountered.
   */
  readStrToken(max?: number | null, c?: ((arg0: number) => boolean) | null): string | null;
  /**
   * Read the next line from the input stream as a Str based on
   * the configured charset.  A line is terminated by \n, \r\n,
   * \r, or EOF.  The Str returned never contains the trailing
   * newline.
   * 
   * The max parameter specifies the maximum number of Unicode
   * characters (not bytes) to read before truncating the line
   * and returning.  If max is null, then no boundary is enforced
   * except of course the end of the stream.
   * 
   * Return null if the end of stream has been reached.  Throw
   * IOErr if there is a problem reading the stream or an invalid
   * character encoding is encountered.
   */
  readLine(max?: number | null): string | null;
  /**
   * Peek at the next byte to be read without actually consuming
   * it.  Peek has the same semantics as a read/unread.  Return
   * null if at end of stream.
   */
  peek(): number | null;
  /**
   * Read the next n chars from the stream as a Str using the
   * current {@link charset | charset}.  Block until exactly n
   * chars have been read or throw IOErr if end of stream is
   * reached first.
   */
  readChars(n: number): string;
  /**
   * Read the entire stream into Str lines based on the current
   * encoding.  Call the specified function for each line read.
   * Each line is terminated by \n, \r\n, \r, or EOF using the
   * same semantics as {@link readLine | readLine} with the null
   * default max line length. The Str lines themselves do not
   * contain a trailing newline. Empty lines are returned as the
   * empty Str "".  This InStream is guaranteed to be closed upon
   * return.
   */
  eachLine(f: ((arg0: string) => void)): void;
  /**
   * Read between 0 and 64 bits from the input stream.  Bits
   * which are partial bytes are consumed from the input stream
   * one byte at a time.  Throw IOErr on error or if end of
   * stream is reached before given number of bits can be read.
   */
  readBits(num: number): number;
}

/**
 * UnknownTypeErr indicates an attempt to access a non-existent
 * type.
 */
export class UnknownTypeErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): UnknownTypeErr;
}

/**
 * Locale models a cultural language and region/country. See [docLang::Localization](https://fantom.org/doc/docLang/Localization)
 * for details.
 * 
 * Also see {@link Env.locale | Env.locale} and {@link Pod.locale | Pod.locale}.
 */
export class Locale extends Obj {
  static type$: Type
  /**
   * Constant for the English Locale "en"
   */
  static en(): Locale;
  /**
   * Return string representation:
   * ```
   * <locale>  := <lang> ["-" <country>]
   * <lang>    := lowercase ISO 636 two letter code
   * <country> := uppercase ISO 3166 two letter code
   * ```
   */
  toStr(): string;
  /**
   * Get the current thread's locale.
   */
  static cur(): Locale;
  /**
   * Get the country/region as an uppercase ISO 3166 two letter
   * code.  Return null if the country is unspecified.
   */
  country(): string | null;
  /**
   * Run the specified function using this locale as the actor's
   * current locale.  This method guarantees that upon return the
   * actor's current locale remains unchanged.
   */
  use(func: ((arg0: this) => void)): this;
  /**
   * Parse a locale according to the {@link toStr | toStr} format.
   * If invalid format and checked is false return null,
   * otherwise throw ParseErr.
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): Locale;
  /**
   * Equality is based on the normalized toStr format.
   */
  equals(obj: JsObj | null): boolean;
  /**
   * Set the current thread's locale. Throw NullErr if null is
   * passed.
   */
  static setCur(locale: Locale): void;
  /**
   * Get the language as a lowercase ISO 639 two letter code.
   */
  lang(): string;
  /**
   * Compute hash code based on normalized toStr format.
   */
  hash(): number;
}

/**
 * Unsafe wraps a mutable object as an immutable reference.
 */
export class Unsafe extends Obj {
  static type$: Type
  /**
   * Get the wrapped object.
   */
  val(): JsObj | null;
  /**
   * Wrap specified object.
   */
  static make(val: JsObj | null, ...args: unknown[]): Unsafe;
}

/**
 * Process manages spawning external OS processes.
 */
export class Process extends Obj {
  static type$: Type
  /**
   * The output stream used to sink the process stderr. Default
   * is to send to {@link Env.err | Env.err}.  If set to null,
   * then output is silently consumed like /dev/null.  Note this
   * field is ignored if {@link mergeErr | mergeErr} is set true,
   * in which case stderr goes to the stream configured via `out`.
   */
  err(): OutStream | null;
  err(it: OutStream | null): void;
  /**
   * The input stream used to source the process stdin. If null,
   * then the new process will block if it attempts to read
   * stdin.  Default is null.
   */
  in(): InStream | null;
  in(it: InStream | null): void;
  /**
   * Working directory of process.
   */
  dir(): File | null;
  dir(it: File | null): void;
  /**
   * Command argument list used to launch process. The first item
   * is the executable itself, then rest are the parameters.
   */
  command(): List<string>;
  command(it: List<string>): void;
  /**
   * The output stream used to sink the process stdout. Default
   * is to send to {@link Env.out | Env.out}.  If set to null,
   * then output is silently consumed like /dev/null.
   */
  out(): OutStream | null;
  out(it: OutStream | null): void;
  /**
   * If true, then stderr is redirected to the output stream
   * configured via the `out` field, and the `err` field is ignored. 
   * The default is true.
   */
  mergeErr(): boolean;
  mergeErr(it: boolean): void;
  /**
   * Spawn this process.  See {@link join | join} to wait until
   * the process finishes and to get the exit code.  Return this.
   */
  run(): this;
  /**
   * Environment variables to pass to new process as a mutable
   * map of string key/value pairs.  This map is initialized with
   * the current process environment.
   */
  env(): Map<string, string>;
  /**
   * Kill this process.  Returns this.
   */
  kill(): this;
  /**
   * Wait for this process to exit and return the exit code. This
   * method may only be called once after `run`.
   */
  join(): number;
  /**
   * Construct a Process instance used to launch an external OS
   * process with the specified command arguments. The first item
   * in the `cmd` list is the executable itself, then rest are the
   * parameters.
   */
  static make(cmd?: List<string>, dir?: File | null, ...args: unknown[]): Process;
}

/**
 * Unit models a unit of measurement.  Units are represented
 * as:
 * - ids: each unit has one or more unique identifiers for the
 *   unit within the VM.  Units are typically defined in the unit
 *   database "etc/sys/units.txt" or can be via by the {@link define | define}
 *   method. Every id assigned to a unit must be unique within
 *   the VM.
 * - name: the first identifier in the ids list is called the *name*
 *   and should be a descriptive summary of the unit using words
 *   separated by underbar such as "miles_per_hour".
 * - symbol: the last identifier in the ids list should be the
 *   abbreviated symbol; for example "kilogram" has the symbol
 *   "kg". In units with only one id, the symbol is the same as
 *   the name. Units with exponents should use Unicode
 *   superscript chars, not ASCII digits.
 * - dimension: defines the ratio of the seven SI base units: m,
 *   kg, sec, A, K, mol, and cd
 * - scale/factor: defines the normalization equations for unit
 *   conversion
 * 
 * A unit identifier is limited to the following characters:
 * - any Unicode char over 128
 * - ASCII letters `a` - `z` and `A` - `Z`
 * - underbar `_`
 * - division sign `/`
 * - percent sign `%`
 * - dollar sign `$`
 * 
 * Units with equal dimensions are considered to measure the
 * same physical quantity.  This is not always true, but good
 * enough for practice. Conversions with the `convertTo` method
 * are expressed with the following equations:
 * ```
 * unit       = dimension * scale + offset
 * toNormal   = scalar * scale + offset
 * fromNormal = (scalar - offset) / scale
 * toUnit     = fromUnit.fromNormal( toUnit.toNormal(sclar) )
 * ```
 * 
 * As a simple, pragmatic solution for modeling Units, there
 * are some units which don't fit this model including
 * logarithm and angular units. Units which don't cleanly fit
 * this model should be represented as dimensionless (all
 * ratios set to zero).
 * 
 * Fantom's model for units of measurement and the unit
 * database are derived from the OASIS oBIX specification.
 */
export class Unit extends Obj {
  static type$: Type
  /**
   * Return the abbreviated symbol for this unit. This is always
   * the last item in {@link ids | ids}.
   */
  symbol(): string;
  /**
   * Ampere (electric current) component of the unit dimension.
   */
  A(): number;
  /**
   * Match the product of this and b against current database
   * definitions. If an unambiguous match cannot be made then
   * throw Err.
   */
  mult(that: Unit): Unit;
  /**
   * List the quantity names used to organize the unit database
   * in "etc/sys/units.txt".  Quantities are merely a convenient
   * mechanism to organize the unit database - there is no
   * guarantee that they include all current VM definitions.
   */
  static quantities(): List<string>;
  /**
   * Return the scale factor used to convert this unit "from
   * normal". For example the scale factor for kilometer is 1000
   * because it is defined as a 1000 meters where meter is the
   * normalized unit for length.  See class header for
   * normalization and conversion equations. The scale factor for
   * the normalized unit is always one.
   */
  scale(): number;
  /**
   * Return the string format of the dimension portion of {@link definition | definition}
   */
  dim(): string;
  /**
   * Kelvin (thermodynamic temperature) component of the unit
   * dimension.
   */
  K(): number;
  /**
   * Mole (amount of substance) component of the unit dimension.
   */
  mol(): number;
  /**
   * Second (time) component of the unit dimension.
   */
  sec(): number;
  /**
   * Match quotient of this divided by b against current database
   * definitions. If an unambiguous match cannot be made then
   * throw Err.
   */
  div(b: Unit): Unit;
  /**
   * Define a new Unit definition in the VM's unit database using
   * the following string format:
   * ```
   * unit   := <ids> [";" <dim> [";" <scale> [";" <offset>]]]
   * names  := <ids> ("," <id>)*
   * id     := <idChar>*
   * idChar := 'a'-'z' | 'A'-'Z' | '_' | '%' | '/' | any char > 128
   * dim    := <ratio> ["*" <ratio>]*   // no whitespace allowed
   * ratio  := <base> <exp>
   * base   := "kg" | "m" | "sec" | "K" | "A" | "mol" | "cd"
   * exp    := <int>
   * scale  := <float>
   * offset := <float>
   * ```
   * 
   * If the format is incorrect or any identifiers are already
   * defined then throw an exception.
   */
  static define(s: string): Unit;
  /**
   * Return string format as specified by {@link define | define}.
   */
  definition(): string;
  /**
   * Kilogram (mass) component of the unit dimension.
   */
  kg(): number;
  static make(...args: unknown[]): Unit;
  /**
   * Return {@link symbol | symbol}.
   */
  toStr(): string;
  /**
   * Candela (luminous intensity) component of the unit
   * dimension.
   */
  cd(): number;
  /**
   * Get the units organized under a specific quantity name in
   * the unit database "etc/sys/units.txt".  Quantities are
   * merely a convenient mechanism to organize the unit database
   * - there is no guarantee that they include all current VM
   * definitions.
   */
  static quantity(quantity: string): List<Unit>;
  /**
   * Return the offset factor used to convert this unit "from
   * normal". See class header for normalization and conversion
   * equations.  Offset is used most commonly with temperature
   * units.  The offset for normalized unit is always zero.
   */
  offset(): number;
  /**
   * Convert a scalar value from this unit to the given unit.  If
   * the units do not have the same dimension then throw Err. For
   * example, to convert 3km to meters:
   * ```
   * m  := Unit("meter")
   * km := Unit("kilometer")
   * km.convertTo(3f, m)  =>  3000f
   * ```
   */
  convertTo(scalar: number, unit: Unit): number;
  /**
   * List all the units currently defined in the VM.  Any units
   * declared in "etc/sys/units.txt" are implicitly defined.
   */
  static list(): List<Unit>;
  /**
   * Meter (length) component of the unit dimension.
   */
  m(): number;
  /**
   * Find a unit by one of its identifiers if it has been defined
   * in this VM.  If the unit isn't defined yet and checked is
   * false then return null, otherwise throw Err.  Any units
   * declared in "etc/sys/units.txt" are implicitly defined.
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): Unit;
  /**
   * Two units are equal if they have reference equality because
   * all units are interned during definition.
   */
  equals(that: JsObj | null): boolean;
  /**
   * Return the primary name identifier of this unit. This is
   * always the first item in {@link ids | ids}.
   */
  name(): string;
  /**
   * Return the list of programmatic identifiers for this unit.
   * The first item is always {@link name | name} and the last is
   * always {@link symbol | symbol}.
   */
  ids(): List<string>;
  /**
   * Return `toStr.hash`.
   */
  hash(): number;
}

/**
 * Regex represents a regular expression.
 */
export class Regex extends Obj {
  static type$: Type
  /**
   * Default value is Regex("").
   */
  static defVal(): Regex;
  /**
   * Return the regular expression pattern string.
   */
  toStr(): string;
  /**
   * Make a Regex which will match a glob pattern:
   * - "?": match one unknown char (maps to "." in regex)
   * - "*": match zero or more unknown char (maps to ".*" in regex)
   * - any other character is matched exactly
   */
  static glob(pattern: string): Regex;
  /**
   * Return flags string
   */
  flags(): string;
  /**
   * Return a `RegexMatcher` instance to use for matching
   * operations against the specified string.
   */
  matcher(s: string): RegexMatcher;
  /**
   * Convenience for {@link RegexMatcher.matches | matcher(s).matches}.
   */
  matches(s: string): boolean;
  /**
   * Make a Regex that matches the given string exactly. All
   * non-alpha numeric characters are escaped.
   */
  static quote(str: string): Regex;
  /**
   * Split the specified string around matches of this pattern.
   * The `limit` parameter specifies how many times to apply the
   * pattern:
   * - If `limit` is greater than zero, the pattern is applied at
   *   most `limit-1` times and any remaining input will be returned
   *   as the list's last item.
   * - If `limit` is less than zero, then the pattern is matched as
   *   many times as possible.
   * - If `limit` is zero, then the pattern is matched as many times
   *   as possible, but trailing empty strings are discarded.
   */
  split(s: string, limit?: number): List<string>;
  /**
   * Compile a regular expression pattern string.  Flags is a
   * string of ASCII chars.  In JavaScript the flags are passed
   * directly to RegExp. In Java the flags are matched against
   * known constants or ignored. The following cross-platform
   * flags are supported:
   * - `i`: case insensitive
   * - `m`: multi-line support for start/end matching
   * - `s`: dot all to allow "." to match newlines
   */
  static fromStr(pattern: string, flags?: string, ...args: unknown[]): Regex;
  /**
   * Equality is based on pattern string and flags.
   */
  equals(obj: JsObj | null): boolean;
  /**
   * Return `toStr.hash`.
   */
  hash(): number;
}

/**
 * TimeoutErr indicates that a blocking operation timed out
 * before normal completion.
 */
export class TimeoutErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): TimeoutErr;
}

/**
 * Test is the base for Fantom unit tests.
 * 
 * See [docTools::Fant](https://fantom.org/doc/docTools/Fant).
 */
export class Test extends Obj {
  static type$: Type
  /**
   * Get the current test method being executed or throw Err if
   * not currently running a test.  This method is available
   * during both {@link setup | setup} and {@link teardown | teardown}
   * as well as during the test itself.
   */
  curTestMethod(): Method;
  /**
   * Verify that the function throws an Err of the exact same
   * type as errType (compare using === operator). If the errType
   * parameter is null, then this method tests only that an
   * exception is thrown, not its type.
   * 
   * Example:
   * ```
   * verifyErr(ParseErr#) { x := Int.fromStr("@#!") }
   * ```
   */
  verifyErr(errType: Type | null, c: ((arg0: Test) => void)): void;
  /**
   * Verify that a != b, otherwise throw a test failure
   * exception. If msg is non-null, include it in failure
   * exception.
   */
  verifyNotEq(a: JsObj | null, b: JsObj | null, msg?: string | null): void;
  /**
   * Verify that cond is true, otherwise throw a test failure
   * exception.  If msg is non-null, include it in a failure
   * exception.  Identical to {@link verify | verify}.
   */
  verifyTrue(cond: boolean, msg?: string | null): void;
  /**
   * Verify that a is null, otherwise throw a test failure
   * exception.  If msg is non-null, include it in a failure
   * exception.
   */
  verifyNull(a: JsObj | null, msg?: string | null): void;
  /**
   * Verify that a === b, otherwise throw a test failure
   * exception. If msg is non-null, include it in failure
   * exception.
   */
  verifySame(a: JsObj | null, b: JsObj | null, msg?: string | null): void;
  /**
   * Verify that the function throws an Err. The Err must be the
   * exact same type as errType and the contained msg must be the
   * same as errMsg.
   * 
   * Example:
   * ```
   * verifyErrMsg(ParseErr#, "Invalid Int: 'ABC'")
   * {
   *   x := Int.fromStr("ABC")
   * }
   * ```
   */
  verifyErrMsg(errType: Type, errMsg: string, c: ((arg0: Test) => void)): void;
  /**
   * Verify that cond is true, otherwise throw a test failure
   * exception.  If msg is non-null, include it in a failure
   * exception. Identical to {@link verifyTrue | verifyTrue}.
   */
  verify(cond: boolean, msg?: string | null): void;
  /**
   * Teardown is called after running every test method.
   */
  teardown(): void;
  /**
   * Verify that cond is false, otherwise throw a test failure
   * exception.  If msg is non-null, include it in a failure
   * exception.
   */
  verifyFalse(cond: boolean, msg?: string | null): void;
  /**
   * Verify that a !== b, otherwise throw a test failure
   * exception. If msg is non-null, include it in failure
   * exception.
   */
  verifyNotSame(a: JsObj | null, b: JsObj | null, msg?: string | null): void;
  /**
   * Verify that a == b, otherwise throw a test failure
   * exception. If both a and b are nonnull, then this method
   * also ensures that a.hash == b.hash, because any two objects
   * which return true for equals() must also return the same
   * hash code.  If msg is non-null, include it in failure
   * exception.
   */
  verifyEq(a: JsObj | null, b: JsObj | null, msg?: string | null): void;
  /**
   * Throw a test failure exception.  If msg is non-null, include
   * it in the failure exception.
   */
  fail(msg?: string | null): void;
  /**
   * Setup is called before running each test method.
   */
  setup(): void;
  /**
   * Return a temporary test directory which may used as a
   * scratch directory.  This directory is guaranteed to be
   * created and empty the first time this method is called for a
   * given test run.  The test directory is
   * "{Env.cur.tempDir}/test/".
   */
  tempDir(): File;
  /**
   * Verify that a is not null, otherwise throw a test failure
   * exception.  If msg is non-null, include it in a failure
   * exception.
   */
  verifyNotNull(a: JsObj | null, msg?: string | null): void;
  /**
   * Verify that `Type.of(obj)` equals the given type.
   */
  verifyType(obj: JsObj, t: Type): void;
}

/**
 * Version is defined as a list of decimal digits separated by
 * the dot.  Convention for Fantom pods is a four part version
 * format of `major.minor.build.patch`.
 */
export class Version extends Obj {
  static type$: Type
  /**
   * Default value is "0".
   */
  static defVal(): Version;
  /**
   * The string format is equivalent to segments.join(".")
   */
  toStr(): string;
  /**
   * Compare from from most significant segment to least
   * significant segment.
   * 
   * Examples:
   * ```
   * 1.6 > 1.4
   * 2.0 > 1.9
   * 1.2.3 > 1.2
   * 1.11 > 1.9.3
   * ```
   */
  compare(obj: JsObj): number;
  /**
   * Get the second segment which represents the minor version.
   * Return null if version has less than two segments.
   */
  minor(): number | null;
  /**
   * Get a readonly list of the integer segments.
   */
  segments(): List<number>;
  /**
   * Get the fourth segment which represents the patch number.
   * Return null if version has less than four segments.
   */
  patch(): number | null;
  /**
   * Parse a string representation into a Version. If invalid
   * format and checked is false return null, otherwise throw
   * ParseErr.
   */
  static fromStr(version: string, checked?: boolean, ...args: unknown[]): Version;
  /**
   * Get the first, most significant segment which represents the
   * major version.
   */
  major(): number;
  /**
   * Get the third segment which represents the build number.
   * Return null if version has less than three segments.
   */
  build(): number | null;
  /**
   * Return true if equal segments.
   */
  equals(obj: JsObj | null): boolean;
  /**
   * Construct with list of integer segments. Throw ArgErr if
   * segments is empty or contains negative numbers.
   */
  static make(segments: List<number>, ...args: unknown[]): Version;
  /**
   * Return toStr.hash
   */
  hash(): number;
}

/**
 * This represents a method return type which is always [this
 * type](https://fantom.org/doc/docLang/Methods#thisReturns).
 */
export class This extends Obj {
  static type$: Type
}

/**
 * List represents a linear sequence of Objects indexed by an
 * Int.
 * 
 * See [examples](examples::sys-lists).
 */
export class List<V = unknown> extends Obj implements Iterable<V> {
  static type$: Type
  /**
   * The number of items in the list.  Getting size is readonly
   * safe, setting size throws ReadonlyErr if readonly.
   * 
   * If the size is set greater than the current size then the
   * list is automatically grown to be a sparse list with new
   * items defaulting to null.  However if this is a non-nullable
   * list, then growing a list will throw ArgErr.
   * 
   * If the size is set less than the current size then any items
   * with indices past the new size are automatically removed. 
   * Changing size automatically allocates new storage so that
   * capacity exactly matches the new size.
   */
  size(): number;
  size(it: number): void;
  /**
   * The number of items this list can hold without allocating
   * more memory. Capacity is always greater or equal to size. 
   * If adding a large number of items, it may be more efficient
   * to manually set capacity. See the {@link trim | trim} method
   * to automatically set capacity to size.  Throw ArgErr if
   * attempting to set capacity less than size.  Getting capacity
   * is readonly safe, setting capacity throws ReadonlyErr if
   * readonly.
   */
  capacity(): number;
  capacity(it: number): void;
  /** List Iterator */
  [Symbol.iterator](): Iterator<V>;
  /** Constructor for of[] with optional initial values */
  static make(of$: Type, ...args: unknown[]): List;
  /**
   * Return integer index just like {@link index | List.index}
   * except use `===` same operator instead of the `==` equals
   * operator.
   */
  indexSame(item: unknown, offset?: number): number | null;
  /**
   * Call {@link add | add} if item is non-null otherwise do
   * nothing.  Return this.
   */
  addNotNull(item: unknown | null): List<V>;
  /**
   * Get the item at the specified index, but if index is out of
   * range, then return `def` parameter.  A negative index may be
   * used according to the same semantics as {@link get | get}. 
   * This method is readonly safe.
   */
  getSafe(index: number, def?: unknown | null): unknown | null;
  /**
   * Constructor for Obj?[] with initial capacity.
   */
  static makeObj(capacity: number, ...args: unknown[]): List;
  /**
   * Reverse index lookup.  This method works just like {@link index | index}
   * except that it searches backward from the starting offset.
   */
  indexr(item: unknown, offset?: number): number | null;
  /**
   * Return a new list containing the items for which c returns
   * true.  If c returns false for every item, then return an
   * empty list.  The inverse of this method is exclude().  This
   * method is readonly safe.
   * 
   * Example:
   * ```
   * list := [0, 1, 2, 3, 4]
   * list.findAll |Int v->Bool| { return v%2==0 } => [0, 2, 4]
   * ```
   */
  findAll(c: unknown): List<V>;
  /**
   * Return a new list which recursively flattens any list items
   * into a one-dimensional result.  This method is readonly
   * safe.
   * 
   * Examples:
   * ```
   * [1,2,3].flatten        =>  [1,2,3]
   * [[1,2],[3]].flatten    =>  [1,2,3]
   * [1,[2,[3]],4].flatten  =>  [1,2,3,4]
   * ```
   */
  flatten(): List<JsObj | null>;
  /**
   * Remove every item in this list which is found in the `toRemove`
   * list using same semantics as {@link remove | remove} (compare
   * for equality via the == operator). If any value is not
   * found, it is ignored.  Return this. Throw ReadonlyErr if
   * readonly.
   */
  removeAll(list: List<V>): List<V>;
  /**
   * Trim the capacity such that the underlying storage is
   * optimized for the current size.  Return this.  Throw
   * ReadonlyErr if readonly.
   */
  trim(): List<V>;
  /**
   * Return a sub-list based on the specified range.  Negative
   * indexes may be used to access from the end of the list. 
   * This method is accessed via the `[]` operator.  This method is
   * readonly safe. Throw IndexErr if range illegal.
   * 
   * Examples:
   * ```
   * list := [0, 1, 2, 3]
   * list[0..2]   => [0, 1, 2]
   * list[3..3]   => [3]
   * list[-2..-1] => [2, 3]
   * list[0..<2]  => [0, 1]
   * list[1..-2]  => [1, 2]
   * ```
   */
  getRange(range: Range): List<V>;
  /**
   * Return the first item in the list for which c returns true.
   * If c returns false for every item, then return null.  This
   * method is readonly safe.
   * 
   * Example:
   * ```
   * list := [0, 1, 2, 3, 4]
   * list.find |Int v->Bool| { return v.toStr == "3" } => 3
   * list.find |Int v->Bool| { return v.toStr == "7" } => null
   * ```
   */
  find(c: unknown): unknown | null;
  /**
   * Return a new list containing all the items which are an
   * instance of the specified type such that item.type.fits(t)
   * is true.  Any null items are automatically excluded.  If
   * none of the items is an instance of the specified type, then
   * an empty list is returned.  The returned list will be a list
   * of t.  This method is readonly safe.
   * 
   * Example:
   * ```
   * list := ["a", 3, "foo", 5sec, null]
   * list.findType(Str#) => Str["a", "foo"]
   * ```
   */
  findType(t: Type): List<V>;
  /**
   * Return a new list which is the intersection of this list and
   * the given list.  The intersection is defined as the unique
   * items which are in *both* lists.  The new list will be ordered
   * according to this list's order.  The new list is guaranteed
   * to be unique with no duplicate values.  Equality is
   * determined using hash() and the == operator (shortcut for
   * equals method).  This method is readonly safe.
   * 
   * Example:
   * ```
   * [0, 1, 2, 3].intersection([5, 3, 1]) => [1, 3]
   * [0, null, 2].intersection([null, 0, 1, 2, 3]) => [0, null, 2]
   * ```
   */
  intersection(that: List<V>): List<V>;
  /**
   * Return a new list containing the items for which c returns
   * false.  If c returns true for every item, then return an
   * empty list.  The inverse of this method is findAll().  This
   * method is readonly safe.
   * 
   * Example:
   * ```
   * list := [0, 1, 2, 3, 4]
   * list.exclude |Int v->Bool| { return v%2==0 } => [1, 3]
   * ```
   */
  exclude(c: unknown): List<V>;
  /**
   * Return a string by concatenating each item's toStr result
   * using the specified separator string.  If c is non-null then
   * it is used to format each item into a string, otherwise
   * Obj.toStr is used.  This method is readonly safe.
   * 
   * Example:
   * ```
   * ["a", "b", "c"].join => "abc"
   * ["a", "b", "c"].join("-") => "a-b-c"
   * ["a", "b", "c"].join("-") |Str s->Str| { return "($s)" } => "(a)-(b)-(c)"
   * ```
   */
  join(separator?: string, c?: unknown | null): string;
  /**
   * Reverse sort - perform an in-place reverse sort on this
   * list.  If a method is provided it implements the comparator
   * returning -1, 0, or 1.  If the comparator method is null
   * then sorting is based on the value's <=> operator (shortcut
   * for `compare` method).  Return this.  Throw ReadonlyErr if
   * readonly.
   * 
   * Example:
   * ```
   * [3, 2, 4, 1].sortr =>  [4, 3, 2, 1]
   * ```
   */
  sortr(c?: unknown | null): List<V>;
  /**
   * Return a string representation of the list.  This method is
   * readonly safe.
   */
  toStr(): string;
  /**
   * Add the specified item to the end of the list.  The item
   * will have an index of size.  Size is incremented by 1. 
   * Return this.  Throw ReadonlyErr if readonly.
   */
  add(item: unknown): List<V>;
  /**
   * Return true if c returns true for all of the items in the
   * list.  If the list is empty, return true.  This method is
   * readonly safe.
   * 
   * Example:
   * ```
   * list := ["ant", "bear"]
   * list.all |Str v->Bool| { return v.size >= 3 } => true
   * list.all |Str v->Bool| { return v.size >= 4 } => false
   * ```
   */
  all(c: unknown): boolean;
  /**
   * Reduce is used to iterate through every item in the list to
   * reduce the list into a single value called the reduction.
   * The initial value of the reduction is passed in as the init
   * parameter, then passed back to the closure along with each
   * item.  This method is readonly safe.
   * 
   * Example:
   * ```
   * list := [1, 2, 3]
   * list.reduce(0) |Obj r, Int v->Obj| { return (Int)r + v } => 6
   * ```
   */
  reduce(init: JsObj | null, c: unknown): JsObj | null;
  /**
   * Return the item at size-1, or if empty return null. This
   * method is readonly safe.
   */
  last(): unknown | null;
  /**
   * Call {@link set | set} if item is non-null otherwise do
   * nothing.  Return this.
   */
  setNotNull(index: number, item: unknown | null): List<V>;
  /**
   * Find an element in the list using a binary search algorithm.
   * The specified comparator function returns a negative
   * integer, zero, or a positive integer if the desired object
   * is less than, equal to, or greater than specified item. The
   * list must be sorted in ascending order according to the
   * specified comparator function. If the key is not found, then
   * return a negative value which is `-(insertation point) - 1`.
   * 
   * Example:
   * ```
   * [1,3,5,7,9].binaryFind |Int item->Int| { return 4 <=> item }
   *             => -3
   * [1,3,5,7,9].binaryFind |Int item->Int| { return 3 <=> item }
   *             => 1
   * ```
   */
  binaryFind(c: unknown): number;
  /**
   * Swap the items at the two specified indexes.  Negative
   * indexes may be used to access an index from the end of the
   * list.  Return this. Throw ReadonlyErr if readonly.
   */
  swap(indexA: number, indexB: number): List<V>;
  /**
   * Get this list as a Fantom expression suitable for code
   * generation. The individual items must all respond to the `toCode`
   * method.
   */
  toCode(): string;
  /**
   * Reverse {@link eachWhile | eachWhile}.  Iterate every item in
   * the list starting with size-1 down to 0.  If the function
   * returns non-null, then break the iteration and return the
   * resulting object.  Return null if the function returns null
   * for every item.  This method is readonly safe.
   */
  eachrWhile(c: unknown): JsObj | null;
  /**
   * Return if this list contains any one of the items in the
   * specified list. Equality is determined by {@link Obj.equals | Obj.equals}.
   * This method is readonly safe.
   */
  containsAny(list: List<V>): boolean;
  /**
   * Return the integer index of the specified item using the `==`
   * operator (shortcut for equals method) to check for equality.
   * Use {@link indexSame | indexSame} to find with `===` operator.
   * The search starts at the specified offset and returns the
   * first match.  The offset may be negative to access from end
   * of list.  Throw IndexErr if offset is out of range.  If the
   * item is not found return null.  This method is readonly
   * safe.
   */
  index(item: unknown, offset?: number): number | null;
  /**
   * Perform an in-place sort on this list.  If a method is
   * provided it implements the comparator returning -1, 0, or 1.
   * If the comparator method is null then sorting is based on
   * the value's <=> operator (shortcut for `compare` method). 
   * Return this. Throw ReadonlyErr if readonly.
   * 
   * Example:
   * ```
   * s := ["candy", "ate", "he"]
   * 
   * s.sort
   * // s now evaluates to [ate, candy, he]
   * 
   * s.sort |Str a, Str b->Int| { return a.size <=> b.size }
   * // s now evaluates to ["he", "ate", "candy"]
   * ```
   */
  sort(c?: unknown | null): List<V>;
  /**
   * Append a value to the end of the list the given number of
   * times. Return this. Throw ReadonlyErr if readonly.
   * 
   * Example:
   * ```
   * Int[,].fill(0, 3)  =>  [0, 0, 0]
   * ```
   */
  fill(val: unknown, times: number): List<V>;
  /**
   * Reverse each - call the specified function for every item in
   * the list starting with index size-1 and decrementing down to
   * 0.  This method is readonly safe.
   * 
   * Example:
   * ```
   * ["a", "b", "c"].eachr |Str s| { echo(s) }
   * => c
   *    b
   *    a
   * ```
   */
  eachr(c: unknown): void;
  /**
   * Add the specified item to the end of the list.  Return this.
   * This method has the same semantics as add(item).  Throw
   * ReadonlyErr if readonly.
   */
  push(item: unknown): List<V>;
  /**
   * Call the specified function for every item in the list
   * starting with index 0 and incrementing up to size-1.  This
   * method is readonly safe.
   * 
   * Example:
   * ```
   * ["a", "b", "c"].each |Str s| { echo(s) }
   * => a
   *    b
   *    c
   * ```
   */
  each(c: unknown): void;
  /**
   * Call the specified function for every non-null item in the
   * list starting with index 0 and incrementing up to size-1. 
   * This method is readonly safe.
   */
  eachNotNull(c: unknown): void;
  /**
   * Convenience for {@link map | map} and {@link findNotNull | findNotNull}.
   * Each item is mapped by the given function and if null is
   * returned it is excluded from the result.  The resulting type
   * is based on the return type of c but non-nullable.  This
   * method is readonly safe.
   * 
   * Example:
   * ```
   * list := [3, 4, 5]
   * list.mapIfNotNull |Int v->Int?| { v.isOdd ? 10+v : null } => [13, 15]
   * ```
   */
  mapNotNull(c: unknown): List<JsObj>;
  /**
   * This is a combination of {@link map | map} and {@link flatten | flatten}.
   * Each item in this list is mapped to zero or more new items
   * by the given function and the results are returned in a
   * single flattened list.  Note unlike {@link flatten | flatten}
   * only one level of flattening is performed. The new list is
   * typed based on the return type of c.  This method is
   * readonly safe.
   * 
   * Example:
   * ```
   * list := ["a", "b"]
   * list.flatMap |v->Str[]| { [v, v.upper] } => ["a", "A", "b", "B"]
   * ```
   */
  flatMap(c: unknown): List<JsObj | null>;
  /**
   * Return if this list contains the specified item. Equality is
   * determined by {@link Obj.equals | Obj.equals}.  This method
   * is readonly safe.
   */
  contains(item: unknown): boolean;
  /**
   * Return a new list with all null items removed. The returned
   * list will be based on this list's type but non-nullable.
   * This method is readonly safe.
   * 
   * Example:
   * ```
   * list := Int?[1, null, 2, null, 3]
   * list.findNotNull => Int[1, 2, 3]
   * ```
   */
  findNotNull(): List<V>;
  /**
   * Returns a new list with all duplicate items removed such
   * that the resulting list is a proper set.  Duplicates are
   * detected using hash() and the == operator (shortcut for
   * equals method).  This method is readonly safe.
   * 
   * Example:
   * ```
   * ["a", "a", "b", "c", "b", "b"].unique => ["a", "b", "c"]
   * ```
   */
  unique(): List<V>;
  /**
   * Remove the object at the specified index.  A negative index
   * may be used to access an index from the end of the list. 
   * Size is decremented by 1.  Return the item removed.  Throw
   * IndexErr if index is out of range.  Throw ReadonlyErr if
   * readonly.
   */
  removeAt(index: number): unknown;
  /**
   * Insert all the items in the specified list into this list at
   * the specified index.  A negative index may be used to access
   * an index from the end of the list.  Size is incremented by
   * list.size.  Return this.  Throw IndexErr if index is out of
   * range.  Throw ReadonlyErr if readonly.
   */
  insertAll(index: number, list: List<V>): List<V>;
  /**
   * Get a readonly List instance with the same contents as this
   * List (although the items may be mutable themselves).  If
   * this List is already readonly, then return this.  Only
   * methods documented as "readonly safe" may be used safely
   * with a readonly List, all others will throw ReadonlyErr. 
   * This method is readonly safe.  See {@link Obj.isImmutable | Obj.isImmutable}
   * and {@link Obj.toImmutable | Obj.toImmutable} for deep
   * immutability.
   */
  ro(): Readonly<List<V>>;
  /**
   * Return platform dependent hashcode based on a hash of the
   * items of the list.
   */
  hash(): number;
  /**
   * Iterate the list using the specified range.   Negative
   * indexes may be used to access from the end of the list. 
   * This method is readonly safe.  Throw IndexErr if range is
   * invalid.
   */
  eachRange(r: Range, c: unknown): void;
  /**
   * Group by into an existing map.  This method shares the same
   * semantics as {@link groupBy | groupBy} except it adds into
   * the given map.
   */
  groupByInto(map: unknown, c: unknown): unknown;
  /**
   * Get a read-write, mutable List instance with the same
   * contents as this List.  If this List is already read-write,
   * then return this. This method is readonly safe.
   */
  rw(): List<V>;
  /**
   * Insert the item at the specified index.  A negative index
   * may be used to access an index from the end of the list. 
   * Size is incremented by 1.  Return this.  Throw IndexErr if
   * index is out of range.  Throw ReadonlyErr if readonly.
   */
  insert(index: number, item: unknown): List<V>;
  /**
   * Group items into buckets keyed by the given function. The
   * result is a map of lists where the map keys are generated by
   * the given function.  The map values are the items which
   * share the same key.  The resulting map key type is
   * determined by the return type of c.
   * 
   * Example:
   * ```
   * // group by string size
   * list := ["ape", "bear", "cat", "deer"]
   * list.groupBy |s->Int| { s.size }  =>  [3:[ape, cat], 4:[bear, deer]]
   * ```
   */
  groupBy(c: unknown): unknown;
  /**
   * Search the list for the index of the specified key using a
   * binary search algorithm.  The list must be sorted in
   * ascending order according to the specified comparator
   * function.  If the list contains multiple matches for key, no
   * guarantee is made to which one is returned.  If the
   * comparator is null then it is assumed to be the `<=>` operator
   * (shortcut for the `compare` method).  If the key is not found,
   * then return a negative value which is `-(insertation point) -
   * 1`.
   * 
   * Example:
   * ```
   * [1,3,5,7,9].binarySearch(4)  => -3
   * [1,3,5,7,9].binarySearch(3)  => 1
   * ```
   */
  binarySearch(key: unknown, c?: unknown | null): number;
  /**
   * Remove the specified value from the list.  The value is
   * compared using the == operator (shortcut for equals method).
   * Use {@link removeSame | removeSame} to remove with the ===
   * operator.  Return the removed value and decrement size by 1.
   * If the value is not found, then return null. Throw
   * ReadonlyErr if readonly.
   */
  remove(item: unknown): unknown | null;
  /**
   * Remove the last item and return it, or return null if the
   * list is empty.  This method has the same semantics as `removeAt(-1)`,
   * with the exception that an empty list is handled.  Throw
   * ReadonlyErr if readonly.
   */
  pop(): unknown | null;
  /**
   * Return a random item from the list.  If the list is empty
   * return null.  This method is readonly safe.  Also see {@link Int.random | Int.random},
   * {@link Float.random | Float.random}, {@link Range.random | Range.random},
   * and {@link util.Random | util::Random}.
   */
  random(): unknown | null;
  /**
   * Return the minimum value of the list.  If c is provided,
   * then it implements the comparator returning -1, 0, or 1.  If
   * c is null then the <=> operator is used (shortcut for
   * compare method).  If the list is empty, return null.  This
   * method is readonly safe.
   * 
   * Example:
   * ```
   * list := ["albatross", "dog", "horse"]
   * list.min => "albatross"
   * list.min |Str a, Str b->Int| { return a.size <=> b.size } => "dog"
   * ```
   */
  min(c?: unknown | null): unknown | null;
  /**
   * Deprecated - use addNotNull
   */
  addIfNotNull(item: unknown | null): List<V>;
  /**
   * Return if this List is readonly.  A readonly List is
   * guaranteed to be immutable (although its items may be
   * mutable themselves).  Any attempt to  modify a readonly List
   * will result in ReadonlyErr.  Use {@link rw | rw} to get a
   * read-write List from a readonly List.  Methods documented as
   * "readonly safe" may be used safely with a readonly List.
   * This method is readonly safe.
   */
  isRO(): boolean;
  /**
   * Get the item Type of this List.
   * 
   * Examples:
   * ```
   * ["hi"].of    =>  Str#
   * [[2, 3]].of  =>  Int[]#
   * ```
   */
  of(): Type;
  /**
   * Get is used to return the item at the specified index.  A
   * negative index may be used to access an index from the end
   * of the list.  For example get(-1) is translated into
   * get(size()-1).  The get method is accessed via the []
   * shortcut operator.  Throw IndexErr if index is out of range.
   * This method is readonly safe.
   */
  get(index: number): unknown;
  /**
   * Remove a range of indices from this list.  Negative indexes
   * may be used to access from the end of the list.  Throw
   * ReadonlyErr if readonly.  Throw IndexErr if range illegal.
   * Return this (*not* the removed items).
   */
  removeRange(r: Range): List<V>;
  /**
   * Create a new list which is the result of calling c for every
   * item in this list.  The new list is typed based on the
   * return type of c.  This method is readonly safe.
   * 
   * Example:
   * ```
   * list := [3, 4, 5]
   * list.map |Int v->Int| { return v*2 } => [6, 8, 10]
   * ```
   */
  map(c: unknown): List<JsObj | null>;
  /**
   * Return if this List is read-write.  A read-write List is
   * mutable and may be modified.  Use {@link ro | ro} to get a
   * readonly List from a read-write List.  This method is
   * readonly safe.
   */
  isRW(): boolean;
  /**
   * Set is used to overwrite the item at the specified index.  A
   * negative index may be used to access an index from the end
   * of the list.  The set method is accessed via the []=
   * shortcut operator. If you wish to use List as a sparse array
   * and set values greater then size, then manually set size
   * larger.  Return this.  Throw IndexErr if index is out of
   * range.  Throw ReadonlyErr if readonly.
   */
  set(index: number, item: unknown): List<V>;
  /**
   * Return the maximum value of the list.  If c is provided,
   * then it implements the comparator returning -1, 0, or 1.  If
   * c is null then the <=> operator is used (shortcut for
   * compare method).  If the list is empty, return null.  This
   * method is readonly safe.
   * 
   * Example:
   * ```
   * list := ["albatross", "dog", "horse"]
   * list.max => "horse"
   * list.max |Str a, Str b->Int| { return a.size <=> b.size } => "albatross"
   * ```
   */
  max(c?: unknown | null): unknown | null;
  /**
   * Return if this list contains every item in the specified
   * list. Equality is determined by {@link Obj.equals | Obj.equals}.
   * This method is readonly safe.
   */
  containsAll(list: List<V>): boolean;
  /**
   * Return if size == 0.  This method is readonly safe.
   */
  isEmpty(): boolean;
  /**
   * Remove all items from the list and set size to 0.  Return
   * this. Throw ReadonlyErr if readonly.
   */
  clear(): List<V>;
  /**
   * Return a new list which is the union of this list and the
   * given list. The union is defined as the unique items which
   * are in *either* list. The resulting list is ordered first by
   * this list's order, and secondarily by that's order.  The new
   * list is guaranteed to be unique with no duplicate values. 
   * Equality is determined using hash() and the == operator
   * (shortcut for equals method).  This method is readonly safe.
   * 
   * Example:
   * ```
   * [1, 2].union([3, 2]) => [1, 2, 3]
   * ```
   */
  union(that: List<V>): List<V>;
  /**
   * Reverse the order of the items of this list in-place. 
   * Return this. Throw ReadonlyErr if readonly.
   * 
   * Example:
   * ```
   * [1, 2, 3, 4].reverse  =>  [4, 3, 2, 1]
   * ```
   */
  reverse(): List<V>;
  /**
   * Return true if c returns true for any of the items in the
   * list.  If the list is empty, return false.  This method is
   * readonly safe.
   * 
   * Example:
   * ```
   * list := ["ant", "bear"]
   * list.any |Str v->Bool| { return v.size >= 4 } => true
   * list.any |Str v->Bool| { return v.size >= 5 } => false
   * ```
   */
  any(c: unknown): boolean;
  /**
   * Return the item at size-1, or if empty return null. This
   * method has the same semantics as last().  This method is
   * readonly safe.
   */
  peek(): unknown | null;
  /**
   * Remove the item just like {@link remove | remove} except use
   * the === operator instead of the == equals operator.
   */
  removeSame(item: unknown): unknown | null;
  /**
   * Return the index of the first item in the list for which c
   * returns true.  If c returns false for every item, then
   * return null.  This method is readonly safe.
   * 
   * Example:
   * ```
   * list := [5, 6, 7]
   * list.findIndex |Int v->Bool| { return v.toStr == "7" } => 2
   * list.findIndex |Int v->Bool| { return v.toStr == "9" } => null
   * ```
   */
  findIndex(c: unknown): number | null;
  /**
   * Add all the items in the specified list to the end of this
   * list. Size is incremented by list.size.  Return this.  Throw
   * ReadonlyErr if readonly.
   */
  addAll(list: List<V>): List<V>;
  /**
   * Two Lists are equal if they have the same type, the same
   * number of items, and all the items at each index return true
   * for `equals`.
   * 
   * Examples:
   * ```
   * [2, 3] == [2, 3]     =>  true
   * [2, 3] == [3, 2]     =>  false
   * [2, 3] == Num[2, 3]  =>  false
   * Str[,] == [,]        =>  false
   * Str[,] == Str?[,]    =>  false
   * ```
   */
  equals(that: JsObj | null): boolean;
  /**
   * Return if this list contains the specified item. Equality is
   * determined by `===`.  This method is readonly safe.
   */
  containsSame(item: unknown): boolean;
  /**
   * Shuffle this list's items into a randomized order. Return
   * this.  Throw ReadonlyErr if readonly.
   */
  shuffle(): List<V>;
  /**
   * Iterate every item in the list starting with index 0 up to
   * size-1 until the function returns non-null.  If function
   * returns non-null, then break the iteration and return the
   * resulting object.  Return null if the function returns null
   * for every item.  This method is readonly safe.
   */
  eachWhile(c: unknown): JsObj | null;
  /**
   * Return the item at index 0, or if empty return null. This
   * method is readonly safe.
   */
  first(): unknown | null;
  /**
   * Create a shallow duplicate copy of this List.  The items
   * themselves are not duplicated.  The resulting list is always
   * read/write.  This method is readonly safe.
   */
  dup(): List<V>;
  /**
   * Find the given item, and move it to the given index.  All
   * the other items are shifted accordingly.  Negative indexes
   * may used to access an index from the end of the list.  If
   * the item is null or not found then this is a no op.  Return
   * this.  Throw ReadonlyErr if readonly.
   * 
   * Examples:
   * ```
   * [10, 11, 12].moveTo(11, 0)  =>  [11, 10, 12]
   * [10, 11, 12].moveTo(11, -1) =>  [10, 12, 11]
   * ```
   */
  moveTo(item: unknown | null, toIndex: number): List<V>;
}

/**
 * RegexMatcher is used in matching operations on a regular
 * expression.
 */
export class RegexMatcher extends Obj {
  static type$: Type
  /**
   * Return the start index of the given {@link group | group}.
   * Throw exception if failed to match input or group index is
   * invalid.
   */
  start(group?: number): number;
  /**
   * Replace the first sequence which matches the pattern with
   * the given replacment string.
   */
  replaceFirst(replacement: string): string;
  /**
   * Match the entire region against the pattern.  If a match is
   * made then return true - additional info is available via the
   * {@link group | group}, {@link start | start}, and {@link end | end}
   * methods.  Return false if a match cannot be made.
   */
  matches(): boolean;
  /**
   * Replace every sequence which matches the pattern with the
   * given replacement string.
   */
  replaceAll(replacement: string): string;
  /**
   * Return the number of capturing groups or zero if no match.
   * Group zero is not included.
   */
  groupCount(): number;
  /**
   * Attempt to find the next match.  If a match is made then
   * return true - additional info is available via the {@link group | group},
   * {@link start | start}, and {@link end | end} methods.  Return
   * false if a match cannot be made.
   */
  find(): boolean;
  /**
   * Return end index+1 of the given {@link group | group}. Throw
   * exception if failed to match input or group index is
   * invalid.
   */
  end(group?: number): number;
  /**
   * Return the substring captured by the matching operation.
   * Group index zero denotes the entire pattern and capturing
   * groups are indexed from left to right starting at one. 
   * Return null if group failed to match part of the input. 
   * Throw exception if failed to match input or group index is
   * invalid.
   */
  group(group?: number): string | null;
}

/**
 * StrBuf is a mutable sequence of Int characters.
 */
export class StrBuf extends Obj {
  static type$: Type
  /**
   * The number of characters this buffer can hold without
   * allocating more memory.
   */
  capacity(): number;
  capacity(it: number): void;
  /**
   * Insert x.toStr into this buffer at the specified index. If x
   * is null then the string "null" is inserted.  Negative
   * indexes may be used to access from the end of the string
   * buffer.  Throw IndexErr if index is out of range.  Return
   * this.
   */
  insert(index: number, x: JsObj | null): this;
  /**
   * Add a substring of the given string to the buffer.  Return
   * this.
   */
  addRange(s: string, r: Range): this;
  /**
   * Remove the char at the specified index.  A negative index
   * may be used to access an index from the end of the list. 
   * Size is decremented by 1.  Return this.  Throw IndexErr if
   * index is out of range.
   */
  remove(index: number): this;
  /**
   * Create an output stream to append characters to this string
   * buffer.  The output stream is designed to write character
   * data, attempts to do binary writes will throw
   * UnsupportedErr.
   */
  out(): OutStream;
  /**
   * Optimized implementation for add(ch.toChar).  Return this.
   */
  addChar(ch: number): this;
  /**
   * Replaces a range of indices from this buffer with the
   * specified string. Negative indexes may be used to access
   * from the end of the buffer. Throw IndexErr if range illegal.
   * Return this.
   */
  replaceRange(r: Range, str: string): this;
  /**
   * Return a substring based on the specified range.  Negative
   * indexes may be used to access from the end of the string
   * buffer.  This method is accessed via the [] operator.  Throw
   * IndexErr if range illegal.
   * 
   * Examples:
   * ```
   * "abcd"[0..2]   => "abc"
   * "abcd"[3..3]   => "d"
   * "abcd"[-2..-1] => "cd"
   * "abcd"[0..<2]  => "ab"
   * "abcd"[1..-2]  => "bc"
   * "abcd"[4..-1]  => ""
   * ```
   */
  getRange(range: Range): string;
  /**
   * Get the character at the zero based index as a Unicode code
   * point. Negative indexes may be used to access from the end
   * of the string buffer. This method is accessed via the []
   * operator.
   */
  get(index: number): number;
  /**
   * Remove a range of indices from this buffer.  Negative
   * indexes may be used to access from the end of the list. 
   * Throw IndexErr if range illegal.  Return this.
   */
  removeRange(r: Range): this;
  /**
   * Add x.toStr to the end of the buffer.  If the buffer is not
   * empty, then first add the specified separator which defaults
   * to a space if not specified.  Return this.
   */
  join(x: JsObj | null, sep?: string): this;
  /**
   * Create with initial capacity (defaults to 16).
   */
  static make(capacity?: number, ...args: unknown[]): StrBuf;
  /**
   * Return the current buffer contents as a Str.
   */
  toStr(): string;
  /**
   * Add x.toStr to the end of this buffer.  If x is null then
   * the string "null" is inserted.  Return this.
   */
  add(x: JsObj | null): this;
  /**
   * Replace the existing character at index in this buffer.
   * Negative indexes may be used to access from the end of the
   * string buffer.  This method is accessed via the [] operator.
   * Return this.
   */
  set(index: number, ch: number): this;
  /**
   * Return if size() == 0.
   */
  isEmpty(): boolean;
  /**
   * Clear the contents of the string buffer so that it has a
   * size of zero.  Return this.
   */
  clear(): this;
  /**
   * Reverse the contents of this string buffer.  Return this.
   */
  reverse(): this;
  /**
   * Return the number of characters in the buffer.
   */
  size(): number;
}

/**
 * Void is used to represent the absence of a return value in a
 * Method.
 */
export class Void extends Obj {
  static type$: Type
}

/**
 * Facet is a mixin included into every facet type.
 * 
 * See [docLang::Facets](https://fantom.org/doc/docLang/Facets)
 * for details.
 */
export abstract class Facet extends Obj {
  static type$: Type
}

/**
 * UriSchemes are registered to handle a specific Uri scheme
 * such as "file" or "http".  Scheme handlers are registered
 * using the pod index key "sys.uriScheme.{scheme}={qname}"
 * where "scheme" is lowercase scheme name and "qname" is the
 * qualified type name of the subclass.  See [docLang](https://fantom.org/doc/docLang/Naming)
 * for the details of how scheme handling works.
 */
export class UriScheme extends Obj {
  static type$: Type
  /**
   * Default implementation returns type qname.
   */
  toStr(): string;
  /**
   * Lookup a UriScheme for the specified scheme name. Scheme
   * name must be lower case - note that {@link Uri.scheme | Uri.scheme}
   * is always normalized to lower case.  If the scheme is not
   * mapped and checked is true then throw UnresolvedErr
   * otherwise return null.
   */
  static find(scheme: string, checked?: boolean): UriScheme | null;
  /**
   * Resolve the uri to a Fantom object.  If uri cannot be
   * resolved by this scheme then throw UnresolvedErr.
   */
  get(uri: Uri, base: JsObj | null): JsObj | null;
  static make(...args: unknown[]): UriScheme;
}

/**
 * UnknownPodErr indicates an attempt to access a non-existent
 * pod.
 */
export class UnknownPodErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): UnknownPodErr;
}

/**
 * Duration represents a relative duration of time with
 * nanosecond precision.
 * 
 * Also see [docLang](https://fantom.org/doc/docLang/DateTime).
 */
export class Duration extends Obj {
  static type$: Type
  /**
   * Max value is equivalent to `make(Int.maxVal)`.
   */
  static maxVal(): Duration;
  /**
   * Min value is equivalent to `make(Int.minVal)`.
   */
  static minVal(): Duration;
  /**
   * Default value is 0ns.
   */
  static defVal(): Duration;
  /**
   * Get this duration in seconds.  Any fractional seconds are
   * truncated with a loss of precision.
   */
  toSec(): number;
  /**
   * Subtract b from this.  Shortcut is a-b.
   */
  minus(b: Duration): Duration;
  /**
   * Get this duration in minutes.  Any fractional minutes are
   * truncated with a loss of precision.
   */
  toMin(): number;
  /**
   * Compare based on nanosecond ticks.
   */
  compare(obj: JsObj): number;
  /**
   * Multiply this with b.  Shortcut is a*b.
   */
  mult(b: number): Duration;
  /**
   * Divide this by b.  Shortcut is a/b.
   */
  divFloat(b: number): Duration;
  /**
   * Get this duration in hours.  Any fractional hours are
   * truncated with a loss of precision.
   */
  toHour(): number;
  /**
   * Divide this by b.  Shortcut is a/b.
   */
  div(b: number): Duration;
  /**
   * Return the minimum duration between this and that.
   */
  min(that: Duration): Duration;
  /**
   * Get the current value of the system timer.  This method
   * returns a relative time unrelated to system or wall-clock
   * time.  Typically it is the number of nanosecond ticks which
   * have elapsed since system startup.
   */
  static now(): Duration;
  /**
   * Get this duration in milliseconds.  Any fractional
   * milliseconds are truncated with a loss of precision.
   */
  toMillis(): number;
  /**
   * Get the system timer at boot time of the Fantom VM.
   */
  static boot(): Duration;
  /**
   * Return a new Duration with this duration's nanosecond ticks
   * truncated according to the specified accuracy. For example `floor(1min)`
   * will truncate this duration such that its seconds are 0.0.
   */
  floor(accuracy: Duration): Duration;
  /**
   * Format this duration according to ISO 8601.  Also see {@link fromIso | fromIso}.
   * 
   * Examples:
   * ```
   * 8ns.toIso             =>  PT0.000000008S
   * 100ms.toIso           =>  PT0.1S
   * (-20sec).toIso        =>  -PT20S
   * 3.5min.toIso          =>  PT3M30S
   * 1day.toIso            =>  PT24H
   * (1day+2hr+3min).toIso =>  P1DT2H3M
   * ```
   */
  toIso(): string;
  /**
   * Create a Duration which represents the specified number of
   * nanosecond ticks.
   */
  static make(ticks: number, ...args: unknown[]): Duration;
  /**
   * Clamp this duration between the min and max.  If it's less
   * than min then return min, if it's greater than max return
   * max, otherwise return this duration itself.
   */
  clamp(min: Duration, max: Duration): Duration;
  /**
   * Return string representation of the duration which is a
   * valid duration literal format suitable for decoding via {@link fromStr | fromStr}.
   */
  toStr(): string;
  /**
   * Multiply this with b.  Shortcut is a*b.
   */
  multFloat(b: number): Duration;
  /**
   * Return human friendly string representation. TODO: enhance
   * this for pattern
   */
  toLocale(): string;
  /**
   * Return number of nanosecond ticks.
   */
  ticks(): number;
  /**
   * Return the maximum duration between this and that.
   */
  max(that: Duration): Duration;
  /**
   * Get this Duration as a Fantom code literal.
   */
  toCode(): string;
  /**
   * Parse a duration according to ISO 8601.  If invalid format
   * and checked is false return null, otherwise throw ParseErr.
   * The following restrictions are enforced:
   * - Cannot specify a `Y` year or `M` month component since it is
   *   ambiguous
   * - Only the `S` seconds component may include a fraction
   * - Only nanosecond resolution is supported See {@link toIso | toIso}
   *   for example formats.
   */
  static fromIso(s: string, checked?: boolean): Duration;
  /**
   * Add this with b.  Shortcut is a+b.
   */
  plus(b: Duration): Duration;
  /**
   * Get the duration which has elapsed since the Fantom VM was
   * booted which is `now - boot`.
   */
  static uptime(): Duration;
  /**
   * Absolute value - if this is a negative duration, then return
   * its positive value.
   */
  abs(): Duration;
  /**
   * Parse a Str into a Duration according to the Fantom [literal
   * format](https://fantom.org/doc/docLang/Literals#duration).
   * If invalid format and checked is false return null,
   * otherwise throw ParseErr.  The following suffixes are
   * supported:
   * ```
   * ns:   nanoseconds  (x 1)
   * ms:   milliseconds (x 1,000,000)
   * sec:  seconds      (x 1,000,000,000)
   * min:  minutes      (x 60,000,000,000)
   * hr:   hours        (x 3,600,000,000,000)
   * day:  days         (x 86,400,000,000,000)
   * ```
   * 
   * Examples:
   * ```
   * Duration.fromStr("4ns")
   * Duration.fromStr("100ms")
   * Duration.fromStr("-0.5hr")
   * ```
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): Duration;
  /**
   * Convenience for `now.ticks`.
   */
  static nowTicks(): number;
  /**
   * Negative of this.  Shortcut is -a.
   */
  negate(): Duration;
  /**
   * Return true if same number nanosecond ticks.
   */
  equals(obj: JsObj | null): boolean;
  /**
   * Get this duration in 24 hour days.  Any fractional days are
   * truncated with a loss of precision.
   */
  toDay(): number;
  /**
   * Return ticks().
   */
  hash(): number;
}

/**
 * Range represents a contiguous range of integers from start
 * to end.  Ranges may be represented as literals in Fantom
 * source code as "start..end" for an inclusive end or
 * "start..<end" for an exclusive range.
 */
export class Range extends Obj {
  static type$: Type
  /**
   * Convert this range into a list of Ints.
   * 
   * Example:
   * ```
   * (2..4).toList   =>  [2,3,4]
   * (2..<4).toList  =>  [2,3]
   * (10..8).toList  =>  [10,9,8]
   * ```
   */
  toList(): List<number>;
  /**
   * Convenience for {@link Int.random | Int.random(this)}. Also
   * see {@link Int.random | Int.random}, {@link Float.random | Float.random},
   * {@link List.random | List.random}, and {@link util.Random | util::Random}.
   */
  random(): number;
  /**
   * Get the minimum value of the range. If range contains no
   * values then return null.  Equivalent to `toList.min`.
   */
  min(): number | null;
  /**
   * Is the end index exclusive.
   * 
   * Example:
   * ```
   * (1..3).exclusive   =>  false
   * (1..<3).exclusive  =>  true
   * ```
   */
  exclusive(): boolean;
  /**
   * Return end index.
   * 
   * Example:
   * ```
   * (1..3).end  =>  3
   * ```
   */
  end(): number;
  /**
   * Constructor with start, end, and exclusive flag (all must be
   * non-null).
   */
  static make(start: number, end: number, exclusive: boolean, ...args: unknown[]): Range;
  /**
   * Create a new list which is the result of calling c for every
   * integer in the range.  The new list is typed based on the
   * return type of c.
   * 
   * Example:
   * ```
   * (10..15).map |i->Str| { i.toHex }  =>  Str[a, b, c, d, e, f]
   * ```
   */
  map(c: ((arg0: number) => JsObj | null)): List<JsObj | null>;
  /**
   * If inclusive return "start..end", if exclusive return
   * "start..<end".
   */
  toStr(): string;
  /**
   * Is the end index inclusive.
   * 
   * Example:
   * ```
   * (1..3).inclusive   =>  true
   * (1..<3).inclusive  =>  false
   * ```
   */
  inclusive(): boolean;
  /**
   * Get the last value of the range.   If range contains no
   * values then return null.  Equivalent to `toList.last`.
   */
  last(): number | null;
  /**
   * Create a new range by adding offset to this range's start
   * and end values.
   * 
   * Example:
   * ```
   * (3..5).offset(2)   =>  5..7
   * (3..<5).offset(-2) =>  1..<3
   * ```
   */
  offset(offset: number): Range;
  /**
   * Get the maximum value of the range. If range contains no
   * values then return null.  Equivalent to `toList.max`.
   */
  max(): number | null;
  /**
   * Return start index.
   * 
   * Example:
   * ```
   * (1..3).start  =>  1
   * ```
   */
  start(): number;
  /**
   * Return if this range contains no integer values. Equivalent
   * to `toList.isEmpty`.
   */
  isEmpty(): boolean;
  /**
   * Call the specified function for each integer in the range.
   * Also see {@link Int.times | Int.times}.
   * 
   * Example:
   * ```
   * (1..3).each |i| { echo(i) }          =>  1, 2, 3
   * (1..<3).each |i| { echo(i) }         => 1, 2
   * ('a'..'z').each |Int i| { echo(i) }  => 'a', 'b', ... 'z'
   * ```
   */
  each(c: ((arg0: number) => void)): void;
  /**
   * Return if this range contains the specified integer.
   * 
   * Example:
   * ```
   * (1..3).contains(2)  =>  true
   * (1..3).contains(4)  =>  false
   * ```
   */
  contains(i: number): boolean;
  /**
   * Convenience for make(start, end, true).
   */
  static makeExclusive(start: number, end: number, ...args: unknown[]): Range;
  /**
   * Parse from string format - inclusive is "start..end", or
   * exclusive is "start..<end".  If invalid format then throw
   * ParseErr or return null based on checked flag.
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): Range;
  /**
   * Return true if same start, end, and exclusive.
   */
  equals(obj: JsObj | null): boolean;
  /**
   * Convenience for make(start, end, false).
   */
  static makeInclusive(start: number, end: number, ...args: unknown[]): Range;
  /**
   * Iterate every integer in the range until the function
   * returns non-null.  If function returns non-null, then break
   * the iteration and return the resulting object.  Return null
   * if the function returns null for every integer in the range.
   */
  eachWhile(c: ((arg0: number) => JsObj | null)): JsObj | null;
  /**
   * Return start ^ end.
   */
  hash(): number;
  /**
   * Get the first value of the range.   If range contains no
   * values then return null.  Equivalent to `toList.first`.
   */
  first(): number | null;
}

/**
 * UnresolvedErr indicates the failure to resolve a Uri to a
 * resource.
 */
export class UnresolvedErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): UnresolvedErr;
}

/**
 * File is used to represent a Uri path to a file or directory.
 * See [examples](examples::sys-files).
 */
export class File extends Obj {
  static type$: Type
  /**
   * Get time the file was last modified or null if unknown.
   */
  modified(): DateTime | null;
  modified(it: DateTime | null): void;
  /**
   * Return the platform's separator for a list of paths:
   * semicolon on Windows, colon on Unix.
   */
  static pathSep(): string;
  /**
   * Return the platform's separator for names within a path:
   * backslash on Windows, forward slash on Unix.
   */
  static sep(): string;
  /**
   * Get the parent directory of this file or null. Also see {@link Uri.parent | Uri.parent}.
   */
  parent(): File | null;
  /**
   * Convenience for {@link InStream.readAllStr | in.readAllStr}.
   * The input stream is guaranteed to be closed.
   */
  readAllStr(normalizeNewlines?: boolean): string;
  /**
   * Get the root directories of the operating system's local
   * file system.
   */
  static osRoots(): List<File>;
  /**
   * Convenience for {@link Uri.mimeType | uri.mimeType}.
   */
  mimeType(): MimeType | null;
  /**
   * Create a file under this directory.  Convenience for {@link create | create}:
   * ```
   * return (this+name.toUri).create
   * ```
   * 
   * Throw IOErr if this file is not a directory or if there is
   * an error creating the new file.  Return the file created.
   */
  createFile(name: string): File;
  /**
   * Copy this file or directory to the new specified location.
   * If this file represents a directory, then it recursively
   * copies the entire directory tree.
   * 
   * The options map is used to customize how the copy is
   * performed. The following summarizes the options:
   * - exclude:   Regex or |File f->Bool|
   * - overwrite: Bool or |File f->Bool|
   * 
   * If the "exclude" option is a Regex - each source file's Uri
   * string is checked for a match to skip.  If a directory is
   * skipped, then its children are skipped also.  The exclude
   * option can also be a function of type `|File f->Bool|` to
   * check each file.  Exclude processing is performed first
   * before checking for an overwrite.
   * 
   * If during the copy, an existing file of the same name is
   * found, then the "overwrite" option should be `true` to
   * overwrite or `false` to skip.  The overwrite option can also
   * be a function of type `|File to,File from->Bool|` which is
   * passed every to/from file to be overwritten.  If the
   * overwrite function throws an exception, it is raised to the `copyTo`
   * caller.  If a directory overwrite is skipped, then its
   * children are skipped too.  If options are null or overwrite
   * is unspecified then the copy is immediately terminated with
   * an IOErr.
   * 
   * Any IOErr or other error encountered during the file copy
   * immediately terminates the copy and is raised to the caller,
   * which might leave the copy in an unfinished state.
   * 
   * Return the `to` destination file.
   */
  copyTo(to: File, options?: Map<string, JsObj> | null): File;
  /**
   * Move this file under the specified directory and return the
   * destination file.  This method is a convenience for:
   * ```
   * return this.moveTo(dir + this.name)
   * ```
   */
  moveInto(dir: File): File;
  /**
   * Convenience for {@link OutStream.writeProps | out.writeProps()}.
   * The output stream is guaranteed to be closed.
   */
  writeProps(props: Map<string, string>): void;
  /**
   * Convenience for {@link Uri.path | uri.path}.
   */
  path(): List<string>;
  /**
   * Normalize this file path to its canonical representation. If
   * a file on the local file system, then the uri will include
   * the "file:" scheme.  Throw IOErr on error.
   */
  normalize(): File;
  /**
   * Create a file or directory represented by this Uri.  If
   * isDir() is false then create an empty file, or if the file
   * already exists overwrite it to empty.  If isDir() is true
   * then create a directory, or if the directory already exists
   * do nothing.  This method will automatically create any
   * parent directories.  Throw IOErr on error. Return this.
   */
  create(): File;
  /**
   * Return if this file is executable.
   */
  isExecutable(): boolean;
  /**
   * Convenience for {@link Uri.pathStr | uri.pathStr}.
   */
  pathStr(): string;
  /**
   * Return `uri.toStr`.
   */
  toStr(): string;
  /**
   * Convenience for {@link Uri.ext | uri.ext}.
   */
  ext(): string | null;
  /**
   * Open a new buffered InStream used to read from this file.  A
   * bufferSize of null or zero will return an unbuffered input
   * stream. Throw IOErr on error.
   */
  in(bufferSize?: number | null): InStream;
  /**
   * Copy this file under the specified directory and return the
   * destination file.  This method is a convenience for:
   * ```
   * return this.copyTo(dir + this.name, options)
   * ```
   */
  copyInto(dir: File, options?: Map<string, JsObj> | null): File;
  /**
   * List the files contained by this directory.  This list
   * includes both child sub-directories and normal files.  If
   * the directory is empty or this file doesn't represent a
   * directory, then return an empty list.  If pattern is
   * non-null then only filenames matched are returned or if null
   * then all filenames.
   */
  list(pattern?: Regex | null): List<File>;
  /**
   * Make a new File instance by joining this file's Uri together
   * with the specified path.  If the file maps to a directory
   * and the resulting Uri doesn't end in slash then an IOErr is
   * thrown - or pass false for checkSlash to have the slash
   * implicitly added.
   * 
   * Examples:
   * ```
   * File(`a/b/`) + `c` => File(`a/b/c`)
   * File(`a/b`) + `c`  => File(`a/c`)
   * ```
   */
  plus(path: Uri, checkSlash?: boolean): File;
  /**
   * Convenience for {@link Uri.basename | uri.basename}.
   */
  basename(): string;
  /**
   * Return the size of the file in bytes, otherwise null if a
   * directory or unknown.
   */
  size(): number | null;
  /**
   * Convenience for {@link InStream.readProps | in.readProps()}.
   * The input stream is guaranteed to be closed.
   */
  readProps(): Map<string, string>;
  /**
   * Convenience for {@link Uri.name | uri.name}.
   */
  name(): string;
  /**
   * Return if this file is readable.
   */
  isReadable(): boolean;
  /**
   * Return `uri.hash`.
   */
  hash(): number;
  /**
   * Convenience for {@link InStream.readAllLines | in.readAllLines}.
   * The input stream is guaranteed to be closed.
   */
  readAllLines(): List<string>;
  /**
   * Return if this file is writable.
   */
  isWritable(): boolean;
  /**
   * Convenience for {@link InStream.readAllBuf | in.readAllBuf}.
   * The input stream is guaranteed to be closed.
   */
  readAllBuf(): Buf;
  /**
   * Get this File as an operating system specific path on the
   * local system.  If this File doesn't represent a path on the
   * local file system then return null.
   */
  osPath(): string | null;
  /**
   * Delete this file.  If this file represents a directory, then
   * recursively delete it.  If the file does not exist, then no
   * action is taken.  Throw IOErr on error.
   */
  delete(): void;
  /**
   * Open a new buffered OutStream used to write to this file. 
   * If append is true, then we open the file to append to the
   * end, otherwise it is opened as an empty file.  A bufferSize
   * of null or zero will return an unbuffered output stream. 
   * Throw IOErr on error.
   */
  out(append?: boolean, bufferSize?: number | null): OutStream;
  /**
   * Create a sub-directory under this directory.  Convenience
   * for {@link create | create}:
   * ```
   * return (this+name/.toUri).create
   * ```
   * 
   * Throw IOErr if this file is not a directory or if there is
   * an error creating the new directory.  Return the directory
   * created.
   */
  createDir(name: string): File;
  /**
   * Make a File for the Uri which represents a file on the local
   * file system.  If creating a Uri to a directory, then the Uri
   * must end in a trailing "/" slash or IOErr is thrown - or you
   * may pass false for checkSlash in which case the trailing
   * slash is implicitly added.  However if a trailing slash is
   * added, then the resulting File's uri will not match the uri
   * passed to this method. If the file doesn't exist, then it is
   * assumed to be to a directory based on a trailing slash (see {@link isDir | isDir}).
   * If the Uri has a relative path, then it is assumed to be
   * relative to the current working directory.  Throw ArgErr if
   * the Uri has a scheme other than null or "file:".
   */
  static make(uri: Uri, checkSlash?: boolean, ...args: unknown[]): File;
  /**
   * List the child files (excludes directories) contained by
   * this directory.  If the directory doesn't contain any child
   * files or this file doesn't represent a directory, then
   * return an empty list.  If pattern is non-null then only
   * filenames matched are returned or if null then all
   * filenames.
   */
  listFiles(pattern?: Regex | null): List<File>;
  /**
   * Request that the file or directory represented by this File
   * be deleted when the virtual machine exits.  Long running
   * applications should use this method with care since each
   * file marked to delete will consume resources.  Throw IOErr
   * on error.  Return this.
   */
  deleteOnExit(): File;
  /**
   * Make a File for the specified operating system specific path
   * on the local file system.
   */
  static os(osPath: string): File;
  /**
   * Convenience for {@link InStream.readObj | in.readObj} The
   * input stream is guaranteed to be closed.
   */
  readObj(options?: Map<string, JsObj> | null): JsObj | null;
  /**
   * If this is a file, return if the file size is zero or null.
   * If this is a directory, return if this directory has no
   * files without reading a full listing.
   */
  isEmpty(): boolean;
  /**
   * Convenience for {@link OutStream.writeObj | out.writeObj} The
   * output stream is guaranteed to be closed.
   */
  writeObj(obj: JsObj | null, options?: Map<string, JsObj> | null): void;
  /**
   * List the child sub-directories contained by this directory. 
   * If the directory doesn't contain any sub-directories or this
   * file doesn't represent a directory, then return an empty
   * list.  If pattern is non-null then only filenames matched
   * are returned or if null then all filenames.
   */
  listDirs(pattern?: Regex | null): List<File>;
  /**
   * Get the store instance which models the storage pool,
   * device, partition, or volume used to store this file.  Raise
   * UnsupportedErr if this file is not associated with a store.
   */
  store(): FileStore;
  /**
   * Create a temporary file which is guaranteed to be a new,
   * empty file with a unique name.  The file name will be
   * generated using the specified prefix and suffix.  If dir is
   * non-null then it is used as the file's parent directory,
   * otherwise the system's default temporary directory is used. 
   * If dir is specified it must be a directory on the local file
   * system.  See {@link deleteOnExit | deleteOnExit} if you wish
   * to have the file automatically deleted on exit.  Throw IOErr
   * on error.
   * 
   * Examples:
   * ```
   * File.createTemp("x", ".txt") => `/tmp/x67392.txt`
   * File.createTemp.deleteOnExit => `/tmp/fan5284.tmp`
   * ```
   */
  static createTemp(prefix?: string, suffix?: string, dir?: File | null): File;
  /**
   * Return the Uri path used to create this File. This Uri may
   * be absolute or relative.
   */
  uri(): Uri;
  /**
   * Return if this file should be hidden to users.  On Unix
   * hidden files start with a dot and on Windows a metadata flag
   * is used.
   */
  isHidden(): boolean;
  /**
   * Renaming this file within its current directory. This method
   * is a convenience for:
   * ```
   * return this.moveTo(parent + newName)
   * ```
   */
  rename(newName: string): File;
  /**
   * Convenience for {@link InStream.eachLine | in.eachLine}. The
   * input stream is guaranteed to be closed.
   */
  eachLine(f: ((arg0: string) => void)): void;
  /**
   * File equality is based on the un-normalized Uri used to
   * create the File.
   */
  equals(that: JsObj | null): boolean;
  /**
   * Return if this file exists.
   */
  exists(): boolean;
  /**
   * Memory map the region of the file specified by `pos` and `size`.
   * If size is null, then use the file's size as a default.  The
   * file is paged into virtual memory on demand.  Modes are:
   * - "r": map the file for reading only.  Throws IOErr if file
   *   does not exist.
   * - "rw": open the file for reading and writing; create if the
   *   file does not exist.
   * - "p": private read/write mode will not propagate changes to
   *   other processes which have mapped the file.
   */
  mmap(mode?: string, pos?: number, size?: number | null): Buf;
  /**
   * Recursively walk this file/directory top down.  If this file
   * is not a directory then the callback is invoked exactly once
   * with this file.  If a directory, then the callback is
   * invoked with this file, then recursively for each child
   * file.
   */
  walk(c: ((arg0: File) => void)): void;
  /**
   * Open this file for random access.  Modes are:
   * - "r": open the file for reading only.  Throws IOErr if file
   *   does not exist.
   * - "rw": open the file for reading and writing; create if the
   *   file does not exist.
   * 
   * The Buf instance returned is backed by a random access file
   * pointer. It provides the same functionality as a memory
   * backed buffer, except for a couple of exceptions such as {@link Buf.unread | Buf.unread}.
   * The resulting Buf is a raw interface to the random access
   * file, no buffering is provided at the framework level - so
   * use methods which only access a few bytes carefully. 
   * However methods which transfer data with other Bufs and IO
   * streams will use an internal buffer for efficiency.
   */
  open(mode?: string): Buf;
  /**
   * Convenience for {@link Uri.isDir | uri.isDir}
   */
  isDir(): boolean;
  /**
   * Move this file to the specified location.  If this file is a
   * directory, then the entire directory is moved.  If the
   * target file already exists or the move fails, then an IOErr
   * is thrown.  Return the `to` destination file.
   */
  moveTo(to: File): File;
}

/**
 * Used on methods to indicate method may be used as an
 * operator. The operator symbol is determined by the method
 * name:
 * ```
 * prefix     symbol    degree
 * ------     ------    ------
 * negate     -a        unary
 * increment  ++a       unary
 * decrement  --a       unary
 * plus       a + b     binary
 * minus      a - b     binary
 * mult       a * b     binary
 * div        a / b     binary
 * mod        a % b     binary
 * get        a[b]      binary
 * set        a[b] = c  ternary
 * add        a { b, }
 * ```
 * 
 * In the case of binary operators multiple methods may be
 * declared for a given symbol as long as every method starts
 * with correct name, for example "plus" and "plusInt".  For
 * unary/ternary operators there can only be one method and it
 * must be named exactly "negate", "increment", "decrement", or
 * "set".
 * 
 * See [docLang](https://fantom.org/doc/docLang/Methods#operators)
 * for additional details.
 */
export class Operator extends Obj implements Facet {
  static type$: Type
  /**
   * Singleton for Operator facet.
   */
  static defVal(): Operator;
}

/**
 * Func models an executable function.  Functions are typed by
 * a formal parameter list and return value (or Void if no
 * return). Functions are typically defined as method slots on
 * a type, but may also be defined via closures.
 * 
 * An immutable function is one proven to be thread safe:
 * - Method functions are always immutable - see {@link Method.func | sys::Method.func}
 * - Closures which only capture final, const variables are
 *   always immutable; toImmutable always returns this
 * - Closures which capture non-final or non-const variables are
 *   always mutable; toImmutable always throws NotImmutableErr
 * - Closures which capture non-final variables which aren't
 *   known to be immutable until runtime (such as Obj or List)
 *   will return false for isImmutable, but will provide a
 *   toImmutable method which attempts to bind to the current
 *   variables by calling toImmutable on each one
 * - Functions created by {@link bind | Func.bind} are immutable
 *   if the original function is immutable *and* every bound
 *   argument is immutable
 * 
 * The definition of a *final variable* is a variable which is
 * never reassigned after it is initialized.  Any variable
 * which is reassigned is considered a non-final variable.
 * 
 * See [docLang::Functions](https://fantom.org/doc/docLang/Functions)
 * for details.
 */
export class Func extends Obj {
  static type$: Type
  /**
   * Return a new function which wraps this function but with a
   * different reflective type signature.  No verification is
   * done that this function actually conforms to the new
   * signature. This method implicitly calls {@link Type.toNonNullable | Type.toNonNullable}
   * on `t`. Throw ArgErr if `t` isn't a parameterized function type.
   * 
   * Examples:
   * ```
   * f := |a,b->Obj| { "$a, $b" }
   * g := f.retype(|Int,Int->Str|#)
   * f.type  =>  |Obj?,Obj?->Obj|
   * g.type  =>  |Int,Int->Str|
   * ```
   */
  static retype<R>(self: (...args: any[]) => R, t: Type): Function;
  /**
   * Return the associated method if this function implements a
   * method slot.  Otherwise return `null`.
   * 
   * Examples:
   * ```
   * Int#plus.func.method  =>  sys::Int.plus
   * ```
   */
  static method<R>(self: (...args: any[]) => R): Method | null;
  /**
   * Convenience for dynamically invoking an instance method with
   * specified target and arguments.  If this method maps to an
   * instance method, then it is semantically equivalent to `callList([target,
   * args[0], args[1] ...])`.  Throw UnsupportedErr if called on a
   * function which is not an instance method.
   */
  static callOn<R>(self: (...args: any[]) => R, target: JsObj | null, args: List<JsObj | null> | null): R;
  /**
   * Get the formal parameters of the function.
   */
  static params<R>(self: (...args: any[]) => R): List<Param>;
  /**
   * Dynamically invoke this function with the specified
   * arguments and return the result.  If the function has Void
   * return type, then null is returned. The argument list must
   * match the number and type of required parameters. If this
   * function represents an instance method (not static and not a
   * constructor) then the first argument must be the target
   * object.  If the function supports default parameters, omit
   * arguments to use the defaults. It is permissible to pass
   * more arguments then the number of method parameters - the
   * additional arguments are ignored.  If no arguments are
   * required, you may pass null for args.
   */
  static callList<R>(self: (...args: any[]) => R, args: List<JsObj | null> | null): R;
  /**
   * Optimized convenience for {@link callList | callList} for
   * zero to eight parameters.
   */
  static call<R>(self: (...args: any[]) => R, a?: unknown, b?: unknown, c?: unknown, d?: unknown, e?: unknown, f?: unknown, g?: unknown, h?: unknown): R;
  /**
   * Convenience for `params.size`
   */
  static arity<R>(self: (...args: any[]) => R): number;
  /**
   * Create a new function by binding the specified arguments to
   * this function's parameters.  The new function takes the
   * remaining unbound parameters.
   * 
   * The resulting function is immutable if this function is
   * immutable and all the args are immutable.
   */
  static bind<R>(self: (...args: any[]) => R, args: List<JsObj | null>): Function;
  /**
   * Type returned by the function or sys::Void if no return
   * value.
   */
  static returns<R>(self: (...args: any[]) => R): Type;
}

/**
 * Time represents a time of day independent of a specific date
 * or timezone.
 */
export class Time extends Obj {
  static type$: Type
  /**
   * Default value is "00:00:00".
   */
  static defVal(): Time;
  /**
   * Subtract the specified duration to this time. Throw ArgErr
   * if `dur` is not between 0 and 24hr. Overflows will rollover.
   * 
   * Example:
   * ```
   * Time(5,0,0) - 30min  =>  04:30:00
   * ```
   */
  minus(dur: Duration): Time;
  /**
   * Compare based on hour, min, sec, and ns values.
   */
  compare(obj: JsObj): number;
  /**
   * Parse a string into a Time using the given pattern.  If
   * string is not a valid format then return null or raise
   * ParseErr based on checked flag.  See {@link toLocale | toLocale}
   * for pattern syntax.
   */
  static fromLocale(str: string, pattern: string, checked?: boolean): Time | null;
  /**
   * Get the number of nanoseconds (the fraction of seconds) as a
   * number between 0 and 999,999,999.
   */
  nanoSec(): number;
  /**
   * Get the whole seconds of the time as a number between 0 and
   * 59.
   */
  sec(): number;
  /**
   * Get the minutes of the time as a number between 0 and 59.
   */
  min(): number;
  /**
   * Get the hour of the time as a number between 0 and 23.
   */
  hour(): number;
  /**
   * Get the current time using the specified timezone. This
   * method may use {@link DateTime.now | DateTime.now} with the
   * default tolerance 250ms.
   */
  static now(tz?: TimeZone): Time;
  /**
   * Format this instance according to ISO 8601 using the
   * pattern:
   * ```
   * hh:mm:ss.FFFFFFFFF
   * ```
   * 
   * Also see {@link fromIso | fromIso} and {@link toStr | toStr}.
   */
  toIso(): string;
  /**
   * Make for the specified time values:
   * - hour:  0-23
   * - min:   0-59
   * - sec:   0-59
   * - ns:    0-999_999_999
   * 
   * Throw ArgErr if any of the parameters are out of range.
   */
  static make(hour: number, min: number, sec?: number, ns?: number, ...args: unknown[]): Time;
  /**
   * Combine this Time with the given Date to return a DateTime.
   */
  toDateTime(d: Date, tz?: TimeZone): DateTime;
  /**
   * Return programmatic ISO 8601 string encoding formatted as
   * follows:
   * ```
   * hh:mm:ss.FFFFFFFFF
   * 12:06:00.0
   * ```
   * 
   * Also see {@link fromStr | fromStr}, {@link toIso | toIso}, and
   * {@link toLocale | toLocale}.
   */
  toStr(): string;
  /**
   * Format this date according to the specified pattern.  If
   * pattern is null, then a localized default is used.  The
   * pattern format is the same as {@link DateTime.toLocale | DateTime.toLocale}:
   * ```
   * h      One digit 24 hour (0-23)   3, 22
   * hh     Two digit 24 hour (0-23)   03, 22
   * k      One digit 12 hour (1-12)   3, 11
   * kk     Two digit 12 hour (1-12)   03, 11
   * m      One digit minutes (0-59)   4, 45
   * mm     Two digit minutes (0-59)   04, 45
   * s      One digit seconds (0-59)   4, 45
   * ss     Two digit seconds (0-59)   04, 45
   * SS     Optional seconds (only if non-zero)
   * f*     Fractional secs trailing zeros
   * F*     Fractional secs no trailing zeros
   * a      Lower case a/p for am/pm   a, p
   * aa     Lower case am/pm           am, pm
   * A      Upper case A/P for am/pm   A, P
   * AA     Upper case AM/PM           AM, PM
   * 'xyz'  Literal characters
   * ```
   * 
   * A symbol immediately preceding a "F" pattern with no
   * fraction to print is skipped.
   */
  toLocale(pattern?: string | null, locale?: Locale): string;
  /**
   * Get this Time as a Fantom expression suitable for code
   * generation.
   */
  toCode(): string;
  /**
   * Translate a duration of time which has elapsed since
   * midnight into a Time of day.  See {@link toDuration | toDuration}.
   * If the duration is not between 0 and 24hr throw ArgErr.
   * 
   * Example:
   * ```
   * Time.fromDuration(150min)  =>  02:30:00
   * ```
   */
  static fromDuration(d: Duration): Time;
  /**
   * Parse an ISO 8601 time.  If invalid format and checked is
   * false return null, otherwise throw ParseErr.  The following
   * format is supported:
   * ```
   * hh:mm:ss.FFFFFFFFF
   * ```
   * 
   * Also see {@link toIso | toIso} and {@link fromStr | fromStr}.
   */
  static fromIso(s: string, checked?: boolean): Time | null;
  /**
   * Add the specified duration to this time. Throw ArgErr if `dur`
   * is not between 0 and 24hr. Overflows will rollover.
   * 
   * Example:
   * ```
   * Time(5,0,0) + 30min  =>  05:30:00
   * ```
   */
  plus(dur: Duration): Time;
  /**
   * Return if "00:00:00" which is equal to {@link defVal | defVal}.
   */
  isMidnight(): boolean;
  /**
   * Parse the string into a Time from the programmatic encoding
   * defined by {@link toStr | toStr}.  If the string cannot be
   * parsed into a valid Time and checked is false then return
   * null, otherwise throw ParseErr.
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): Time;
  /**
   * Two times are equal if have identical hour, min, sec, and ns
   * values.
   */
  equals(that: JsObj | null): boolean;
  /**
   * Return the duration of time which has elapsed since
   * midnight. See {@link fromDuration | fromDuration}.
   * 
   * Example:
   * ```
   * Time(2, 30).toDuration  =>  150min
   * ```
   */
  toDuration(): Duration;
  /**
   * Return hash of hour, min, sec, and ns values.
   */
  hash(): number;
}

/**
 * Env defines a pluggable class used to boot and manage a
 * Fantom runtime environment.  Use {@link cur | cur} to access
 * the current Env instance.
 */
export class Env extends Obj {
  static type$: Type
  /**
   * Get the parent environment or null if this is the bootstrap
   * environment.  Many virtual methods delegate to their parent
   * by default.
   */
  parent(): Env | null;
  /**
   * Get the home directory of Fantom installation. Default
   * implementation delegates to {@link parent | parent}.
   */
  homeDir(): File;
  /**
   * Path used by {@link findFile | findFile} if this is a {@link util.PathEnv | util::PathEnv}.
   */
  path(): List<File>;
  /**
   * Get the local host name of the machine running the virtual
   * machine process.  Default implementation delegates to {@link parent | parent}.
   */
  host(): string;
  /**
   * Return the default hash code of {@link Obj.hash | Obj.hash}
   * for the specified object regardless of whether the object
   * has overridden the `hash` method.  If null then return 0.
   */
  idHash(obj: JsObj | null): number;
  /**
   * Get the environment variables as a case insensitive,
   * immutable map of Str name/value pairs.  The environment map
   * is initialized from the following sources from lowest
   * priority to highest priority:
   * 1. shell environment variables
   * 2. Java system properties (Java VM only obviously)
   * 
   * Default implementation delegates to {@link parent | parent}.
   */
  vars(): Map<string, string>;
  /**
   * Return the list of pod names for all the pods currently
   * installed in this environemnt.  This method is used by {@link Pod.list | Pod.list}
   * and for constructing the type database.  Each of these names
   * must be resolvable by {@link findPodFile | findPodFile}.  The
   * default implementation routes to {@link findFile | findFile}
   * to look in the "lib/fan" directory and assumes a naming
   * convention of "{name}.pod".
   */
  findAllPodNames(): List<string>;
  /**
   * Standard input stream. Default implementation delegates to {@link parent | parent}.
   */
  in(): InStream;
  /**
   * Find a file in the environment using a relative path such as
   * "etc/foo/config.props".  If the URI is not relative then
   * throw ArgErr.  If the file is not found in the environment
   * then throw UnresolvedErr or return null based on checked
   * flag.  If {@link findAllFiles | findAllFiles} would return
   * multiple matches, then this method should always return the
   * file with the highest priority. Default implementation
   * delegates to {@link parent | parent}.
   */
  findFile(uri: Uri, checked?: boolean): File | null;
  /**
   * Virtual machine runtime as one of the following constants:
   * - "java"
   * - "dotnet"
   * - "js"
   */
  runtime(): string;
  /**
   * Lookup all the matching values for a pod indexed key.  If no
   * matches are found return the empty list.  Indexed props are
   * declared in your pod's build script, and coalesced into a
   * master index by the current environment.  See [docLang](https://fantom.org/doc/docLang/Env#index)
   * for details.
   */
  index(key: string): List<string>;
  /**
   * Find all the files in the environment which match a relative
   * path such as "etc/foo/config.props".  It is possible to have
   * multiple matches if the environment uses a search path
   * model. If the list contains more than one item, then the
   * first file has the highest priority and the last item has
   * the lowest priority.  If the URI is not relative then throw
   * ArgErr. Return empty list if the file is not found in
   * environment. Default implementation delegates to {@link parent | parent}.
   */
  findAllFiles(uri: Uri): List<File>;
  /**
   * Return a merged key/value map of all the prop files found
   * using the following resolution rules:
   * 1. {@link findAllFiles | Env.findAllFiles}: "etc/{pod}/{uri}"
   * 2. Pods indexed with `sys.envProps`: "/{pod}/uri"
   * 3. {@link Pod.files | Pod.files}: "/{uri}"
   * 
   * The uri must be relative.  Note that props such as locale
   * files can be bundled into a pod for deployment and searched
   * by adding an indexed prop with the key "sys.envProps" and
   * the pod name as the value.  This feature does not support
   * "config.props".
   * 
   * The files are parsed using {@link InStream.readProps | InStream.readProps}
   * and merged according to their priority order.  If the file
   * is defined as a resource in the pod itself, then it is
   * treated as lowest priority.  The first file returned by `findAllFiles`
   * is treated as highest priority and overwrites any key-value
   * pairs defined at a lower priority.
   * 
   * The map is cached so that subsequent calls for the same path
   * don't require accessing the file system again.  The `maxAge`
   * parameter specifies the tolerance accepted before a cache
   * refresh is performed to check if any of the files have been
   * modified.
   * 
   * Also see {@link Pod.props | Pod.props} and [docLang::Env](https://fantom.org/doc/docLang/Env).
   */
  props(pod: Pod, uri: Uri, maxAge: Duration): Map<string, string>;
  /**
   * Return list of all pod names that define the given key.
   * NOTE: Java runtime only
   */
  indexPodNames(key: string): List<string>;
  /**
   * Terminate the current virtual machine. Default
   * implementation delegates to {@link parent | parent}.
   */
  exit(status?: number): void;
  /**
   * Compile a script file into a pod and return the first public
   * type declared in the script file.  If the file has been
   * previously compiled and hasn't changed, then a cached type
   * is returned.  If the script contains errors then the first
   * CompilerErr found is thrown.  The options available:
   * - logLevel: the default {@link LogLevel | LogLevel} to use for
   *   logging the compilation process and errors
   * - log: the {@link compiler.CompilerLog | compiler::CompilerLog}
   *   to use for logging the compilation process and errors
   * - logOut: an output stream to capture logging
   * - force: pass `true` to not use caching, always forces a
   *   recompile
   */
  compileScript(f: File, options?: Map<string, JsObj> | null): Type;
  /**
   * Get listing of all keys mapped by indexed props.  The values
   * of each key may be resolved by the {@link index | index}
   * method. See [docLang](https://fantom.org/doc/docLang/Env#index)
   * for details. NOTE: Java runtime only
   */
  indexKeys(): List<string>;
  /**
   * Get the current runtime environment
   */
  static cur(): Env;
  /**
   * Get the Java VM Version as a single integer (8, 9, etc.). If
   * the {@link runtime | runtime} is not java, return 0.
   */
  javaVersion(): number;
  /**
   * Add a function to be called on VM shutdown.  Throw
   * NotImmutableErr if the function is not immutable. Default
   * implementation delegates to {@link parent | parent}.
   */
  addShutdownHook(hook: (() => void)): void;
  /**
   * Lookup a localized property for the specified pod/key pair.
   * The following rules are used for resolution:
   * 1. `props(pod, `locale/{locale}.props`)`
   * 2. `props(pod, `locale/{lang}.props`)`
   * 3. `props(pod, `locale/en.props`)`
   * 4. Fallback to `pod::key` unless `def` specified
   * 
   * Where `{locale}` is {@link Locale.toStr | Locale.toStr} and `{lang}`
   * is {@link Locale.lang | Locale.lang}. The maxAge parameter is
   * set to Duration.maxVal (cached for life of the VM).
   * 
   * Also see {@link Pod.locale | Pod.locale} and [docLang::Localization](https://fantom.org/doc/docLang/Localization).
   */
  locale(pod: Pod, key: string, def?: string | null, locale?: Locale): string | null;
  /**
   * Name of the host platform as a string formatted as
   * "<os>-<arch>".  See {@link os | os} and {@link arch | arch}.
   */
  platform(): string;
  /**
   * Standard output stream. Default implementation delegates to {@link parent | parent}.
   */
  out(): OutStream;
  /**
   * Prompt the user to enter a password from standard input with
   * echo disabled.  This method routes to {@link util.Console.promptPassword | util::Console.promptPassword}.
   */
  promptPassword(msg?: string): string | null;
  /**
   * Compile a script file into a pod and return the JS source
   * code of resulting pod.  If the script contains errors then
   * the first CompilerErr found is thrown.  The options
   * available:
   * - podName: the name of pod created for script
   * - logLevel: the default {@link LogLevel | LogLevel} to use for
   *   logging the compilation process and errors
   * - log: the {@link compiler.CompilerLog | compiler::CompilerLog}
   *   to use for logging the compilation process and errors
   * - logOut: an output stream to capture logging
   */
  compileScriptToJs(f: File, options?: Map<string, JsObj> | null): string;
  /**
   * Get the working directory to use for saving compiled pods
   * and configuration information.  Default implementation
   * delegates to {@link parent | parent}.
   */
  workDir(): File;
  /**
   * Get the main method which was used to run this Fantom VM.
   * Return null if VM was booted outside of a Fantom main
   * method. Default implementation delegates to {@link parent | parent}.
   */
  mainMethod(): Method | null;
  /**
   * Run the garbage collector.  No guarantee is made to what the
   * VM will actually do.  Default implementation delegates to {@link parent | parent}.
   */
  gc(): void;
  /**
   * Operating system name as one of the following constants:
   * - "win32"
   * - "macosx"
   * - "linux"
   * - "aix"
   * - "solaris"
   * - "hpux"
   * - "qnx"
   */
  os(): string;
  /**
   * Standard error output stream. Default implementation
   * delegates to {@link parent | parent}.
   */
  err(): OutStream;
  /**
   * Get the command line arguments used to run the fan process
   * as an immutable List of strings.  Default implementation
   * delegates to {@link parent | parent}.
   */
  args(): List<string>;
  /**
   * Poll for a platform dependent map of diagnostics name/value
   * pairs for the current state of the VM.  Java platforms
   * return key values from the `java.lang.management` interface.
   * Default implementation delegates to {@link parent | parent}.
   */
  diagnostics(): Map<string, JsObj>;
  /**
   * Resolve the pod file for the given pod name.  If the name
   * cannot be resolved to a pod, return null.  The default
   * implementation routes to {@link findFile | findFile} to look
   * in "lib/fan" directory.
   */
  findPodFile(podName: string): File | null;
  /**
   * Get the temp directory to use for scratch files. Default
   * implementation delegates to {@link parent | parent}.
   */
  tempDir(): File;
  /**
   * Remove a shutdown hook function which was added by {@link addShutdownHook | addShutdownHook}.
   * Remove true if hook had been previously added and was
   * unregistered, false otherwise. Default implementation
   * delegates to {@link parent | parent}.
   */
  removeShutdownHook(hook: (() => void)): boolean;
  /**
   * Microprocessor architecture name as one of the following
   * constants:
   * - "x86"
   * - "x86_64"
   * - "ppc"
   * - "sparc"
   * - "ia64"
   * - "ia64_32"
   * - "aarch64"
   */
  arch(): string;
  /**
   * Get the user name of the user account used to run the
   * virtual machine process.  Default implementation delegates
   * to {@link parent | parent}.
   */
  user(): string;
  /**
   * Prompt the user to enter a command line from standard input.
   * This method routes to {@link util.Console.prompt | util::Console.prompt}.
   */
  prompt(msg?: string): string | null;
  /**
   * Lookup a configuration property for given pod/key pair. If
   * not found then return `def`.  Default implementation routes to
   * {@link props | props} using max age of one minute:
   * ```
   * props(pod, `config.props`, 1min).get(key, def)
   * ```
   * 
   * Also see {@link Pod.config | Pod.config} and [docLang::Env](https://fantom.org/doc/docLang/Env).
   */
  config(pod: Pod, key: string, def?: string | null): string | null;
}

/**
 * Facet meta-data applied to facet classes.
 */
export class FacetMeta extends Obj implements Facet {
  static type$: Type
  /**
   * Indicates whether the facet is inherited by sub-types. See [docLang](https://fantom.org/doc/docLang/Facets#inheritance)
   * for additional details.
   */
  inherited(): boolean;
  __inherited(it: boolean): void;
  static make(f?: ((arg0: FacetMeta) => void) | null, ...args: unknown[]): FacetMeta;
}

/**
 * Int is used to represent a signed 64-bit integer.
 */
export class Int extends Num {
  static type$: Type
  /**
   * Maximum value which can be stored in a signed 64-bit Int:
   * 9,223,372,036,854,775,807
   */
  static maxVal(): number;
  /**
   * Minimum value which can be stored in a signed 64-bit Int:
   * -9,223,372,036,854,775,808
   */
  static minVal(): number;
  /**
   * Default value is zero.
   */
  static defVal(): number;
  /**
   * Bitwise left shift of this by b.
   */
  static shiftl(self: number, b: number): number;
  /**
   * Multiply this with b.  Shortcut is a*b.
   */
  static mult(self: number, b: number): number;
  /**
   * Return remainder of this divided by b.  Shortcut is a%b.
   */
  static mod(self: number, b: number): number;
  /**
   * Divide this by b.  Shortcut is a/b.
   */
  static divFloat(self: number, b: number): number;
  /**
   * If this Unicode char is an ASCII lowercase char, then return
   * it as uppercase, otherwise return this.
   * 
   * Example:
   * ```
   * 'a'.upper => 'A'
   * '4'.upper => '4'
   * ```
   */
  static upper(self: number): number;
  /**
   * Return if this Unicode char is whitespace: space \t \n \r \f
   */
  static isSpace(self: number): boolean;
  /**
   * Divide this by b.  Shortcut is a/b.
   */
  static div(self: number, b: number): number;
  /**
   * Add this with b.  Shortcut is a+b.
   */
  static plusFloat(self: number, b: number): number;
  /**
   * If this Unicode char is a lowercase char, then return it as
   * uppercase according to the current locale.  Note that
   * Unicode contains some case conversion rules that don't work
   * correctly on a single character, so {@link Str.localeUpper | Str.localeUpper}
   * should be preferred.  See also {@link localeLower | localeLower}
   * and {@link upper | upper}.
   */
  static localeUpper(self: number): number;
  /**
   * Return if this Unicode char is an ASCII uppercase alphabetic
   * char: A-Z
   */
  static isUpper(self: number): boolean;
  /**
   * Bitwise right shift of this by b.  Zero is shifted into the
   * highest bits performing like an unsigned shift.  This is
   * equivalent to the Java `>>>` operator.
   */
  static shiftr(self: number, b: number): number;
  /**
   * Return if the two Unicode chars are equal without regard to
   * ASCII case.
   */
  static equalsIgnoreCase(self: number, ch: number): boolean;
  /**
   * Clamp this integer between the min and max.  If it's less
   * than min then return min, if it's greater than max return
   * max, otherwise return this integer itself.
   */
  static clamp(self: number, min: number, max: number): number;
  /**
   * Convert nano-seconds ticks since 1-Jan-2000 to a DateTime.
   * Convenience for {@link DateTime.makeTicks | DateTime.makeTicks}.
   */
  static toDateTime(self: number, tz?: TimeZone): DateTime;
  /**
   * Return remainder of this divided by b.  Shortcut is a%b.
   */
  static modFloat(self: number, b: number): number;
  /**
   * Return decimal string representation.
   */
  static toStr(self: number): string;
  /**
   * Multiply this with b.  Shortcut is a*b.
   */
  static multFloat(self: number, b: number): number;
  /**
   * Return if this Unicode char is an ASCII alpha-numeric char:
   * isAlpha||isDigit
   */
  static isAlphaNum(self: number): boolean;
  /**
   * Return string representation in given radix.  If width is
   * non-null, then leading zeros are prepended to ensure the
   * specified width.
   * 
   * Examples:
   * ```
   * 255.toRadix(8)    =>  "377"
   * 255.toRadix(8, 5) =>  "00377"
   * ```
   */
  static toRadix(self: number, radix: number, width?: number | null): string;
  /**
   * Return if this Unicode char is an ASCII alpha char:
   * isUpper||isLower
   */
  static isAlpha(self: number): boolean;
  /**
   * Get this Int as a Fantom code literal.  Base must be 10 or
   * 16.
   */
  static toCode(self: number, base?: number): string;
  /**
   * If this Unicode char is an ASCII uppercase char, then return
   * it as lowercase, otherwise return this.
   * 
   * Example:
   * ```
   * 'A'.lower => 'a'
   * 'h'.lower => 'h'
   * ```
   */
  static lower(self: number): number;
  /**
   * Add this with b.  Shortcut is a+b.
   */
  static plus(self: number, b: number): number;
  /**
   * Divide this by b.  Shortcut is a/b.
   */
  static divDecimal(self: number, b: number): number;
  /**
   * Return if this Unicode char is a lowercase letter in the
   * current locale.  See also {@link localeIsUpper | localeIsUpper}
   * and {@link isLower | isLower}.
   */
  static localeIsLower(self: number): boolean;
  /**
   * Parse a Str into a Int using the specified radix.  Unless
   * the radix is 10, then a leading minus sign is illegal. If
   * invalid format and checked is false return null, otherwise
   * throw ParseErr.
   */
  static fromStr(s: string, radix?: number, checked?: boolean, ...args: unknown[]): Int;
  /**
   * Return hexdecimal string representation.  If width is
   * non-null, then leading zeros are prepended to ensure the
   * specified number of nibble characters.
   * 
   * Examples:
   * ```
   * 255.toHex     =>  "ff"
   * 255.toHex(4)  =>  "00ff"
   * ```
   */
  static toHex(self: number, width?: number | null): string;
  /**
   * Bitwise arithmetic right-shift of this by b. The left-most
   * bit is shifted into the highest bits performing like a
   * signed shift. This is equivalent to the Java `>>` operator.
   */
  static shifta(self: number, b: number): number;
  /**
   * Return if this Unicode char is a digit in the specified
   * radix. A decimal radix of ten returns true for 0-9.  A radix
   * of 16 also returns true for a-f and A-F.
   * 
   * Example:
   * ```
   * '3'.toDigit     => true
   * 3.toDigit       => false
   * 'B'.toDigit(16) => true
   * ```
   */
  static isDigit(self: number, radix?: number): boolean;
  /**
   * If this Unicode char is an uppercase char, then return it as
   * lowercase according to the current locale.  Note that
   * Unicode contains some case conversion rules that don't work
   * correctly on a single character, so {@link Str.localeLower | Str.localeLower}
   * should be preferred.  See also {@link localeUpper | localeUpper}
   * and {@link lower | lower}.
   */
  static localeLower(self: number): number;
  /**
   * Convert nano-seconds ticks to a Duration. Convenience for {@link Duration.make | Duration.make}.
   */
  static toDuration(self: number): Duration;
  /**
   * Return this.
   */
  static hash(self: number): number;
  /**
   * Subtract b from this.  Shortcut is a-b.
   */
  static minus(self: number, b: number): number;
  /**
   * Compare based on integer value.
   */
  static compare(self: number, obj: JsObj): number;
  /**
   * Return if this integer is evenly divisible by two.
   */
  static isEven(self: number): boolean;
  /**
   * Increment by one.  Shortcut is ++a or a++.
   */
  static increment(self: number): number;
  /**
   * Add this with b.  Shortcut is a+b.
   */
  static plusDecimal(self: number, b: number): number;
  /**
   * Return if this Unicode char is an uppercase letter in the
   * current locale.  See also {@link localeIsLower | localeIsLower}
   * and {@link isUpper | isUpper}.
   */
  static localeIsUpper(self: number): boolean;
  /**
   * Generate a random number.  If range is null then all 2^64
   * integer values (both negative and positive) are produced
   * with equal probability.  If range is non-null, then the
   * result is guaranteed to be inclusive of the range.  Also see
   * {@link Float.random | Float.random} , {@link Range.random | Range.random}
   * , {@link List.random | List.random} , and {@link util.Random | util::Random}.
   * 
   * Examples:
   * ```
   * r := Int.random
   * r := Int.random(0..100)
   * ```
   */
  static random(r?: Range | null): number;
  /**
   * Bitwise not/inverse of this.
   */
  static not(self: number): number;
  /**
   * Call the specified function to this times passing the
   * current counter. The counter begins at zero.  Also see {@link Range.each | Range.each}.
   * 
   * Example:
   * ```
   * 3.times |i| { echo(i) }  =>  0, 1, 2
   * ```
   */
  static times(self: number, c: ((arg0: number) => void)): void;
  /**
   * Subtract b from this.  Shortcut is a-b.
   */
  static minusDecimal(self: number, b: number): number;
  /**
   * Return the smaller of this and the specified Int values.
   */
  static min(self: number, that: number): number;
  /**
   * Bitwise-and of this and b.
   */
  static and(self: number, b: number): number;
  /**
   * Subtract b from this.  Shortcut is a-b.
   */
  static minusFloat(self: number, b: number): number;
  /**
   * Return if this integer is not evenly divisible by two.
   */
  static isOdd(self: number): boolean;
  /**
   * Return this value raised to the specified power. Throw
   * ArgErr if pow is less than zero.
   */
  static pow(self: number, pow: number): number;
  /**
   * Bitwise-exclusive-or of this and b.
   */
  static xor(self: number, b: number): number;
  /**
   * Convert this number into a Unicode char `0`-'9'.  If radix is
   * greater than 10, then use a lower case letter.  Return null
   * if this number cannot be represented as a single digit
   * character for the specified radix.
   * 
   * Example:
   * ```
   * 3.toDigit      => '3'
   * 15.toDigit(16) => 'f'
   * 99.toDigit     => null
   * ```
   */
  static toDigit(self: number, radix?: number): number | null;
  /**
   * Map as a Unicode code point to a single character Str.
   */
  static toChar(self: number): string;
  /**
   * Format this integer number for the current locale. If
   * pattern is null, then the locale's default pattern is used.
   * See {@link Float.toLocale | Float.toLocale} for pattern
   * language.  Fractional formatting is not supported for
   * integers.
   * 
   * In addition `Int.toLocale` supports the "B" pattern which will
   * format a number of bytes with the appropriate B, KB, MB, GB
   * suffix based on the magnitude (1024B == 1KB).
   * 
   * Examples:
   * ```
   * 3.toLocale("00")             =>  03
   * 3.toLocale("000")            =>  003
   * 123456789.toLocale("#,###")  =>  123,456,789
   * 123.toLocale("B")            =>  123B
   * 1234.toLocale("B")           =>  1.2KB
   * 100_000.toLocale("B")        =>  98KB
   * (3*1024*1024).toLocale("B")  =>  3MB
   * ```
   */
  static toLocale(self: number, pattern?: string | null, locale?: Locale): string;
  /**
   * Return remainder of this divided by b.  Shortcut is a%b.
   */
  static modDecimal(self: number, b: number): number;
  /**
   * Bitwise-or of this and b.
   */
  static or(self: number, b: number): number;
  /**
   * Return the larger of this and the specified Int values.
   */
  static max(self: number, that: number): number;
  /**
   * Convert a Unicode digit character into a number for the
   * specified radix.  Return null if this char is not a valid
   * digit.
   * 
   * Example:
   * ```
   * '3'.fromDigit     => 3
   * 'f'.fromDigit(16) => 15
   * '%'.fromDigit     => null
   * ```
   */
  static fromDigit(self: number, radix?: number): number | null;
  /**
   * Return the absolute value of this integer.  If this value is
   * positive then return this, otherwise return the negation.
   */
  static abs(self: number): number;
  /**
   * Negative of this.  Shortcut is -a.
   */
  static negate(self: number): number;
  /**
   * Decrement by one.  Shortcut is --a or a--.
   */
  static decrement(self: number): number;
  /**
   * Return true if same integer value.
   */
  static equals(self: number, obj: JsObj | null): boolean;
  /**
   * Return if this Unicode char is an ASCII lowercase alphabetic
   * char: a-z
   */
  static isLower(self: number): boolean;
  /**
   * Multiply this with b.  Shortcut is a*b.
   */
  static multDecimal(self: number, b: number): number;
}

/**
 * NullErr indicates an attempt to dereference null.  It is
 * often raised when attempting to access an instance field or
 * method on a null reference.  It may also be thrown when a
 * parameter is expecting a non-nullable argument and null is
 * passed.
 */
export class NullErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): NullErr;
}

/**
 * Field is a slot which models the ability to get and set a
 * value.
 */
export class Field extends Slot {
  static type$: Type
  /**
   * Type stored by the field.
   */
  type(): Type;
  /**
   * Get the field for the specified instance.  If the field is
   * static, then the instance parameter is ignored.  If the
   * getter is non-null, then it is used to get the field.
   */
  get(instance?: JsObj | null): JsObj | null;
  /**
   * Construct a function which sets zero or more fields on a
   * target object.  The function can be passed to a constructor
   * which takes an it-block to reflectively set const fields. 
   * Example:
   * ```
   * const class Foo
   * {
   *   new make(|This|? f := null) { f?.call(this) }
   *   const Int x
   * }
   * 
   * f := Field.makeSetFunc([Foo#x: 7])
   * Foo foo := Foo#.make([f])
   * ```
   */
  static makeSetFunc(vals: Map<Field, JsObj | null>): ((arg0: JsObj) => void);
  /**
   * Set the field for the specified instance.  If the field is
   * static, then the instance parameter is ignored.  If the
   * setter is non-null, then it is used to set the field.
   */
  set(instance: JsObj | null, value: JsObj | null): void;
}

/**
 * Obj is the root class of all classes.
 */
export class Obj {
  static type$: Type
  /**
   * Return a string representation of this object.
   */
  toStr(): string;
  /**
   * This method called whenever an it-block is applied to an
   * object.  The default implementation calls the function with `this`,
   * and then returns `this`.
   */
  with(f: ((arg0: this) => void)): this;
  /**
   * Return a negative integer, zero, or a positive integer if
   * this object is less than, equal to, or greater than the
   * specified object:
   * ```
   * this < that   =>  <0
   * this == that  =>  0
   * this > that   =>  >0
   * ```
   * 
   * This method may also be accessed via the `<` `<=` `<=>` `>=` and `>`
   * shortcut operators.  If not overridden the default
   * implementation compares the {@link toStr | toStr}
   * representations.  Also see [docLang](https://fantom.org/doc/docLang/Expressions#shortcuts).
   * 
   * Examples:
   * ```
   * 3.compare(8)  =>  -1
   * 8.compare(3)  =>  1
   * 8.compare(8)  =>  0
   * 3 <=> 8       =>  -1  // shortcut for 3.compare(8)
   * ```
   */
  compare(that: JsObj): number;
  /**
   * Return if this Obj is [immutable](https://fantom.org/doc/docLang/Concurrency#immutability)
   * and safe to share between threads:
   * - an instance of a const class
   * - the result of {@link toImmutable | toImmutable} on {@link List | List},
   *   {@link Map | Map}, or {@link Buf | Buf}
   * - a Func object may or may not be immutable - see {@link Func | sys::Func}.
   * - other instances are assumed mutable and return false
   */
  isImmutable(): boolean;
  /**
   * Compare this object to the specified for equality.  This
   * method may be accessed via the == and != shortcut operators.
   * If not overridden the default implementation compares for
   * reference equality using the === operator.  If this method
   * is overridden, then hash() must also be overridden such that
   * any two objects which return true for equals() must return
   * the same value for hash().  This method must accept `null` and
   * return false.
   */
  equals(that: JsObj | null): boolean;
  /**
   * Write `x.toStr` to standard output followed by newline.  If `x`
   * is null then print "null".  If no argument is provided then
   * print an empty line.
   */
  static echo(x?: JsObj | null): void;
  /**
   * Trap a dynamic call for handling.  Dynamic calls are invoked
   * with the -> shortcut operator:
   * ```
   * a->x        a.trap("x", null)
   * a->x()      a.trap("x", null)
   * a->x = b    a.trap("x", [b])
   * a->x(b)     a.trap("x", [b])
   * a->x(b, c)  a.trap("x", [b, c])
   * ```
   * 
   * The default implementation provided by Obj attempts to use
   * reflection.  If name maps to a method, it is invoked with
   * the specified arguments.  If name maps to a field and
   * args.size is zero, get the field.  If name maps to a field
   * and args.size is one, set the field and return args[0]. 
   * Otherwise throw UnknownSlotErr.
   */
  trap(name: string, args?: List<JsObj | null> | null): JsObj | null;
  /**
   * Get an immutable representation of this instance or throw
   * NotImmutableErr if this object cannot be represented as an
   * immutable:
   * - if type is const, return this
   * - if already an immutable List, Map, Buf, or Func return this
   * - if a List, then attempt to perform a deep clone by calling
   *   toImmutable on all items
   * - if a Map, then attempt to perform a deep clone by calling
   *   toImmutable on all values (keys are already immutable)
   * - some Funcs can be made immutable - see {@link Func | sys::Func}
   * - if a Buf create immutable copy, see {@link Buf | sys::Buf}
   * - any other object throws NotImmutableErr
   */
  toImmutable(): Readonly<this>;
  /**
   * Return a unique hashcode for this object.  If a class
   * overrides hash() then it must ensure if equals() returns
   * true for any two objects then they have same hash code.
   */
  hash(): number;
  /**
   * Get the `Type` instance which represents this object's class.
   * Also see`Type.of` or {@link Pod.of | Pod.of}.
   */
  typeof(): Type;
}

/**
 * CastErr is a runtime exception raised when invalid cast is
 * performed.
 */
export class CastErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): CastErr;
}

/**
 * OutStream is used to write binary and text data to an output
 * stream.
 */
export class OutStream extends Obj {
  static type$: Type
  /**
   * The current charset used to encode Unicode characters into
   * bytes.  The default charset should always be UTF-8.
   */
  charset(): Charset;
  charset(it: Charset): void;
  /**
   * Byte order mode for binary writes. Default is {@link Endian.big | Endian.big}
   * (network byte order).
   */
  endian(): Endian;
  endian(it: Endian): void;
  /**
   * XML escape single and double quotes.  See {@link writeXml | writeXml}.
   */
  static xmlEscQuotes(): number;
  /**
   * XML escape any character greater then 0x7f.  See {@link writeXml | writeXml}.
   */
  static xmlEscUnicode(): number;
  /**
   * XML escape newline characters.  See {@link writeXml | writeXml}.
   */
  static xmlEscNewlines(): number;
  /**
   * Write four bytes as a 32-bit floating point number using
   * configured {@link endian | endian} order according to {@link Float.bits32 | Float.bits32}.
   * This is paired with {@link InStream.readF4 | InStream.readF4}.
   * Throw IOErr on error.  Return this.
   */
  writeF4(r: number): this;
  /**
   * Write a string to this output stream using XML escape
   * sequences. By default only the `< > &` characters are escaped.
   * You can use the following flags to escape additional
   * characters:
   * - {@link xmlEscNewlines | xmlEscNewlines}: escape the `\n` and `\r`
   *   characters
   * - {@link xmlEscQuotes | xmlEscQuotes}: escape the single and
   *   double quote characters
   * - {@link xmlEscUnicode | xmlEscUnicode}: escape any character
   *   greater than 0x7f
   * 
   * Any control character less than 0x20 which is not `\t`, `\n` or `\r`
   * is always escaped with a numeric reference.  Return this.
   */
  writeXml(str: string, mode?: number): this;
  /**
   * Write one byte, one if true or zero if false.  This method
   * is paired with {@link InStream.readBool | InStream.readBool}.
   * Throw IOErr on error.  Return this.
   */
  writeBool(b: boolean): this;
  /**
   * Write the given map of Str name/value pairs to the output
   * stream according to the Fantom props file format (see {@link InStream.readProps | InStream.readProps}
   * for full specification).  The props are written using UTF-8
   * regardless of this stream's current charset.  If close
   * argument is true, then automatically close the stream. 
   * Return this.
   */
  writeProps(props: Map<string, string>, close?: boolean): this;
  /**
   * Flush the stream so any buffered bytes are written out. 
   * Default implementation does nothing.  Throw IOErr on error. 
   * Return this.
   */
  flush(): this;
  /**
   * Write eight bytes as a 64-bit floating point number using
   * configured {@link endian | endian} order according to {@link Float.bits | Float.bits}.
   * This is paired with {@link InStream.readF8 | InStream.readF8}.
   * Throw IOErr on error.  Return this.
   */
  writeF8(r: number): this;
  /**
   * Write a byte to the output stream.  Throw IOErr on error.
   * Return this.
   */
  write(byte: number): this;
  /**
   * Close the output stream.  This method is guaranteed to never
   * throw an IOErr.  Return true if the stream was closed
   * successfully or false if the stream was closed abnormally. 
   * Default implementation does nothing and returns true.
   */
  close(): boolean;
  /**
   * Write four bytes as a 32-bit number using configured {@link endian | endian}.
   * This method may be paired with {@link InStream.readU4 | InStream.readU4}
   * or {@link InStream.readS4 | InStream.readS4}.  Throw IOErr on
   * error.  Return this.
   */
  writeI4(n: number): this;
  /**
   * Write between 0 and 64 bits of the given integer value. 
   * Bits which are only a partial byte are bufferred in RAM
   * until {@link flush | flush}.
   */
  writeBits(val: number, num: number): this;
  /**
   * Convenience for `writeChars(obj.toStr + "\n")`.  If obj is
   * null then print the string "null\n".  Return this.
   */
  printLine(obj?: JsObj | null): this;
  /**
   * Write two bytes as a 16-bit number using configured {@link endian | endian}.
   * This method may be paired with {@link InStream.readU2 | InStream.readU2}
   * or {@link InStream.readS2 | InStream.readS2}.  Throw IOErr on
   * error.  Return this.
   */
  writeI2(n: number): this;
  /**
   * Write n bytes from the specified Buf at its current position
   * to this output stream.  If n is defaulted to
   * buf.remaining(), then everything left in the buffer is
   * drained to this output stream. The buf's position is
   * advanced n bytes upon return.  Throw IOErr on error.  Return
   * this.
   */
  writeBuf(buf: Buf, n?: number): this;
  /**
   * Write eight bytes as a 64-bit number using configured {@link endian | endian}.
   * This is paired with {@link InStream.readS8 | InStream.readS8}.
   * Throw IOErr on error.  Return this.
   */
  writeI8(n: number): this;
  /**
   * Write a serialized object from the stream according to the
   * Fantom [serialization format](https://fantom.org/doc/docLang/Serialization).
   * Throw IOErr on error.  Return this.
   * 
   * The options may be used to specify the format of the output:
   * - "indent": Int specifies how many spaces to indent each
   *   level.  Default is 0.
   * - "skipDefaults": Bool specifies if we should skip fields at
   *   their default values.  Field values are compared according
   *   to the `equals` method.  Default is false.
   * - "skipErrors": Bool specifies if we should skip objects which
   *   aren't serializable. If true then we output null and a
   *   comment. Default is false.
   */
  writeObj(obj: JsObj | null, options?: Map<string, JsObj> | null): this;
  /**
   * If this output stream is mapped to a file device, then
   * synchronize all memory buffers to the physical storage
   * device. Throw IOErr on error.  Return this.
   */
  sync(): this;
  /**
   * Write one or more bytes to the stream for the specified
   * Unicode character based on the current charset encoding. 
   * Return this.
   */
  writeChar(char: number): this;
  /**
   * Convenience for `writeChars(obj.toStr)`.  If obj is null, then
   * print the string "null".  Return this.
   */
  print(s: JsObj | null): this;
  /**
   * Write a Str in modified UTF-8 format according to the `java.io.DataOutput`
   * specification.  This method is paired with {@link InStream.readUtf | InStream.readUtf}.
   * Throw IOErr on error.  Return this.
   */
  writeUtf(s: string): this;
  /**
   * Write a decimal as a string according to {@link writeUtf | writeUtf}.
   */
  writeDecimal(d: number): this;
  /**
   * Write the Unicode characters in the specified string to the
   * stream using the current charset encoding.  The off arg
   * specifies the index offset to start writing characters and
   * len the number of characters in str to write.  Return this.
   */
  writeChars(str: string, off?: number, len?: number): this;
}

/**
 * UnknownSlotErr indicates an attempt to access a non-existent
 * slot.
 */
export class UnknownSlotErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): UnknownSlotErr;
}

/**
 * IndexErr indicates an attempt to access an invalid index in
 * a List.
 */
export class IndexErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): IndexErr;
}

/**
 * Annotate a type or slot as undocumented.  This facet
 * indicates an API should not be documented with automated
 * tools such as [Fandoc](fandoc::pod-doc). As a developer you
 * should avoid using these types and slots since they are
 * explicitly marked as not part of the public API.
 */
export class NoDoc extends Obj implements Facet {
  static type$: Type
  /**
   * Singleton for NoDoc facet.
   */
  static defVal(): NoDoc;
}

/**
 * Services are used to publish functionality in a VM for use
 * by other software components.  The service registry for the
 * VM is keyed by public types each service implements.
 * 
 * The following table illustrates the service lifecycle:
 * ```
 * Method        isInstalled  isRunning
 * -----------   -----------  ----------
 * constructed   false        false
 * install       true         false
 * start         true         true
 * stop          true         false
 * uninstall     false        false
 * ```
 * 
 * While the service is installed, it may be looked up in the
 * registry via {@link find | find} and {@link findAll | findAll}.
 * The running state is used to invoke the {@link onStart | onStart}
 * and {@link onStop | onStop} callbacks which gives the service
 * a chance to setup/shutdown its actors and associated
 * resources.
 */
export abstract class Service extends Obj {
  static type$: Type
  /**
   * Is the service in the installed state. Note this method
   * requires accessing a global hash table, so it should not be
   * heavily polled in a concurrent environment.
   */
  isInstalled(): boolean;
  /**
   * Start this service.  If not installed, this method
   * automatically calls {@link install | install}.  If already
   * running, do nothing.  Return this.
   */
  start(): this;
  /**
   * List all the installed services.
   */
  static list(): List<Service>;
  /**
   * Find all services installed for the given type.  If no
   * services are found then return an empty list.
   */
  static findAll(t: Type): List<Service>;
  /**
   * Stop this service.  If not running, do nothing. Return this.
   */
  stop(): this;
  /**
   * Uninstall this service from the VM's service registry. If
   * the service is running, this method automatically calls {@link stop | stop}.
   * If not installed, do nothing.  Return this.
   */
  uninstall(): this;
  /**
   * Is the service in the running state. Note this method
   * requires accessing a global hash table, so it should not be
   * heavily polled in a concurrent environment.
   */
  isRunning(): boolean;
  /**
   * Install this service into the VM's service registry. If
   * already installed, do nothing.  Return this.
   */
  install(): this;
  /**
   * Find an installed service by type.  If not found and checked
   * is false return null, otherwise throw UnknownServiceErr.  If
   * multiple services are registered for the given type then
   * return the first one registered.
   */
  static find(t: Type, checked?: boolean): Service | null;
  /**
   * Services are required to implement equality by reference.
   */
  equals(that: JsObj | null): boolean;
  /**
   * Services are required to implement equality by reference.
   */
  hash(): number;
}

/**
 * Date represents a day in time independent of a timezone.
 */
export class Date extends Obj {
  static type$: Type
  /**
   * Default value is "2000-01-01".
   */
  static defVal(): Date;
  /**
   * Subtract the specified number of days to this date to get a
   * date in the past.  Throw ArgErr if `days` parameter is not a
   * whole number of days (must be evenly divisible by 24hr).
   * 
   * Example:
   * ```
   * Date(2008, Month.feb, 28) - 2day  =>  2008-02-26
   * ```
   */
  minus(days: Duration): Date;
  /**
   * Compare based on year, month, and day.
   */
  compare(obj: JsObj): number;
  /**
   * Get the first day of this Date's current month.
   * 
   * Example:
   * ```
   * Date("2009-10-28").firstOfMonth  =>  2009-10-01
   * ```
   */
  firstOfMonth(): Date;
  /**
   * Return the week number of the year as a number between 1 and
   * 53 using the given weekday as the start of the week
   * (defaults to current locale).
   */
  weekOfYear(startOfWeek?: Weekday): number;
  /**
   * Get the year as a number such as 2009.
   */
  year(): number;
  /**
   * Return the day of the year as a number between 1 and 365 (or
   * 1 to 366 if a leap year).
   */
  dayOfYear(): number;
  /**
   * Parse a string into a Date using the given pattern.  If
   * string is not a valid format then return null or raise
   * ParseErr based on checked flag.  See {@link toLocale | toLocale}
   * for pattern syntax.
   */
  static fromLocale(str: string, pattern: string, checked?: boolean): Date | null;
  /**
   * Get the day of the week for this date.
   */
  weekday(): Weekday;
  /**
   * Return is this date equal to {@link today | today}.
   */
  isToday(): boolean;
  /**
   * Get the Jan 1st of this Date's current year.
   * 
   * Example:
   * ```
   * Date("2025-10-28").firstOfYear  =>  2025-01-01
   * ```
   */
  firstOfYear(): Date;
  /**
   * Get yesterday's Date using specified timezone.
   */
  static yesterday(tz?: TimeZone): Date;
  /**
   * Get the last day of this Date's current month.
   * 
   * Example:
   * ```
   * Date("2009-10-28").lastOfMonth  =>  2009-10-31
   * ```
   */
  lastOfMonth(): Date;
  /**
   * Get the Dec 31st of this Date's current year.
   * 
   * Example:
   * ```
   * Date("2025-10-28").lastOfYear  =>  2025-12-31
   * ```
   */
  lastOfYear(): Date;
  /**
   * Get today's Date using specified timezone.
   */
  static today(tz?: TimeZone): Date;
  /**
   * Get the beginning of this date's three month quarter
   * 
   * Example:
   * ```
   * Date("2025-04-28").firstOfQuarter  =>  2025-04-01
   * ```
   */
  firstOfQuarter(): Date;
  /**
   * Return if this date is in the same year of `that`
   */
  isSameYear(that: Date): boolean;
  /**
   * Format this instance according to ISO 8601 using the
   * pattern:
   * ```
   * YYYY-MM-DD
   * ```
   * 
   * Also see {@link fromIso | fromIso} and {@link toStr | toStr}.
   */
  toIso(): string;
  /**
   * Make for the specified date values:
   * - year:  no restriction (although only 1901-2099 maps to
   *   DateTime)
   * - month: Month enumeration
   * - day:   1-31
   * 
   * Throw ArgErr if any of the parameters are out of range.
   */
  static make(year: number, month: Month, day: number, ...args: unknown[]): Date;
  /**
   * Get the day of the month as a number between 1 and 31.
   */
  day(): number;
  /**
   * Combine this Date with the given Time to return a DateTime.
   */
  toDateTime(t: Time, tz?: TimeZone): DateTime;
  /**
   * Return programmatic ISO 8601 string encoding formatted as
   * follows:
   * ```
   * YYYY-MM-DD
   * 2009-01-10
   * ```
   * 
   * Also {@link fromStr | fromStr}, {@link toIso | toIso}, and {@link toLocale | toLocale}.
   */
  toStr(): string;
  /**
   * Format this date according to the specified pattern.  If
   * pattern is null, then a localized default is used.  The
   * pattern format is the same as {@link DateTime.toLocale | DateTime.toLocale}:
   * ```
   * YY     Two digit year             07
   * YYYY   Four digit year            2007
   * M      One/two digit month        6, 11
   * MM     Two digit month            06, 11
   * MMM    Three letter abbr month    Jun, Nov
   * MMMM   Full month                 June, November
   * D      One/two digit day          5, 28
   * DD     Two digit day              05, 28
   * DDD    Day with suffix            1st, 2nd, 3rd, 24th
   * WWW    Three letter abbr weekday  Tue
   * WWWW   Full weekday               Tuesday
   * Q      Quarter number             3
   * QQQ    Quarter with suffix        3rd
   * QQQQ   Quarter spelled out        3rd Quarter
   * 'xyz'  Literal characters
   * ```
   */
  toLocale(pattern?: string | null, locale?: Locale): string;
  /**
   * Return a DateTime for the beginning of this day at midnight.
   */
  midnight(tz?: TimeZone): DateTime;
  /**
   * Get the end of this date's three month quarter
   * 
   * Example:
   * ```
   * Date("2025-04-28").lastOfQuarter  =>  2025-06-30
   * ```
   */
  lastOfQuarter(): Date;
  /**
   * Get this Date as a Fantom expression suitable for code
   * generation.
   */
  toCode(): string;
  /**
   * Get tomorrow's Date using specified timezone.
   */
  static tomorrow(tz?: TimeZone): Date;
  /**
   * Parse an ISO 8601 date.  If invalid format and checked is
   * false return null, otherwise throw ParseErr.  The following
   * format is supported:
   * ```
   * YYYY-MM-DD
   * ```
   * 
   * Also see {@link toIso | toIso} and {@link fromStr | fromStr}.
   */
  static fromIso(s: string, checked?: boolean): Date | null;
  /**
   * Return is this date equal to {@link today | today} + 1day.
   */
  isTomorrow(): boolean;
  /**
   * Add the specified number of days to this date to get a date
   * in the future.  Throw ArgErr if `days` parameter is not a
   * whole number of days (must be evenly divisible by 24hr).
   * 
   * Example:
   * ```
   * Date(2008, Month.feb, 28) + 2day  =>  2008-03-01
   * ```
   */
  plus(days: Duration): Date;
  /**
   * Convenience for `this < that`
   */
  isBefore(that: Date): boolean;
  /**
   * Return if this date is in the same year and month of `that`
   */
  isSameMonth(that: Date): boolean;
  /**
   * Parse the string into a Date from the programmatic encoding
   * defined by {@link toStr | toStr}.  If the string cannot be
   * parsed into a valid Date and checked is false then return
   * null, otherwise throw ParseErr.
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): Date;
  /**
   * Get the month of this date.
   */
  month(): Month;
  /**
   * Return the delta between this and the given date.  The
   * result is always an exact multiple of 24 hour days.
   * 
   * Example:
   * ```
   * Date(2009, Month.jan, 5) - Date(2009, Month.jan, 2)  =>  3day
   * ```
   */
  minusDate(days: Date): Duration;
  /**
   * Two dates are equal if they have the same year, month, and
   * day.
   */
  equals(that: JsObj | null): boolean;
  /**
   * Return is this date equal to {@link today | today} - 1day.
   */
  isYesterday(): boolean;
  /**
   * Convenience for `this > that`
   */
  isAfter(that: Date): boolean;
  /**
   * Return hash of year, month, and day.
   */
  hash(): number;
  /**
   * Integer between 1 and 4 for which of the three month
   * quarters this date falls in.
   */
  quarter(): number;
}

/**
 * FileStore represents the storage pool, device, partition, or
 * volume used to store files.
 */
export class FileStore extends Obj {
  static type$: Type
  /**
   * Number of bytes unallocated in the store or null if unknown.
   */
  freeSpace(): number | null;
  /**
   * Number of bytes available for use by the application or null
   * if unknown.
   */
  availSpace(): number | null;
  /**
   * Total number of bytes in the store or null if unknown.
   */
  totalSpace(): number | null;
}

/**
 * Universally Unique Identifier.  UUIDs are 128-bit
 * identifiers which are unique across space and time making
 * them ideal for naming without a central naming authority. 
 * Fantom's UUIDs are loosely based on RFC 4122 with the
 * following parts used in the generation:
 * - 8 bytes: nanosecond ticks since 1 Jan 2000 UTC
 * - 2 bytes: sequence number
 * - 6 bytes: node address
 * 
 * The sequence number is initialized from a randomized number,
 * and helps protect against collisions when the system clock
 * is changed. The node address is ideally mapped to the MAC
 * address if available, or the IP address hashed with a random
 * number.
 * 
 * No guarantee is made how the bytes are laid out.  Future
 * versions might hash these bytes, or use alternate
 * mechanisms.
 * 
 * The string format for the UUID follows the canonical format
 * of 32 hexadecimal digits displayed in five groups for
 * "8-4-4-4-12". For example:
 * ```
 * 03f0e2bb-8f1a-c800-e1f8-00623f7473c4
 * ```
 */
export class Uuid extends Obj {
  static type$: Type
  /**
   * Return the string representation of this UUID. See class
   * header for string format.
   */
  toStr(): string;
  /**
   * Compare based on the 128 bit value which will naturally
   * result in sorts by created timestamp.
   */
  compare(that: JsObj): number;
  /**
   * Get the least significant 64 bits of this 128 bit UUID.
   */
  bitsLo(): number;
  /**
   * Parse a UUID according to the string format defined in the
   * class header documentation.  If invalid format and checked
   * is false return null, otherwise throw ParseErr.
   */
  static fromStr(s: string, checked?: boolean, ...args: unknown[]): Uuid;
  /**
   * Create a 128-bit UUID from two 64-bit integers.
   */
  static makeBits(hi: number, lo: number): Uuid;
  /**
   * Return if the specified object is a Uuid with the same 128
   * bits.
   */
  equals(that: JsObj | null): boolean;
  /**
   * Generate a new UUID globally unique in space and time.
   */
  static make(...args: unknown[]): Uuid;
  /**
   * Hashcode is defined as `bitsHi ^ bitsLow`
   */
  hash(): number;
  /**
   * Get the most significant 64 bits of this 128 bit UUID.
   */
  bitsHi(): number;
}

/**
 * Param represents one parameter definition of a Func (or
 * Method).
 */
export class Param extends Obj {
  static type$: Type
  /**
   * Return "$type $name"
   */
  toStr(): string;
  /**
   * Type of the parameter.
   */
  type(): Type;
  /**
   * Return if this parameter has a default value.  If true, then
   * callers are not required to specify an argument.
   */
  hasDefault(): boolean;
  /**
   * Name of the parameter.
   */
  name(): string;
}

/**
 * UnknownServiceErr indicates an attempt to lookup a service
 * which is not installed.  See {@link Service.find | Service.find}.
 */
export class UnknownServiceErr extends Err {
  static type$: Type
  /**
   * Construct with specified error message and optional root
   * cause.
   */
  static make(msg?: string, cause?: Err | null, ...args: unknown[]): UnknownServiceErr;
}

export class ObjUtil {
  static hash(obj: any): number
  static equals(a: any, b: JsObj | null): boolean
  static compare(a: any, b: JsObj | null, op?: boolean): number
  static compareNE(a: any, b: JsObj | null): boolean
  static compareLT(a: any, b: JsObj | null): boolean
  static compareLE(a: any, b: JsObj | null): boolean
  static compareGE(a: any, b: JsObj | null): boolean
  static compareGT(a: any, b: JsObj | null): boolean
  static is(obj: any, type: Type): boolean
  static as(obj: any, type: Type): any
  static coerce(obj: any, type: Type): any
  static typeof(obj: any): Type
  static trap(obj: any, name: string, args: List<JsObj | null> | null): JsObj | null
  static doTrap(obj: any, name: string, args: List<JsObj | null> | null, type: Type): JsObj | null
  static isImmutable(obj: any): boolean
  static toImmutable(obj: any): JsObj | null
  static with<T>(self: T, f: ((it: T) => void)): T
  static toStr(obj: any): string
  static echo(obj: any): void
}
